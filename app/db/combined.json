[
    {
        "title": "Two Sum",
        "source": "https://leetcode.com/problems/two-sum/",
        "description": "<p>Given an array of integers <code>nums</code>&nbsp;and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p>\n\n<p>You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p>\n\n<p>You can return the answer in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,7,11,15], target = 9\n<strong>Output:</strong> [0,1]\n<strong>Explanation:</strong> Because nums[0] + nums[1] == 9, we return [0, 1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,4], target = 6\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,3], target = 6\n<strong>Output:</strong> [0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><strong>Only one valid answer exists.</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow-up:&nbsp;</strong>Can you come up with an algorithm that is less than <code>O(n<sup>2</sup>)</code><font face=\"monospace\">&nbsp;</font>time complexity?",
        "difficulty": "easy",
        "sample_test_cases": [
            "twoSum([2,7,11,15], 9)",
            "twoSum([3,2,4], 6)",
            "twoSum([3,3], 6)"
        ],
        "sample_test_results": [
            "[0, 1]",
            "[1, 2]",
            "[0, 1]"
        ],
        "hidden_test_cases": [
            "twoSum([49, 61, 74, 96, 29, 88, 53, -34, -48], 184)",
            "twoSum([62, 15, -95, 26, -65, 12, -86, -5, -40, -64, -91, -14, 20, -36, 83], -60)",
            "twoSum([-12, -75, 90, 56, -15, -55, -51, -27, 61, 24, -9, -58], -85)",
            "twoSum([-87, 21, -26, 13, -29, -53, -87, 11], -140)",
            "twoSum([-65, 6, 58, -29], -7)",
            "twoSum([-87, 54], -33)",
            "twoSum([-97, -10, 89], -8)",
            "twoSum([30, 57, -82, -8, 92, 99, 82, -76], 74)",
            "twoSum([75, -74, 40], 1)",
            "twoSum([-67, -35, 76, 71, -85, 91, -55, -42, 66, -28, 1, 89], 56)"
        ],
        "hidden_test_results": [
            "[3, 5]",
            "[3, 6]",
            "[7, 11]",
            "[0, 5]",
            "[0, 2]",
            "[0, 1]",
            "[0, 2]",
            "[3, 6]",
            "[0, 1]",
            "[1, 5]"
        ],
        "boilerplate": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        ",
        "compare_func": "return sorted(result) == sorted(eval(expected))"
    },
    {
        "title": "Palindrome Number",
        "source": "https://leetcode.com/problems/palindrome-number/",
        "description": "<p>Given an integer <code>x</code>, return <code>true</code><em> if </em><code>x</code><em> is a </em><span data-keyword=\"palindrome-integer\"><em><strong>palindrome</strong></em></span><em>, and </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 121\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 121 reads as 121 from left to right and from right to left.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = -121\n<strong>Output:</strong> false\n<strong>Explanation:</strong> From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 10\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Reads 01 from right to left. Therefore it is not a palindrome.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= x &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it without converting the integer to a string?",
        "difficulty": "easy",
        "sample_test_cases": [
            "isPalindrome(121)",
            "isPalindrome(-121)",
            "isPalindrome(10)"
        ],
        "sample_test_results": [
            "True",
            "False",
            "False"
        ],
        "hidden_test_cases": [
            "isPalindrome(0)",
            "isPalindrome(1234321)",
            "isPalindrome(-1)",
            "isPalindrome(1000)",
            "isPalindrome(12321)",
            "isPalindrome(100001)",
            "isPalindrome(2147483647)",
            "isPalindrome(-2147483648)",
            "isPalindrome(11)",
            "isPalindrome(1000021)"
        ],
        "hidden_test_results": [
            "True",
            "True",
            "False",
            "False",
            "True",
            "True",
            "False",
            "False",
            "True",
            "False"
        ],
        "boilerplate": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Longest Common Prefix",
        "source": "https://leetcode.com/problems/longest-common-prefix/",
        "description": "<p>Write a function to find the longest common prefix string amongst an array of strings.</p>\n\n<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]\n<strong>Output:</strong> &quot;fl&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> There is no common prefix among the input strings.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 200</code></li>\n\t<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>\n\t<li><code>strs[i]</code> consists of only lowercase English letters.</li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "longestCommonPrefix(['flower','flow','flight'])",
            "longestCommonPrefix(['dog','racecar','car'])"
        ],
        "sample_test_results": [
            "'fl'",
            "''"
        ],
        "hidden_test_cases": [
            "longestCommonPrefix(['interspecies','interstellar','interstate'])",
            "longestCommonPrefix(['throne','throne'])",
            "longestCommonPrefix([''])",
            "longestCommonPrefix(['a'])",
            "longestCommonPrefix(['','b'])",
            "longestCommonPrefix(['prefix','prefix','prefix'])",
            "longestCommonPrefix(['abc','def','ghi'])",
            "longestCommonPrefix(['flower','flower','flower','flower'])",
            "longestCommonPrefix(['x','xy','xyz'])",
            "longestCommonPrefix(['ab','a'])"
        ],
        "hidden_test_results": [
            "'inters'",
            "'throne'",
            "''",
            "'a'",
            "''",
            "'prefix'",
            "''",
            "'flower'",
            "'x'",
            "'a'"
        ],
        "boilerplate": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Valid Parentheses",
        "source": "https://leetcode.com/problems/valid-parentheses/",
        "description": "<p>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>\n\n<p>An input string is valid if:</p>\n\n<ol>\n\t<li>Open brackets must be closed by the same type of brackets.</li>\n\t<li>Open brackets must be closed in the correct order.</li>\n\t<li>Every close bracket has a corresponding open bracket of the same type.</li>\n</ol>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;()&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;()[]{}&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;(]&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">false</span></p>\n</div>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;([])&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of parentheses only <code>&#39;()[]{}&#39;</code>.</li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "isValid('()')",
            "isValid('()[]{}')",
            "isValid('(]')",
            "isValid('([])')"
        ],
        "sample_test_results": [
            "True",
            "True",
            "False",
            "True"
        ],
        "hidden_test_cases": [
            "isValid('{[]}')",
            "isValid('((()))')",
            "isValid('(()[]{})')",
            "isValid('}{}')",
            "isValid('')",
            "isValid('((())')",
            "isValid('())')",
            "isValid('([)]')",
            "isValid('{{{}}}')",
            "isValid('[({})]')"
        ],
        "hidden_test_results": [
            "True",
            "True",
            "True",
            "False",
            "True",
            "False",
            "False",
            "False",
            "True",
            "True"
        ],
        "boilerplate": "class Solution:\n    def isValid(self, s: str) -> bool:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Find the Index of the First Occurrence in a String",
        "source": "https://leetcode.com/problems/implement-strstr/",
        "description": "<p>Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> &quot;sad&quot; occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> &quot;leeto&quot; did not occur in &quot;leetcode&quot;, so we return -1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= haystack.length, needle.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>haystack</code> and <code>needle</code> consist of only lowercase English characters.</li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "strStr('sadbutsad', 'sad')",
            "strStr('leetcode', 'leeto')"
        ],
        "sample_test_results": [
            "0",
            "-1"
        ],
        "hidden_test_cases": [
            "strStr('hello', 'll')",
            "strStr('aaaaa', 'bba')",
            "strStr('', '')",
            "strStr('a', 'a')",
            "strStr('mississippi', 'issi')",
            "strStr('aaaaaa', 'aa')",
            "strStr('abc', 'c')",
            "strStr('hello world', 'world')",
            "strStr('abcabcd', 'abcd')",
            "strStr('testing', '')"
        ],
        "hidden_test_results": [
            "2",
            "-1",
            "0",
            "0",
            "1",
            "0",
            "2",
            "6",
            "3",
            "0"
        ],
        "boilerplate": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        ",
        "compare_func": "return result == int(expected)"
    },
    {
        "title": "Search Insert Position",
        "source": "https://leetcode.com/problems/search-insert-position/",
        "description": "<p>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>\n\n<p>You must&nbsp;write an algorithm with&nbsp;<code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,5,6], target = 5\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,5,6], target = 2\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,5,6], target = 7\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> contains <strong>distinct</strong> values sorted in <strong>ascending</strong> order.</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "searchInsert([1,3,5,6], 5)",
            "searchInsert([1,3,5,6], 2)",
            "searchInsert([1,3,5,6], 7)"
        ],
        "sample_test_results": [
            "2",
            "1",
            "4"
        ],
        "hidden_test_cases": [
            "searchInsert([1], 0)",
            "searchInsert([1], 2)",
            "searchInsert([1,3,5,6,8,10], 9)",
            "searchInsert([1,4,6,7,8,9], 6)",
            "searchInsert([-5,-3,0,1,3], -4)",
            "searchInsert([-3,-1,0,2], 1)",
            "searchInsert([1,2,3,4,5], 5)",
            "searchInsert([2,4,6,8], 1)",
            "searchInsert([1,3,5,7], 4)",
            "searchInsert([1,3,5,7,9], 8)"
        ],
        "hidden_test_results": [
            "0",
            "1",
            "5",
            "2",
            "1",
            "3",
            "4",
            "0",
            "2",
            "4"
        ],
        "boilerplate": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        ",
        "compare_func": "return result == int(expected)"
    },
    {
        "title": "Length of Last Word",
        "source": "https://leetcode.com/problems/length-of-last-word/",
        "description": "<p>Given a string <code>s</code> consisting of words and spaces, return <em>the length of the <strong>last</strong> word in the string.</em></p>\n\n<p>A <strong>word</strong> is a maximal <span data-keyword=\"substring-nonempty\">substring</span> consisting of non-space characters only.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;Hello World&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The last word is &quot;World&quot; with length 5.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;   fly me   to   the moon  &quot;\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The last word is &quot;moon&quot; with length 4.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;luffy is still joyboy&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The last word is &quot;joyboy&quot; with length 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of only English letters and spaces <code>&#39; &#39;</code>.</li>\n\t<li>There will be at least one word in <code>s</code>.</li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "lengthOfLastWord(\"Hello World\")",
            "lengthOfLastWord(\"   fly me   to   the moon  \")",
            "lengthOfLastWord(\"luffy is still joyboy\")"
        ],
        "sample_test_results": [
            "5",
            "4",
            "6"
        ],
        "hidden_test_cases": [
            "lengthOfLastWord(\"a\")",
            "lengthOfLastWord(\"hello   \")",
            "lengthOfLastWord(\"   space\")",
            "lengthOfLastWord(\"multiple   words   here\")",
            "lengthOfLastWord(\"oneword\")",
            "lengthOfLastWord(\"  spaces  between  words  \")",
            "lengthOfLastWord(\"trailing space  \")",
            "lengthOfLastWord(\"   leading space\")",
            "lengthOfLastWord(\"multiple     spaces     between\")",
            "lengthOfLastWord(\"z\")"
        ],
        "hidden_test_results": [
            "1",
            "5",
            "5",
            "4",
            "7",
            "5",
            "5",
            "5",
            "7",
            "1"
        ],
        "boilerplate": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        ",
        "compare_func": "return result == int(expected)"
    },
    {
        "title": "Plus One",
        "source": "https://leetcode.com/problems/plus-one/",
        "description": "<p>You are given a <strong>large integer</strong> represented as an integer array <code>digits</code>, where each <code>digits[i]</code> is the <code>i<sup>th</sup></code> digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading <code>0</code>&#39;s.</p>\n\n<p>Increment the large integer by one and return <em>the resulting array of digits</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [1,2,3]\n<strong>Output:</strong> [1,2,4]\n<strong>Explanation:</strong> The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [4,3,2,1]\n<strong>Output:</strong> [4,3,2,2]\n<strong>Explanation:</strong> The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [9]\n<strong>Output:</strong> [1,0]\n<strong>Explanation:</strong> The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= digits.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= digits[i] &lt;= 9</code></li>\n\t<li><code>digits</code> does not contain any leading <code>0</code>&#39;s.</li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "plusOne([1,2,3])",
            "plusOne([4,3,2,1])",
            "plusOne([9])"
        ],
        "sample_test_results": [
            "[1, 2, 4]",
            "[4, 3, 2, 2]",
            "[1, 0]"
        ],
        "hidden_test_cases": [
            "plusOne([0])",
            "plusOne([9,9])",
            "plusOne([1,0,0])",
            "plusOne([1,9,9])",
            "plusOne([9,8,9])",
            "plusOne([1,2,3,4])",
            "plusOne([9,9,9,9])",
            "plusOne([5,0,9])",
            "plusOne([1])",
            "plusOne([4,9,9,9])"
        ],
        "hidden_test_results": [
            "[1]",
            "[1, 0, 0]",
            "[1, 0, 1]",
            "[2, 0, 0]",
            "[9, 9, 0]",
            "[1, 2, 3, 5]",
            "[1, 0, 0, 0, 0]",
            "[5, 1, 0]",
            "[2]",
            "[5, 0, 0, 0]"
        ],
        "boilerplate": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        ",
        "compare_func": "return str(result) == expected"
    },
    {
        "title": "Add Binary",
        "source": "https://leetcode.com/problems/add-binary/",
        "description": "<p>Given two binary strings <code>a</code> and <code>b</code>, return <em>their sum as a binary string</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> a = \"11\", b = \"1\"\n<strong>Output:</strong> \"100\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> a = \"1010\", b = \"1011\"\n<strong>Output:</strong> \"10101\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>a</code> and <code>b</code> consist&nbsp;only of <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code> characters.</li>\n\t<li>Each string does not contain leading zeros except for the zero itself.</li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "addBinary(\"11\", \"1\")",
            "addBinary(\"1010\", \"1011\")"
        ],
        "sample_test_results": [
            "'100'",
            "'10101'"
        ],
        "hidden_test_cases": [
            "addBinary(\"0\", \"0\")",
            "addBinary(\"1\", \"1\")",
            "addBinary(\"111\", \"111\")",
            "addBinary(\"1111\", \"1111\")",
            "addBinary(\"1010\", \"0101\")",
            "addBinary(\"100\", \"110\")",
            "addBinary(\"11\", \"11\")",
            "addBinary(\"1\", \"111\")",
            "addBinary(\"1000\", \"1100\")",
            "addBinary(\"1111\", \"1\")"
        ],
        "hidden_test_results": [
            "'0'",
            "'10'",
            "'1110'",
            "'11110'",
            "'1111'",
            "'1010'",
            "'110'",
            "'1000'",
            "'10100'",
            "'10000'"
        ],
        "boilerplate": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Climbing Stairs",
        "source": "https://leetcode.com/problems/climbing-stairs/",
        "description": "<p>You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p>\n\n<p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 45</code></li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "climbStairs(2)",
            "climbStairs(3)"
        ],
        "sample_test_results": [
            "2",
            "3"
        ],
        "hidden_test_cases": [
            "climbStairs(1)",
            "climbStairs(4)",
            "climbStairs(5)",
            "climbStairs(6)",
            "climbStairs(7)",
            "climbStairs(8)",
            "climbStairs(9)",
            "climbStairs(10)",
            "climbStairs(20)",
            "climbStairs(30)"
        ],
        "hidden_test_results": [
            "1",
            "5",
            "8",
            "13",
            "21",
            "34",
            "55",
            "89",
            "10946",
            "1346269"
        ],
        "boilerplate": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        ",
        "compare_func": "return result == int(expected)"
    },
    {
        "title": "Best Time to Buy and Sell Stock",
        "source": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
        "description": "<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>\n\n<p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p>\n\n<p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,1,5,3,6,4]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,6,4,3,1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> In this case, no transactions are done and the max profit = 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "maxProfit([7,1,5,3,6,4])",
            "maxProfit([7,6,4,3,1])",
            "maxProfit([2,4,1,7])"
        ],
        "sample_test_results": [
            "5",
            "0",
            "6"
        ],
        "hidden_test_cases": [
            "maxProfit([1])",
            "maxProfit([1,2])",
            "maxProfit([2,1])",
            "maxProfit([3,3,3])",
            "maxProfit([1,2,4,2,5,7,2,4,9,0])",
            "maxProfit([2,1,2,1,0,1,2])",
            "maxProfit([9,8,7,6,5,4,3,2,1])",
            "maxProfit([1,4,1,4,3,1])",
            "maxProfit([10000,9999,9998,9997])",
            "maxProfit([0,2,0,2,0,2])"
        ],
        "hidden_test_results": [
            "0",
            "1",
            "0",
            "0",
            "8",
            "2",
            "0",
            "3",
            "0",
            "2"
        ],
        "boilerplate": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        ",
        "compare_func": "return str(result) == expected"
    },
    {
        "title": "Valid Palindrome",
        "source": "https://leetcode.com/problems/valid-palindrome/",
        "description": "<p>A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p>\n\n<p>Given a string <code>s</code>, return <code>true</code><em> if it is a <strong>palindrome</strong>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;A man, a plan, a canal: Panama&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> &quot;amanaplanacanalpanama&quot; is a palindrome.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;race a car&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> &quot;raceacar&quot; is not a palindrome.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot; &quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> s is an empty string &quot;&quot; after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists only of printable ASCII characters.</li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "isPalindrome(\"A man, a plan, a canal: Panama\")",
            "isPalindrome(\"race a car\")",
            "isPalindrome(\" \")"
        ],
        "sample_test_results": [
            "True",
            "False",
            "True"
        ],
        "hidden_test_cases": [
            "isPalindrome(\"\")",
            "isPalindrome(\".,\")",
            "isPalindrome(\"0P\")",
            "isPalindrome(\"abc123cba\")",
            "isPalindrome(\"Race a Car\")",
            "isPalindrome(\"!@#$%^&*()\")",
            "isPalindrome(\"12321\")",
            "isPalindrome(\"Never odd or even\")",
            "isPalindrome(\"a\")",
            "isPalindrome(\".,a,.\")"
        ],
        "hidden_test_results": [
            "True",
            "True",
            "False",
            "False",
            "False",
            "True",
            "True",
            "True",
            "True",
            "True"
        ],
        "boilerplate": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        ",
        "compare_func": "return str(result).lower() == expected.lower()"
    },
    {
        "title": "Excel Sheet Column Title",
        "source": "https://leetcode.com/problems/excel-sheet-column-title/",
        "description": "<p>Given an integer <code>columnNumber</code>, return <em>its corresponding column title as it appears in an Excel sheet</em>.</p>\n\n<p>For example:</p>\n\n<pre>\nA -&gt; 1\nB -&gt; 2\nC -&gt; 3\n...\nZ -&gt; 26\nAA -&gt; 27\nAB -&gt; 28 \n...\n</pre>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnNumber = 1\n<strong>Output:</strong> &quot;A&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnNumber = 28\n<strong>Output:</strong> &quot;AB&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnNumber = 701\n<strong>Output:</strong> &quot;ZY&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= columnNumber &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "convertToTitle(1)",
            "convertToTitle(28)",
            "convertToTitle(701)"
        ],
        "sample_test_results": [
            "'A'",
            "'AB'",
            "'ZY'"
        ],
        "hidden_test_cases": [
            "convertToTitle(26)",
            "convertToTitle(27)",
            "convertToTitle(52)",
            "convertToTitle(676)",
            "convertToTitle(702)",
            "convertToTitle(1000)",
            "convertToTitle(2147483647)",
            "convertToTitle(18278)",
            "convertToTitle(17576)",
            "convertToTitle(18277)"
        ],
        "hidden_test_results": [
            "'Z'",
            "'AA'",
            "'AZ'",
            "'YZ'",
            "'ZZ'",
            "'ALL'",
            "'FXSHRXW'",
            "'ZZZ'",
            "'YYZ'",
            "'ZZY'"
        ],
        "boilerplate": "class Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Happy Number",
        "source": "https://leetcode.com/problems/happy-number/",
        "description": "<p>Write an algorithm to determine if a number <code>n</code> is happy.</p>\n\n<p>A <strong>happy number</strong> is a number defined by the following process:</p>\n\n<ul>\n\t<li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li>\n\t<li>Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.</li>\n\t<li>Those numbers for which this process <strong>ends in 1</strong> are happy.</li>\n</ul>\n\n<p>Return <code>true</code> <em>if</em> <code>n</code> <em>is a happy number, and</em> <code>false</code> <em>if not</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 19\n<strong>Output:</strong> true\n<strong>Explanation:</strong>\n1<sup>2</sup> + 9<sup>2</sup> = 82\n8<sup>2</sup> + 2<sup>2</sup> = 68\n6<sup>2</sup> + 8<sup>2</sup> = 100\n1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "isHappy(19)",
            "isHappy(2)",
            "isHappy(7)"
        ],
        "sample_test_results": [
            "True",
            "False",
            "True"
        ],
        "hidden_test_cases": [
            "isHappy(1)",
            "isHappy(4)",
            "isHappy(16)",
            "isHappy(89)",
            "isHappy(100)",
            "isHappy(1111111)",
            "isHappy(999999)",
            "isHappy(123)",
            "isHappy(3)",
            "isHappy(44)"
        ],
        "hidden_test_results": [
            "True",
            "False",
            "False",
            "False",
            "True",
            "True",
            "False",
            "False",
            "False",
            "True"
        ],
        "boilerplate": "class Solution:\n    def isHappy(self, n: int) -> bool:\n        ",
        "compare_func": "return str(result).lower() == expected.lower()"
    },
    {
        "title": "Isomorphic Strings",
        "source": "https://leetcode.com/problems/isomorphic-strings/",
        "description": "<p>Given two strings <code>s</code> and <code>t</code>, <em>determine if they are isomorphic</em>.</p>\n\n<p>Two strings <code>s</code> and <code>t</code> are isomorphic if the characters in <code>s</code> can be replaced to get <code>t</code>.</p>\n\n<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;egg&quot;, t = &quot;add&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The strings <code>s</code> and <code>t</code> can be made identical by:</p>\n\n<ul>\n\t<li>Mapping <code>&#39;e&#39;</code> to <code>&#39;a&#39;</code>.</li>\n\t<li>Mapping <code>&#39;g&#39;</code> to <code>&#39;d&#39;</code>.</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;foo&quot;, t = &quot;bar&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">false</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The strings <code>s</code> and <code>t</code> can not be made identical as <code>&#39;o&#39;</code> needs to be mapped to both <code>&#39;a&#39;</code> and <code>&#39;r&#39;</code>.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;paper&quot;, t = &quot;title&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>t.length == s.length</code></li>\n\t<li><code>s</code> and <code>t</code> consist of any valid ascii character.</li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "isIsomorphic(\"egg\", \"add\")",
            "isIsomorphic(\"foo\", \"bar\")",
            "isIsomorphic(\"paper\", \"title\")"
        ],
        "sample_test_results": [
            "True",
            "False",
            "True"
        ],
        "hidden_test_cases": [
            "isIsomorphic(\"\", \"\")",
            "isIsomorphic(\"a\", \"b\")",
            "isIsomorphic(\"ab\", \"aa\")",
            "isIsomorphic(\"badc\", \"bada\")",
            "isIsomorphic(\"abcde\", \"vwxyz\")",
            "isIsomorphic(\"hello\", \"world\")",
            "isIsomorphic(\"aaaa\", \"bbbb\")",
            "isIsomorphic(\"ab\", \"cd\")",
            "isIsomorphic(\"13\", \"42\")",
            "isIsomorphic(\"ACAB\", \"XCXY\")"
        ],
        "hidden_test_results": [
            "True",
            "True",
            "False",
            "False",
            "True",
            "False",
            "True",
            "True",
            "True",
            "True"
        ],
        "boilerplate": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        ",
        "compare_func": "return str(result).lower() == expected.lower()"
    },
    {
        "title": "Contains Duplicate II",
        "source": "https://leetcode.com/problems/contains-duplicate-ii/",
        "description": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <code>true</code> <em>if there are two <strong>distinct indices</strong> </em><code>i</code><em> and </em><code>j</code><em> in the array such that </em><code>nums[i] == nums[j]</code><em> and </em><code>abs(i - j) &lt;= k</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1], k = 3\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,1,1], k = 1\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1,2,3], k = 2\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "containsNearbyDuplicate([1,2,3,1], 3)",
            "containsNearbyDuplicate([1,0,1,1], 1)",
            "containsNearbyDuplicate([1,2,3,1,2,3], 2)"
        ],
        "sample_test_results": [
            "True",
            "True",
            "False"
        ],
        "hidden_test_cases": [
            "containsNearbyDuplicate([1,2,3,4,5], 2)",
            "containsNearbyDuplicate([1,1], 1)",
            "containsNearbyDuplicate([1,2,1], 0)",
            "containsNearbyDuplicate([1,2,3,4,1], 4)",
            "containsNearbyDuplicate([1,2,3,4,1], 3)",
            "containsNearbyDuplicate([-1,-1], 1)",
            "containsNearbyDuplicate([1], 1)",
            "containsNearbyDuplicate([1,2,3,4,2], 3)",
            "containsNearbyDuplicate([1,1,1,1], 2)",
            "containsNearbyDuplicate([1,2,1,2], 2)"
        ],
        "hidden_test_results": [
            "False",
            "True",
            "False",
            "True",
            "False",
            "True",
            "False",
            "True",
            "True",
            "True"
        ],
        "boilerplate": "class Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        ",
        "compare_func": "return str(result).lower() == expected.lower()"
    },
    {
        "title": "Summary Ranges",
        "source": "https://leetcode.com/problems/summary-ranges/",
        "description": "<p>You are given a <strong>sorted unique</strong> integer array <code>nums</code>.</p>\n\n<p>A <strong>range</strong> <code>[a,b]</code> is the set of all integers from <code>a</code> to <code>b</code> (inclusive).</p>\n\n<p>Return <em>the <strong>smallest sorted</strong> list of ranges that <strong>cover all the numbers in the array exactly</strong></em>. That is, each element of <code>nums</code> is covered by exactly one of the ranges, and there is no integer <code>x</code> such that <code>x</code> is in one of the ranges but not in <code>nums</code>.</p>\n\n<p>Each range <code>[a,b]</code> in the list should be output as:</p>\n\n<ul>\n\t<li><code>&quot;a-&gt;b&quot;</code> if <code>a != b</code></li>\n\t<li><code>&quot;a&quot;</code> if <code>a == b</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,2,4,5,7]\n<strong>Output:</strong> [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]\n<strong>Explanation:</strong> The ranges are:\n[0,2] --&gt; &quot;0-&gt;2&quot;\n[4,5] --&gt; &quot;4-&gt;5&quot;\n[7,7] --&gt; &quot;7&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,2,3,4,6,8,9]\n<strong>Output:</strong> [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]\n<strong>Explanation:</strong> The ranges are:\n[0,0] --&gt; &quot;0&quot;\n[2,4] --&gt; &quot;2-&gt;4&quot;\n[6,6] --&gt; &quot;6&quot;\n[8,9] --&gt; &quot;8-&gt;9&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 20</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>All the values of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is sorted in ascending order.</li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "summaryRanges([0,1,2,4,5,7])",
            "summaryRanges([0,2,3,4,6,8,9])",
            "summaryRanges([])"
        ],
        "sample_test_results": [
            "['0->2', '4->5', '7']",
            "['0', '2->4', '6', '8->9']",
            "[]"
        ],
        "hidden_test_cases": [
            "summaryRanges([1])",
            "summaryRanges([1,2])",
            "summaryRanges([1,3,5,7])",
            "summaryRanges([1,2,3,4,5])",
            "summaryRanges([-1,0,1,2])",
            "summaryRanges([-5,-4,-3,-1,0,2])",
            "summaryRanges([1,3])",
            "summaryRanges([1,2,4,6,7,8])",
            "summaryRanges([0,1,3,5,6,7,9])",
            "summaryRanges([-2147483648,2147483647])"
        ],
        "hidden_test_results": [
            "['1']",
            "['1->2']",
            "['1', '3', '5', '7']",
            "['1->5']",
            "['-1->2']",
            "['-5->-3', '-1->0', '2']",
            "['1', '3']",
            "['1->2', '4', '6->8']",
            "['0->1', '3', '5->7', '9']",
            "['-2147483648', '2147483647']"
        ],
        "boilerplate": "class Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        ",
        "compare_func": "return sorted(result) == sorted(eval(expected))"
    },
    {
        "title": "Power of Two",
        "source": "https://leetcode.com/problems/power-of-two/",
        "description": "<p>Given an integer <code>n</code>, return <em><code>true</code> if it is a power of two. Otherwise, return <code>false</code></em>.</p>\n\n<p>An integer <code>n</code> is a power of two, if there exists an integer <code>x</code> such that <code>n == 2<sup>x</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> true\n<strong>Explanation: </strong>2<sup>0</sup> = 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 16\n<strong>Output:</strong> true\n<strong>Explanation: </strong>2<sup>4</sup> = 16\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it without loops/recursion?",
        "difficulty": "easy",
        "sample_test_cases": [
            "isPowerOfTwo(1)",
            "isPowerOfTwo(16)",
            "isPowerOfTwo(3)"
        ],
        "sample_test_results": [
            "True",
            "True",
            "False"
        ],
        "hidden_test_cases": [
            "isPowerOfTwo(0)",
            "isPowerOfTwo(-16)",
            "isPowerOfTwo(2)",
            "isPowerOfTwo(4)",
            "isPowerOfTwo(5)",
            "isPowerOfTwo(32)",
            "isPowerOfTwo(64)",
            "isPowerOfTwo(100)",
            "isPowerOfTwo(2147483647)",
            "isPowerOfTwo(-2147483648)"
        ],
        "hidden_test_results": [
            "False",
            "False",
            "True",
            "True",
            "False",
            "True",
            "True",
            "False",
            "False",
            "False"
        ],
        "boilerplate": "class Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        ",
        "compare_func": "return str(result).lower() == expected.lower()"
    },
    {
        "title": "Ugly Number",
        "source": "https://leetcode.com/problems/ugly-number/",
        "description": "<p>An <strong>ugly number</strong> is a positive integer whose prime factors are limited to <code>2</code>, <code>3</code>, and <code>5</code>.</p>\n\n<p>Given an integer <code>n</code>, return <code>true</code> <em>if</em> <code>n</code> <em>is an <strong>ugly number</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 6\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 6 = 2 &times; 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 14\n<strong>Output:</strong> false\n<strong>Explanation:</strong> 14 is not ugly since it includes the prime factor 7.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "isUgly(6)",
            "isUgly(1)",
            "isUgly(14)"
        ],
        "sample_test_results": [
            "True",
            "True",
            "False"
        ],
        "hidden_test_cases": [
            "isUgly(8)",
            "isUgly(0)",
            "isUgly(-6)",
            "isUgly(25)",
            "isUgly(15)",
            "isUgly(49)",
            "isUgly(30)",
            "isUgly(100)",
            "isUgly(-2147483648)",
            "isUgly(2147483647)"
        ],
        "hidden_test_results": [
            "True",
            "False",
            "False",
            "True",
            "True",
            "False",
            "True",
            "True",
            "False",
            "False"
        ],
        "boilerplate": "class Solution:\n    def isUgly(self, n: int) -> bool:\n        ",
        "compare_func": "return str(result).lower() == expected.lower()"
    },
    {
        "title": "Word Pattern",
        "source": "https://leetcode.com/problems/word-pattern/",
        "description": "<p>Given a <code>pattern</code> and a string <code>s</code>, find if <code>s</code>&nbsp;follows the same pattern.</p>\n\n<p>Here <b>follow</b> means a full match, such that there is a bijection between a letter in <code>pattern</code> and a <b>non-empty</b> word in <code>s</code>. Specifically:</p>\n\n<ul>\n\t<li>Each letter in <code>pattern</code> maps to <strong>exactly</strong> one unique word in <code>s</code>.</li>\n\t<li>Each unique word in <code>s</code> maps to <strong>exactly</strong> one letter in <code>pattern</code>.</li>\n\t<li>No two letters map to the same word, and no two words map to the same letter.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">pattern = &quot;abba&quot;, s = &quot;dog cat cat dog&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">true</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The bijection can be established as:</p>\n\n<ul>\n\t<li><code>&#39;a&#39;</code> maps to <code>&quot;dog&quot;</code>.</li>\n\t<li><code>&#39;b&#39;</code> maps to <code>&quot;cat&quot;</code>.</li>\n</ul>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">pattern = &quot;abba&quot;, s = &quot;dog cat cat fish&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">false</span></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">pattern = &quot;aaaa&quot;, s = &quot;dog cat cat dog&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">false</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pattern.length &lt;= 300</code></li>\n\t<li><code>pattern</code> contains only lower-case English letters.</li>\n\t<li><code>1 &lt;= s.length &lt;= 3000</code></li>\n\t<li><code>s</code> contains only lowercase English letters and spaces <code>&#39; &#39;</code>.</li>\n\t<li><code>s</code> <strong>does not contain</strong> any leading or trailing spaces.</li>\n\t<li>All the words in <code>s</code> are separated by a <strong>single space</strong>.</li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "wordPattern(\"abba\", \"dog cat cat dog\")",
            "wordPattern(\"abba\", \"dog cat cat fish\")",
            "wordPattern(\"aaaa\", \"dog cat cat dog\")"
        ],
        "sample_test_results": [
            "True",
            "False",
            "False"
        ],
        "hidden_test_cases": [
            "wordPattern(\"abc\", \"dog cat dog\")",
            "wordPattern(\"jquery\", \"jquery\")",
            "wordPattern(\"aaa\", \"aa aa aa\")",
            "wordPattern(\"abba\", \"dog dog dog dog\")",
            "wordPattern(\"ab\", \"dog cat\")",
            "wordPattern(\"abc\", \"b c a\")",
            "wordPattern(\"aabb\", \"cat cat dog dog\")",
            "wordPattern(\"abba\", \"dog cat cat fish\")",
            "wordPattern(\"\", \"\")",
            "wordPattern(\"a\", \"dog\")"
        ],
        "hidden_test_results": [
            "False",
            "False",
            "True",
            "False",
            "True",
            "True",
            "True",
            "False",
            "True",
            "True"
        ],
        "boilerplate": "class Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        ",
        "compare_func": "return str(result).lower() == expected.lower()"
    },
    {
        "title": "Nim Game",
        "source": "https://leetcode.com/problems/nim-game/",
        "description": "<p>You are playing the following Nim Game with your friend:</p>\n\n<ul>\n\t<li>Initially, there is a heap of stones on the table.</li>\n\t<li>You and your friend will alternate taking turns, and <strong>you go first</strong>.</li>\n\t<li>On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.</li>\n\t<li>The one who removes the last stone is the winner.</li>\n</ul>\n\n<p>Given <code>n</code>, the number of stones in the heap, return <code>true</code><em> if you can win the game assuming both you and your friend play optimally, otherwise return </em><code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> false\n<strong>Explanation:</strong> These are the possible outcomes:\n1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.\n2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.\n3. You remove 3 stones. Your friend removes the last stone. Your friend wins.\nIn all outcomes, your friend wins.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "canWinNim(4)",
            "canWinNim(1)",
            "canWinNim(2)"
        ],
        "sample_test_results": [
            "False",
            "True",
            "True"
        ],
        "hidden_test_cases": [
            "canWinNim(3)",
            "canWinNim(5)",
            "canWinNim(6)",
            "canWinNim(7)",
            "canWinNim(8)",
            "canWinNim(9)",
            "canWinNim(10)",
            "canWinNim(100)",
            "canWinNim(1000000)",
            "canWinNim(2147483647)"
        ],
        "hidden_test_results": [
            "True",
            "True",
            "True",
            "True",
            "False",
            "True",
            "True",
            "False",
            "False",
            "True"
        ],
        "boilerplate": "class Solution:\n    def canWinNim(self, n: int) -> bool:\n        ",
        "compare_func": "return str(result).lower() == expected.lower()"
    },
    {
        "title": "Power of Three",
        "source": "https://leetcode.com/problems/power-of-three/",
        "description": "<p>Given an integer <code>n</code>, return <em><code>true</code> if it is a power of three. Otherwise, return <code>false</code></em>.</p>\n\n<p>An integer <code>n</code> is a power of three, if there exists an integer <code>x</code> such that <code>n == 3<sup>x</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 27\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 27 = 3<sup>3</sup>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no x where 3<sup>x</sup> = 0.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = -1\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no x where 3<sup>x</sup> = (-1).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it without loops/recursion?",
        "difficulty": "easy",
        "sample_test_cases": [
            "isPowerOfThree(27)",
            "isPowerOfThree(0)",
            "isPowerOfThree(-1)"
        ],
        "sample_test_results": [
            "True",
            "False",
            "False"
        ],
        "hidden_test_cases": [
            "isPowerOfThree(1)",
            "isPowerOfThree(9)",
            "isPowerOfThree(45)",
            "isPowerOfThree(81)",
            "isPowerOfThree(243)",
            "isPowerOfThree(-3)",
            "isPowerOfThree(2)",
            "isPowerOfThree(99)",
            "isPowerOfThree(19683)",
            "isPowerOfThree(-729)"
        ],
        "hidden_test_results": [
            "True",
            "True",
            "False",
            "True",
            "True",
            "False",
            "False",
            "False",
            "True",
            "False"
        ],
        "boilerplate": "class Solution:\n    def isPowerOfThree(self, n: int) -> bool:\n        ",
        "compare_func": "return str(result).lower() == expected.lower()"
    },
    {
        "title": "Power of Four",
        "source": "https://leetcode.com/problems/power-of-four/",
        "description": "<p>Given an integer <code>n</code>, return <em><code>true</code> if it is a power of four. Otherwise, return <code>false</code></em>.</p>\n\n<p>An integer <code>n</code> is a power of four, if there exists an integer <code>x</code> such that <code>n == 4<sup>x</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 16\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 5\n<strong>Output:</strong> false\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> n = 1\n<strong>Output:</strong> true\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it without loops/recursion?",
        "difficulty": "easy",
        "sample_test_cases": [
            "isPowerOfFour(16)",
            "isPowerOfFour(5)",
            "isPowerOfFour(1)"
        ],
        "sample_test_results": [
            "True",
            "False",
            "True"
        ],
        "hidden_test_cases": [
            "isPowerOfFour(4)",
            "isPowerOfFour(64)",
            "isPowerOfFour(8)",
            "isPowerOfFour(256)",
            "isPowerOfFour(-4)",
            "isPowerOfFour(0)",
            "isPowerOfFour(2)",
            "isPowerOfFour(100)",
            "isPowerOfFour(1024)",
            "isPowerOfFour(-1024)"
        ],
        "hidden_test_results": [
            "True",
            "True",
            "False",
            "True",
            "False",
            "False",
            "False",
            "False",
            "True",
            "False"
        ],
        "boilerplate": "class Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        ",
        "compare_func": "return str(result).lower() == expected.lower()"
    },
    {
        "title": "Reverse Vowels of a String",
        "source": "https://leetcode.com/problems/reverse-vowels-of-a-string/",
        "description": "<p>Given a string <code>s</code>, reverse only all the vowels in the string and return it.</p>\n\n<p>The vowels are <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, and <code>&#39;u&#39;</code>, and they can appear in both lower and upper cases, more than once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;IceCreAm&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;AceCreIm&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The vowels in <code>s</code> are <code>[&#39;I&#39;, &#39;e&#39;, &#39;e&#39;, &#39;A&#39;]</code>. On reversing the vowels, s becomes <code>&quot;AceCreIm&quot;</code>.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">s = &quot;leetcode&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;leotcede&quot;</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consist of <strong>printable ASCII</strong> characters.</li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "reverseVowels('IceCreAm')",
            "reverseVowels('leetcode')"
        ],
        "sample_test_results": [
            "'AceCreIm'",
            "'leotcede'"
        ],
        "hidden_test_cases": [
            "reverseVowels('hello')",
            "reverseVowels('aA')",
            "reverseVowels('race a car')",
            "reverseVowels('')",
            "reverseVowels('xyz')",
            "reverseVowels('AEIOU')",
            "reverseVowels('aeiou')",
            "reverseVowels('.,!')",
            "reverseVowels('Aa')",
            "reverseVowels('LEetcOde')"
        ],
        "hidden_test_results": [
            "'holle'",
            "'Aa'",
            "'raca e car'",
            "''",
            "'xyz'",
            "'UOIEA'",
            "'uoiea'",
            "'.,!'",
            "'aA'",
            "'LeOtcedE'"
        ],
        "boilerplate": "class Solution:\n    def reverseVowels(self, s: str) -> str:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Intersection of Two Arrays II",
        "source": "https://leetcode.com/problems/intersection-of-two-arrays-ii/",
        "description": "<p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must appear as many times as it shows in both arrays and you may return the result in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2,2,1], nums2 = [2,2]\n<strong>Output:</strong> [2,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n<strong>Output:</strong> [4,9]\n<strong>Explanation:</strong> [9,4] is also accepted.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>What if the given array is already sorted? How would you optimize your algorithm?</li>\n\t<li>What if <code>nums1</code>&#39;s size is small compared to <code>nums2</code>&#39;s size? Which algorithm is better?</li>\n\t<li>What if elements of <code>nums2</code> are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "intersect([1,2,2,1], [2,2])",
            "intersect([4,9,5], [9,4,9,8,4])"
        ],
        "sample_test_results": [
            "[2, 2]",
            "[9, 4]"
        ],
        "hidden_test_cases": [
            "intersect([1,1,1], [1,1])",
            "intersect([1,2], [1,1])",
            "intersect([1], [1])",
            "intersect([1,2,3], [4,5,6])",
            "intersect([1,2,3,4], [1,2,3,4])",
            "intersect([1,1,1,1], [1])",
            "intersect([], [1])",
            "intersect([1,2,2,3], [2,2,2,3])",
            "intersect([1,2,3,4,5], [5,4,3,2,1])",
            "intersect([1000,1000], [1000,1000])"
        ],
        "hidden_test_results": [
            "[1, 1]",
            "[1]",
            "[1]",
            "[]",
            "[1, 2, 3, 4]",
            "[1]",
            "[]",
            "[2, 2, 3]",
            "[5, 4, 3, 2, 1]",
            "[1000, 1000]"
        ],
        "boilerplate": "class Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        ",
        "compare_func": "return sorted(result) == sorted(eval(expected))"
    },
    {
        "title": "Valid Perfect Square",
        "source": "https://leetcode.com/problems/valid-perfect-square/",
        "description": "<p>Given a positive integer num, return <code>true</code> <em>if</em> <code>num</code> <em>is a perfect square or</em> <code>false</code> <em>otherwise</em>.</p>\n\n<p>A <strong>perfect square</strong> is an integer that is the square of an integer. In other words, it is the product of some integer with itself.</p>\n\n<p>You must not use any built-in library function, such as <code>sqrt</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 16\n<strong>Output:</strong> true\n<strong>Explanation:</strong> We return true because 4 * 4 = 16 and 4 is an integer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 14\n<strong>Output:</strong> false\n<strong>Explanation:</strong> We return false because 3.742 * 3.742 = 14 and 3.742 is not an integer.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "isPerfectSquare(16)",
            "isPerfectSquare(14)",
            "isPerfectSquare(1)"
        ],
        "sample_test_results": [
            "True",
            "False",
            "True"
        ],
        "hidden_test_cases": [
            "isPerfectSquare(0)",
            "isPerfectSquare(4)",
            "isPerfectSquare(9)",
            "isPerfectSquare(25)",
            "isPerfectSquare(26)",
            "isPerfectSquare(100)",
            "isPerfectSquare(2147483647)",
            "isPerfectSquare(808201)",
            "isPerfectSquare(2)",
            "isPerfectSquare(3)"
        ],
        "hidden_test_results": [
            "True",
            "True",
            "True",
            "True",
            "False",
            "True",
            "False",
            "True",
            "False",
            "False"
        ],
        "boilerplate": "class Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        ",
        "compare_func": "return str(result).lower() == expected.lower()"
    },
    {
        "title": "Find the Difference",
        "source": "https://leetcode.com/problems/find-the-difference/",
        "description": "<p>You are given two strings <code>s</code> and <code>t</code>.</p>\n\n<p>String <code>t</code> is generated by random shuffling string <code>s</code> and then add one more letter at a random position.</p>\n\n<p>Return the letter that was added to <code>t</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcd&quot;, t = &quot;abcde&quot;\n<strong>Output:</strong> &quot;e&quot;\n<strong>Explanation:</strong> &#39;e&#39; is the letter that was added.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;&quot;, t = &quot;y&quot;\n<strong>Output:</strong> &quot;y&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>t.length == s.length + 1</code></li>\n\t<li><code>s</code> and <code>t</code> consist of lowercase English letters.</li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "findTheDifference('abcd', 'abcde')",
            "findTheDifference('', 'y')",
            "findTheDifference('ae', 'aea')"
        ],
        "sample_test_results": [
            "'e'",
            "'y'",
            "'a'"
        ],
        "hidden_test_cases": [
            "findTheDifference('abcd', 'abcde')",
            "findTheDifference('', 'y')",
            "findTheDifference('a', 'aa')",
            "findTheDifference('ae', 'aea')",
            "findTheDifference('abc', 'cabd')",
            "findTheDifference('xyz', 'xyzz')",
            "findTheDifference('aaa', 'aaaa')",
            "findTheDifference('bb', 'bbb')",
            "findTheDifference('abcd', 'dbcae')",
            "findTheDifference('hello', 'hollae')"
        ],
        "hidden_test_results": [
            "'e'",
            "'y'",
            "'a'",
            "'a'",
            "'d'",
            "'z'",
            "'a'",
            "'b'",
            "'e'",
            "'a'"
        ],
        "boilerplate": "class Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Is Subsequence",
        "source": "https://leetcode.com/problems/is-subsequence/",
        "description": "<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code><em> if </em><code>s</code><em> is a <strong>subsequence</strong> of </em><code>t</code><em>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>A <strong>subsequence</strong> of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;<u>a</u>b<u>c</u>d<u>e</u>&quot;</code> while <code>&quot;aec&quot;</code> is not).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"abc\", t = \"ahbgdc\"\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"axc\", t = \"ahbgdc\"\n<strong>Output:</strong> false\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= t.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist only of lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Suppose there are lots of incoming <code>s</code>, say <code>s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub></code> where <code>k &gt;= 10<sup>9</sup></code>, and you want to check one by one to see if <code>t</code> has its subsequence. In this scenario, how would you change your code?",
        "difficulty": "easy",
        "sample_test_cases": [
            "isSubsequence('abc', 'ahbgdc')",
            "isSubsequence('axc', 'ahbgdc')",
            "isSubsequence('', 'ahbgdc')"
        ],
        "sample_test_results": [
            "True",
            "False",
            "True"
        ],
        "hidden_test_cases": [
            "isSubsequence('abc', 'ahbgdc')",
            "isSubsequence('', '')",
            "isSubsequence('abc', 'abc')",
            "isSubsequence('abc', 'abcd')",
            "isSubsequence('abc', 'acb')",
            "isSubsequence('ab', 'baab')",
            "isSubsequence('leetcode', 'yleets')",
            "isSubsequence('b', 'abc')",
            "isSubsequence('bb', 'ahbgb')",
            "isSubsequence('aaaaaa', 'bbaaaa')"
        ],
        "hidden_test_results": [
            "True",
            "True",
            "True",
            "True",
            "False",
            "True",
            "False",
            "True",
            "True",
            "False"
        ],
        "boilerplate": "class Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        ",
        "compare_func": "return str(result).lower() == expected.lower()"
    },
    {
        "title": "Binary Watch",
        "source": "https://leetcode.com/problems/binary-watch/",
        "description": "<p>A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent&nbsp;the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.</p>\n\n<ul>\n\t<li>For example, the below binary watch reads <code>&quot;4:51&quot;</code>.</li>\n</ul>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/08/binarywatch.jpg\" style=\"width: 500px; height: 500px;\" /></p>\n\n<p>Given an integer <code>turnedOn</code> which represents the number of LEDs that are currently on (ignoring the PM), return <em>all possible times the watch could represent</em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>The hour must not contain a leading zero.</p>\n\n<ul>\n\t<li>For example, <code>&quot;01:00&quot;</code> is not valid. It should be <code>&quot;1:00&quot;</code>.</li>\n</ul>\n\n<p>The minute must&nbsp;consist of two digits and may contain a leading zero.</p>\n\n<ul>\n\t<li>For example, <code>&quot;10:2&quot;</code> is not valid. It should be <code>&quot;10:02&quot;</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> turnedOn = 1\n<strong>Output:</strong> [\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> turnedOn = 9\n<strong>Output:</strong> []\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= turnedOn &lt;= 10</code></li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "readBinaryWatch(1)",
            "readBinaryWatch(9)",
            "readBinaryWatch(2)"
        ],
        "sample_test_results": [
            "['0:01', '0:02', '0:04', '0:08', '0:16', '0:32', '1:00', '2:00', '4:00', '8:00']",
            "[]",
            "['0:03', '0:05', '0:06', '0:09', '0:10', '0:12', '0:17', '0:18', '0:20', '0:24', '0:33', '0:34', '0:36', '0:40', '0:48', '1:01', '1:02', '1:04', '1:08', '1:16', '1:32', '2:01', '2:02', '2:04', '2:08', '2:16', '2:32', '3:00', '4:01', '4:02', '4:04', '4:08', '4:16', '4:32', '5:00', '6:00', '8:01', '8:02', '8:04', '8:08', '8:16', '8:32', '9:00', '10:00']"
        ],
        "hidden_test_cases": [
            "readBinaryWatch(0)",
            "readBinaryWatch(1)",
            "readBinaryWatch(2)",
            "readBinaryWatch(3)",
            "readBinaryWatch(4)",
            "readBinaryWatch(5)",
            "readBinaryWatch(6)",
            "readBinaryWatch(7)",
            "readBinaryWatch(8)",
            "readBinaryWatch(9)"
        ],
        "hidden_test_results": [
            "['0:00']",
            "['0:01', '0:02', '0:04', '0:08', '0:16', '0:32', '1:00', '2:00', '4:00', '8:00']",
            "['0:03', '0:05', '0:06', '0:09', '0:10', '0:12', '0:17', '0:18', '0:20', '0:24', '0:33', '0:34', '0:36', '0:40', '0:48', '1:01', '1:02', '1:04', '1:08', '1:16', '1:32', '2:01', '2:02', '2:04', '2:08', '2:16', '2:32', '3:00', '4:01', '4:02', '4:04', '4:08', '4:16', '4:32', '5:00', '6:00', '8:01', '8:02', '8:04', '8:08', '8:16', '8:32', '9:00', '10:00']",
            "['0:07', '0:11', '0:13', '0:14', '0:19', '0:21', '0:22', '0:25', '0:26', '0:28', '0:35', '0:37', '0:38', '0:41', '0:42', '0:44', '0:49', '0:50', '0:52', '0:56', '1:03', '1:05', '1:06', '1:09', '1:10', '1:12', '1:17', '1:18', '1:20', '1:24', '1:33', '1:34', '1:36', '1:40', '1:48', '2:03', '2:05', '2:06', '2:09', '2:10', '2:12', '2:17', '2:18', '2:20', '2:24', '2:33', '2:34', '2:36', '2:40', '2:48', '3:01', '3:02', '3:04', '3:08', '3:16', '3:32', '4:03', '4:05', '4:06', '4:09', '4:10', '4:12', '4:17', '4:18', '4:20', '4:24', '4:33', '4:34', '4:36', '4:40', '4:48', '5:01', '5:02', '5:04', '5:08', '5:16', '5:32', '6:01', '6:02', '6:04', '6:08', '6:16', '6:32', '7:00', '8:03', '8:05', '8:06', '8:09', '8:10', '8:12', '8:17', '8:18', '8:20', '8:24', '8:33', '8:34', '8:36', '8:40', '8:48', '9:01', '9:02', '9:04', '9:08', '9:16', '9:32', '10:01', '10:02', '10:04', '10:08', '10:16', '10:32', '11:00']",
            "['0:15', '0:23', '0:27', '0:29', '0:30', '0:39', '0:43', '0:45', '0:46', '0:51', '0:53', '0:54', '0:57', '0:58', '1:07', '1:11', '1:13', '1:14', '1:19', '1:21', '1:22', '1:25', '1:26', '1:28', '1:35', '1:37', '1:38', '1:41', '1:42', '1:44', '1:49', '1:50', '1:52', '1:56', '2:07', '2:11', '2:13', '2:14', '2:19', '2:21', '2:22', '2:25', '2:26', '2:28', '2:35', '2:37', '2:38', '2:41', '2:42', '2:44', '2:49', '2:50', '2:52', '2:56', '3:03', '3:05', '3:06', '3:09', '3:10', '3:12', '3:17', '3:18', '3:20', '3:24', '3:33', '3:34', '3:36', '3:40', '3:48', '4:07', '4:11', '4:13', '4:14', '4:19', '4:21', '4:22', '4:25', '4:26', '4:28', '4:35', '4:37', '4:38', '4:41', '4:42', '4:44', '4:49', '4:50', '4:52', '4:56', '5:03', '5:05', '5:06', '5:09', '5:10', '5:12', '5:17', '5:18', '5:20', '5:24', '5:33', '5:34', '5:36', '5:40', '5:48', '6:03', '6:05', '6:06', '6:09', '6:10', '6:12', '6:17', '6:18', '6:20', '6:24', '6:33', '6:34', '6:36', '6:40', '6:48', '7:01', '7:02', '7:04', '7:08', '7:16', '7:32', '8:07', '8:11', '8:13', '8:14', '8:19', '8:21', '8:22', '8:25', '8:26', '8:28', '8:35', '8:37', '8:38', '8:41', '8:42', '8:44', '8:49', '8:50', '8:52', '8:56', '9:03', '9:05', '9:06', '9:09', '9:10', '9:12', '9:17', '9:18', '9:20', '9:24', '9:33', '9:34', '9:36', '9:40', '9:48', '10:03', '10:05', '10:06', '10:09', '10:10', '10:12', '10:17', '10:18', '10:20', '10:24', '10:33', '10:34', '10:36', '10:40', '10:48', '11:01', '11:02', '11:04', '11:08', '11:16', '11:32']",
            "['0:31', '0:47', '0:55', '0:59', '1:15', '1:23', '1:27', '1:29', '1:30', '1:39', '1:43', '1:45', '1:46', '1:51', '1:53', '1:54', '1:57', '1:58', '2:15', '2:23', '2:27', '2:29', '2:30', '2:39', '2:43', '2:45', '2:46', '2:51', '2:53', '2:54', '2:57', '2:58', '3:07', '3:11', '3:13', '3:14', '3:19', '3:21', '3:22', '3:25', '3:26', '3:28', '3:35', '3:37', '3:38', '3:41', '3:42', '3:44', '3:49', '3:50', '3:52', '3:56', '4:15', '4:23', '4:27', '4:29', '4:30', '4:39', '4:43', '4:45', '4:46', '4:51', '4:53', '4:54', '4:57', '4:58', '5:07', '5:11', '5:13', '5:14', '5:19', '5:21', '5:22', '5:25', '5:26', '5:28', '5:35', '5:37', '5:38', '5:41', '5:42', '5:44', '5:49', '5:50', '5:52', '5:56', '6:07', '6:11', '6:13', '6:14', '6:19', '6:21', '6:22', '6:25', '6:26', '6:28', '6:35', '6:37', '6:38', '6:41', '6:42', '6:44', '6:49', '6:50', '6:52', '6:56', '7:03', '7:05', '7:06', '7:09', '7:10', '7:12', '7:17', '7:18', '7:20', '7:24', '7:33', '7:34', '7:36', '7:40', '7:48', '8:15', '8:23', '8:27', '8:29', '8:30', '8:39', '8:43', '8:45', '8:46', '8:51', '8:53', '8:54', '8:57', '8:58', '9:07', '9:11', '9:13', '9:14', '9:19', '9:21', '9:22', '9:25', '9:26', '9:28', '9:35', '9:37', '9:38', '9:41', '9:42', '9:44', '9:49', '9:50', '9:52', '9:56', '10:07', '10:11', '10:13', '10:14', '10:19', '10:21', '10:22', '10:25', '10:26', '10:28', '10:35', '10:37', '10:38', '10:41', '10:42', '10:44', '10:49', '10:50', '10:52', '10:56', '11:03', '11:05', '11:06', '11:09', '11:10', '11:12', '11:17', '11:18', '11:20', '11:24', '11:33', '11:34', '11:36', '11:40', '11:48']",
            "['1:31', '1:47', '1:55', '1:59', '2:31', '2:47', '2:55', '2:59', '3:15', '3:23', '3:27', '3:29', '3:30', '3:39', '3:43', '3:45', '3:46', '3:51', '3:53', '3:54', '3:57', '3:58', '4:31', '4:47', '4:55', '4:59', '5:15', '5:23', '5:27', '5:29', '5:30', '5:39', '5:43', '5:45', '5:46', '5:51', '5:53', '5:54', '5:57', '5:58', '6:15', '6:23', '6:27', '6:29', '6:30', '6:39', '6:43', '6:45', '6:46', '6:51', '6:53', '6:54', '6:57', '6:58', '7:07', '7:11', '7:13', '7:14', '7:19', '7:21', '7:22', '7:25', '7:26', '7:28', '7:35', '7:37', '7:38', '7:41', '7:42', '7:44', '7:49', '7:50', '7:52', '7:56', '8:31', '8:47', '8:55', '8:59', '9:15', '9:23', '9:27', '9:29', '9:30', '9:39', '9:43', '9:45', '9:46', '9:51', '9:53', '9:54', '9:57', '9:58', '10:15', '10:23', '10:27', '10:29', '10:30', '10:39', '10:43', '10:45', '10:46', '10:51', '10:53', '10:54', '10:57', '10:58', '11:07', '11:11', '11:13', '11:14', '11:19', '11:21', '11:22', '11:25', '11:26', '11:28', '11:35', '11:37', '11:38', '11:41', '11:42', '11:44', '11:49', '11:50', '11:52', '11:56']",
            "['3:31', '3:47', '3:55', '3:59', '5:31', '5:47', '5:55', '5:59', '6:31', '6:47', '6:55', '6:59', '7:15', '7:23', '7:27', '7:29', '7:30', '7:39', '7:43', '7:45', '7:46', '7:51', '7:53', '7:54', '7:57', '7:58', '9:31', '9:47', '9:55', '9:59', '10:31', '10:47', '10:55', '10:59', '11:15', '11:23', '11:27', '11:29', '11:30', '11:39', '11:43', '11:45', '11:46', '11:51', '11:53', '11:54', '11:57', '11:58']",
            "['7:31', '7:47', '7:55', '7:59', '11:31', '11:47', '11:55', '11:59']",
            "[]"
        ],
        "boilerplate": "class Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        ",
        "compare_func": "def sorted_list_strings(lst):\n        return sorted([str(x) for x in eval(lst)])\n    return sorted(result) == sorted_list_strings(expected)"
    },
    {
        "title": "Convert a Number to Hexadecimal",
        "source": "https://leetcode.com/problems/convert-a-number-to-hexadecimal/",
        "description": "<p>Given a 32-bit integer <code>num</code>, return <em>a string representing its hexadecimal representation</em>. For negative integers, <a href=\"https://en.wikipedia.org/wiki/Two%27s_complement\" target=\"_blank\">two&rsquo;s complement</a> method is used.</p>\n\n<p>All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.</p>\n\n<p><strong>Note:&nbsp;</strong>You are not allowed to use any built-in library method to directly solve this problem.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> num = 26\n<strong>Output:</strong> \"1a\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> num = -1\n<strong>Output:</strong> \"ffffffff\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= num &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "toHex(26)",
            "toHex(-1)",
            "toHex(0)"
        ],
        "sample_test_results": [
            "'1a'",
            "'ffffffff'",
            "'0'"
        ],
        "hidden_test_cases": [
            "toHex(0)",
            "toHex(16)",
            "toHex(26)",
            "toHex(-1)",
            "toHex(2147483647)",
            "toHex(-2147483648)",
            "toHex(100)",
            "toHex(-100)",
            "toHex(255)",
            "toHex(-255)"
        ],
        "hidden_test_results": [
            "'0'",
            "'10'",
            "'1a'",
            "'ffffffff'",
            "'7fffffff'",
            "'80000000'",
            "'64'",
            "'ffffff9c'",
            "'ff'",
            "'ffffff01'"
        ],
        "boilerplate": "class Solution:\n    def toHex(self, num: int) -> str:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Longest Palindrome",
        "source": "https://leetcode.com/problems/longest-palindrome/",
        "description": "<p>Given a string <code>s</code> which consists of lowercase or uppercase letters, return the length of the <strong>longest <span data-keyword=\"palindrome-string\">palindrome</span></strong>&nbsp;that can be built with those letters.</p>\n\n<p>Letters are <strong>case sensitive</strong>, for example, <code>&quot;Aa&quot;</code> is not considered a palindrome.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abccccdd&quot;\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The longest palindrome that can be built is &quot;a&quot;, whose length is 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> consists of lowercase <strong>and/or</strong> uppercase English&nbsp;letters only.</li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "longestPalindrome('abccccdd')",
            "longestPalindrome('a')",
            "longestPalindrome('Aa')"
        ],
        "sample_test_results": [
            "7",
            "1",
            "1"
        ],
        "hidden_test_cases": [
            "longestPalindrome('racecar')",
            "longestPalindrome('aaaaaa')",
            "longestPalindrome('abcde')",
            "longestPalindrome('AAaa')",
            "longestPalindrome('aA')",
            "longestPalindrome('z')",
            "longestPalindrome('abccba')",
            "longestPalindrome('aaabbbcccc')",
            "longestPalindrome('abcABC')",
            "longestPalindrome('')"
        ],
        "hidden_test_results": [
            "7",
            "6",
            "1",
            "4",
            "1",
            "1",
            "6",
            "9",
            "1",
            "0"
        ],
        "boilerplate": "class Solution:\n    def longestPalindrome(self, s: str) -> int:\n        ",
        "compare_func": "return int(result) == int(expected)"
    },
    {
        "title": "Add Strings",
        "source": "https://leetcode.com/problems/add-strings/",
        "description": "<p>Given two non-negative integers, <code>num1</code> and <code>num2</code> represented as string, return <em>the sum of</em> <code>num1</code> <em>and</em> <code>num2</code> <em>as a string</em>.</p>\n\n<p>You must solve the problem without using any built-in library for handling large integers (such as <code>BigInteger</code>). You must also not convert the inputs to integers directly.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num1 = &quot;11&quot;, num2 = &quot;123&quot;\n<strong>Output:</strong> &quot;134&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num1 = &quot;456&quot;, num2 = &quot;77&quot;\n<strong>Output:</strong> &quot;533&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> num1 = &quot;0&quot;, num2 = &quot;0&quot;\n<strong>Output:</strong> &quot;0&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num1.length, num2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>num1</code> and <code>num2</code> consist of only digits.</li>\n\t<li><code>num1</code> and <code>num2</code> don&#39;t have any leading zeros except for the zero itself.</li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "addStrings('11', '123')",
            "addStrings('456', '77')",
            "addStrings('0', '0')"
        ],
        "sample_test_results": [
            "'134'",
            "'533'",
            "'0'"
        ],
        "hidden_test_cases": [
            "addStrings('9', '1')",
            "addStrings('999', '1')",
            "addStrings('1', '999')",
            "addStrings('0', '1')",
            "addStrings('1', '0')",
            "addStrings('999999', '1')",
            "addStrings('123', '456')",
            "addStrings('1000', '2000')",
            "addStrings('9999', '9999')",
            "addStrings('1111', '9999')"
        ],
        "hidden_test_results": [
            "'10'",
            "'1000'",
            "'1000'",
            "'1'",
            "'1'",
            "'1000000'",
            "'579'",
            "'3000'",
            "'19998'",
            "'11110'"
        ],
        "boilerplate": "class Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        ",
        "compare_func": "return str(result) == eval(expected)"
    },
    {
        "title": "Arranging Coins",
        "source": "https://leetcode.com/problems/arranging-coins/",
        "description": "<p>You have <code>n</code> coins and you want to build a staircase with these coins. The staircase consists of <code>k</code> rows where the <code>i<sup>th</sup></code> row has exactly <code>i</code> coins. The last row of the staircase <strong>may be</strong> incomplete.</p>\n\n<p>Given the integer <code>n</code>, return <em>the number of <strong>complete rows</strong> of the staircase you will build</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/09/arrangecoins1-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> n = 5\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Because the 3<sup>rd</sup> row is incomplete, we return 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/09/arrangecoins2-grid.jpg\" style=\"width: 333px; height: 333px;\" />\n<pre>\n<strong>Input:</strong> n = 8\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Because the 4<sup>th</sup> row is incomplete, we return 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "arrangeCoins(5)",
            "arrangeCoins(8)",
            "arrangeCoins(1)"
        ],
        "sample_test_results": [
            "2",
            "3",
            "1"
        ],
        "hidden_test_cases": [
            "arrangeCoins(0)",
            "arrangeCoins(3)",
            "arrangeCoins(10)",
            "arrangeCoins(15)",
            "arrangeCoins(21)",
            "arrangeCoins(100)",
            "arrangeCoins(1000)",
            "arrangeCoins(10000)",
            "arrangeCoins(2147483647)",
            "arrangeCoins(6)"
        ],
        "hidden_test_results": [
            "0",
            "2",
            "4",
            "5",
            "6",
            "13",
            "44",
            "140",
            "65535",
            "3"
        ],
        "boilerplate": "class Solution:\n    def arrangeCoins(self, n: int) -> int:\n        ",
        "compare_func": "return int(result) == int(expected)"
    },
    {
        "title": "Assign Cookies",
        "source": "https://leetcode.com/problems/assign-cookies/",
        "description": "<p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.</p>\n\n<p>Each child <code>i</code> has a greed factor <code>g[i]</code>, which is the minimum size of a cookie that the child will be content with; and each cookie <code>j</code> has a size <code>s[j]</code>. If <code>s[j] &gt;= g[i]</code>, we can assign the cookie <code>j</code> to the child <code>i</code>, and the child <code>i</code> will be content. Your goal is to maximize the number of your content children and output the maximum number.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> g = [1,2,3], s = [1,1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> g = [1,2], s = [1,2,3]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \nYou have 3 cookies and their sizes are big enough to gratify all of the children, \nYou need to output 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= g.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= g[i], s[j] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Note:</strong> This question is the same as <a href=\"https://leetcode.com/problems/maximum-matching-of-players-with-trainers/description/\" target=\"_blank\"> 2410: Maximum Matching of Players With Trainers.</a></p>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "findContentChildren([1,2,3], [1,1])",
            "findContentChildren([1,2], [1,2,3])",
            "findContentChildren([1,2,3], [])"
        ],
        "sample_test_results": [
            "1",
            "2",
            "0"
        ],
        "hidden_test_cases": [
            "findContentChildren([], [1,2,3])",
            "findContentChildren([1,2], [1])",
            "findContentChildren([2], [1])",
            "findContentChildren([1,2,3], [1,2,3])",
            "findContentChildren([10,9,8,7], [5,6,7,8])",
            "findContentChildren([1,1,1], [1,1,1])",
            "findContentChildren([2,3,4,5], [1,2,3])",
            "findContentChildren([1], [2])",
            "findContentChildren([3,4,5], [1,2])",
            "findContentChildren([1,2,3], [3])"
        ],
        "hidden_test_results": [
            "0",
            "1",
            "0",
            "3",
            "2",
            "3",
            "2",
            "1",
            "0",
            "1"
        ],
        "boilerplate": "class Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        ",
        "compare_func": "return int(result) == int(expected)"
    },
    {
        "title": "Repeated Substring Pattern",
        "source": "https://leetcode.com/problems/repeated-substring-pattern/",
        "description": "<p>Given a string <code>s</code>, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abab&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> It is the substring &quot;ab&quot; twice.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aba&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcabcabcabc&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> It is the substring &quot;abc&quot; four times or the substring &quot;abcabc&quot; twice.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "repeatedSubstringPattern('abab')",
            "repeatedSubstringPattern('aba')",
            "repeatedSubstringPattern('abcabcabcabc')"
        ],
        "sample_test_results": [
            "True",
            "False",
            "True"
        ],
        "hidden_test_cases": [
            "repeatedSubstringPattern('')",
            "repeatedSubstringPattern('a')",
            "repeatedSubstringPattern('aa')",
            "repeatedSubstringPattern('aaa')",
            "repeatedSubstringPattern('aabaaba')",
            "repeatedSubstringPattern('abaababaab')",
            "repeatedSubstringPattern('aaaaa')",
            "repeatedSubstringPattern('abcabc')",
            "repeatedSubstringPattern('abcabcabc')",
            "repeatedSubstringPattern('abac')"
        ],
        "hidden_test_results": [
            "True",
            "False",
            "True",
            "True",
            "False",
            "True",
            "True",
            "True",
            "True",
            "False"
        ],
        "boilerplate": "class Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        ",
        "compare_func": "return str(result).lower() == expected.lower()"
    },
    {
        "title": "License Key Formatting",
        "source": "https://leetcode.com/problems/license-key-formatting/",
        "description": "<p>You are given a license key represented as a string <code>s</code> that consists of only alphanumeric characters and dashes. The string is separated into <code>n + 1</code> groups by <code>n</code> dashes. You are also given an integer <code>k</code>.</p>\n\n<p>We want to reformat the string <code>s</code> such that each group contains exactly <code>k</code> characters, except for the first group, which could be shorter than <code>k</code> but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.</p>\n\n<p>Return <em>the reformatted license key</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;5F3Z-2e-9-w&quot;, k = 4\n<strong>Output:</strong> &quot;5F3Z-2E9W&quot;\n<strong>Explanation:</strong> The string s has been split into two parts, each part has 4 characters.\nNote that the two extra dashes are not needed and can be removed.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;2-5g-3-J&quot;, k = 2\n<strong>Output:</strong> &quot;2-5G-3J&quot;\n<strong>Explanation:</strong> The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of English letters, digits, and dashes <code>&#39;-&#39;</code>.</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "licenseKeyFormatting('5F3Z-2e-9-w', 4)",
            "licenseKeyFormatting('2-5g-3-J', 2)"
        ],
        "sample_test_results": [
            "'5F3Z-2E9W'",
            "'2-5G-3J'"
        ],
        "hidden_test_cases": [
            "licenseKeyFormatting('a-a-a-a-', 1)",
            "licenseKeyFormatting('---', 3)",
            "licenseKeyFormatting('2', 2)",
            "licenseKeyFormatting('r', 1)",
            "licenseKeyFormatting('5F3Z-2e-9-w-a-b-c-d', 4)",
            "licenseKeyFormatting('2-5g-3-J-k-L', 3)",
            "licenseKeyFormatting('a-b-c', 3)",
            "licenseKeyFormatting('12345', 1)",
            "licenseKeyFormatting('ABCD', 2)",
            "licenseKeyFormatting('a-1-B-2', 2)"
        ],
        "hidden_test_results": [
            "'A-A-A-A'",
            "''",
            "'2'",
            "'R'",
            "'5F3Z-2E9W-ABCD'",
            "'2-5G3-JKL'",
            "'ABC'",
            "'1-2-3-4-5'",
            "'AB-CD'",
            "'A1-B2'"
        ],
        "boilerplate": "class Solution:\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Construct the Rectangle",
        "source": "https://leetcode.com/problems/construct-the-rectangle/",
        "description": "<p>A web developer needs to know how to design a web page&#39;s size. So, given a specific rectangular web page&rsquo;s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:</p>\n\n<ol>\n\t<li>The area of the rectangular web page you designed must equal to the given target area.</li>\n\t<li>The width <code>W</code> should not be larger than the length <code>L</code>, which means <code>L &gt;= W</code>.</li>\n\t<li>The difference between length <code>L</code> and width <code>W</code> should be as small as possible.</li>\n</ol>\n\n<p>Return <em>an array <code>[L, W]</code> where <code>L</code> and <code>W</code> are the length and width of the&nbsp;web page you designed in sequence.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> area = 4\n<strong>Output:</strong> [2,2]\n<strong>Explanation:</strong> The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. \nBut according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> area = 37\n<strong>Output:</strong> [37,1]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> area = 122122\n<strong>Output:</strong> [427,286]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= area &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "constructRectangle(4)",
            "constructRectangle(37)",
            "constructRectangle(122122)"
        ],
        "sample_test_results": [
            "[2, 2]",
            "[37, 1]",
            "[427, 286]"
        ],
        "hidden_test_cases": [
            "constructRectangle(1)",
            "constructRectangle(9)",
            "constructRectangle(16)",
            "constructRectangle(24)",
            "constructRectangle(100)",
            "constructRectangle(1000)",
            "constructRectangle(10000)",
            "constructRectangle(99999)",
            "constructRectangle(1000000)",
            "constructRectangle(9999999)"
        ],
        "hidden_test_results": [
            "[1, 1]",
            "[3, 3]",
            "[4, 4]",
            "[6, 4]",
            "[10, 10]",
            "[40, 25]",
            "[100, 100]",
            "[369, 271]",
            "[1000, 1000]",
            "[4649, 2151]"
        ],
        "boilerplate": "class Solution:\n    def constructRectangle(self, area: int) -> List[int]:\n        ",
        "compare_func": "expected = eval(expected); return result[0]*result[1] == expected[0]*expected[1] and result[0] >= result[1] and abs(result[0]-result[1]) <= abs(expected[0]-expected[1])"
    },
    {
        "title": "Teemo Attacking",
        "source": "https://leetcode.com/problems/teemo-attacking/",
        "description": "<p>Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly <code>duration</code> seconds. More formally, an attack at second <code>t</code> will mean Ashe is poisoned during the <strong>inclusive</strong> time interval <code>[t, t + duration - 1]</code>. If Teemo attacks again <strong>before</strong> the poison effect ends, the timer for it is <strong>reset</strong>, and the poison effect will end <code>duration</code> seconds after the new attack.</p>\n\n<p>You are given a <strong>non-decreasing</strong> integer array <code>timeSeries</code>, where <code>timeSeries[i]</code> denotes that Teemo attacks Ashe at second <code>timeSeries[i]</code>, and an integer <code>duration</code>.</p>\n\n<p>Return <em>the <strong>total</strong> number of seconds that Ashe is poisoned</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> timeSeries = [1,4], duration = 2\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Teemo&#39;s attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.\nAshe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> timeSeries = [1,2], duration = 2\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Teemo&#39;s attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3.\nAshe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= timeSeries.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= timeSeries[i], duration &lt;= 10<sup>7</sup></code></li>\n\t<li><code>timeSeries</code> is sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "findPoisonedDuration([1,4], 2)",
            "findPoisonedDuration([1,2], 2)"
        ],
        "sample_test_results": [
            "4",
            "3"
        ],
        "hidden_test_cases": [
            "findPoisonedDuration([1], 1)",
            "findPoisonedDuration([1,2,3,4,5], 1)",
            "findPoisonedDuration([1,3,5,7,9], 3)",
            "findPoisonedDuration([1,2,3,4,5], 5)",
            "findPoisonedDuration([1,10,20,30], 5)",
            "findPoisonedDuration([1,2,3,100], 2)",
            "findPoisonedDuration([1,1,1,1], 2)",
            "findPoisonedDuration([0,1,2], 1)",
            "findPoisonedDuration([1,5,10], 2)",
            "findPoisonedDuration([1,3], 3)"
        ],
        "hidden_test_results": [
            "1",
            "5",
            "11",
            "9",
            "20",
            "6",
            "2",
            "3",
            "6",
            "5"
        ],
        "boilerplate": "class Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        ",
        "compare_func": "return int(result) == int(expected)"
    },
    {
        "title": "Base 7",
        "source": "https://leetcode.com/problems/base-7/",
        "description": "<p>Given an integer <code>num</code>, return <em>a string of its <strong>base 7</strong> representation</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> num = 100\n<strong>Output:</strong> \"202\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> num = -7\n<strong>Output:</strong> \"-10\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-10<sup>7</sup> &lt;= num &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "convertToBase7(100)",
            "convertToBase7(-7)"
        ],
        "sample_test_results": [
            "'202'",
            "'-10'"
        ],
        "hidden_test_cases": [
            "convertToBase7(0)",
            "convertToBase7(7)",
            "convertToBase7(-49)",
            "convertToBase7(1000000)",
            "convertToBase7(-1000000)",
            "convertToBase7(1)",
            "convertToBase7(-1)",
            "convertToBase7(49)",
            "convertToBase7(999999)",
            "convertToBase7(-999999)"
        ],
        "hidden_test_results": [
            "'0'",
            "'10'",
            "'-100'",
            "'11333311'",
            "'-11333311'",
            "'1'",
            "'-1'",
            "'100'",
            "'11333310'",
            "'-11333310'"
        ],
        "boilerplate": "class Solution:\n    def convertToBase7(self, num: int) -> str:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Perfect Number",
        "source": "https://leetcode.com/problems/perfect-number/",
        "description": "<p>A <a href=\"https://en.wikipedia.org/wiki/Perfect_number\" target=\"_blank\"><strong>perfect number</strong></a> is a <strong>positive integer</strong> that is equal to the sum of its <strong>positive divisors</strong>, excluding the number itself. A <strong>divisor</strong> of an integer <code>x</code> is an integer that can divide <code>x</code> evenly.</p>\n\n<p>Given an integer <code>n</code>, return <code>true</code><em> if </em><code>n</code><em> is a perfect number, otherwise return </em><code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 28\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 28 = 1 + 2 + 4 + 7 + 14\n1, 2, 4, 7, and 14 are all divisors of 28.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 7\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "difficulty": "easy",
        "sample_test_cases": [
            "checkPerfectNumber(28)",
            "checkPerfectNumber(7)"
        ],
        "sample_test_results": [
            "True",
            "False"
        ],
        "hidden_test_cases": [
            "checkPerfectNumber(1)",
            "checkPerfectNumber(6)",
            "checkPerfectNumber(496)",
            "checkPerfectNumber(8128)",
            "checkPerfectNumber(33550336)",
            "checkPerfectNumber(12)",
            "checkPerfectNumber(100)",
            "checkPerfectNumber(1000)",
            "checkPerfectNumber(10000)",
            "checkPerfectNumber(100000)"
        ],
        "hidden_test_results": [
            "False",
            "True",
            "True",
            "True",
            "True",
            "False",
            "False",
            "False",
            "False",
            "False"
        ],
        "boilerplate": "class Solution:\n    def checkPerfectNumber(self, num: int) -> bool:\n        ",
        "compare_func": "return str(result).lower() == expected.lower()"
    },
    {
        "title": "Zigzag Conversion",
        "source": "https://leetcode.com/problems/zigzag-conversion/",
        "description": "<p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>\n\n<pre>\nP   A   H   N\nA P L S I I G\nY   I   R\n</pre>\n\n<p>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code></p>\n\n<p>Write the code that will take a string and make this conversion given a number of rows:</p>\n\n<pre>\nstring convert(string s, int numRows);\n</pre>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;PAYPALISHIRING&quot;, numRows = 3\n<strong>Output:</strong> &quot;PAHNAPLSIIGYIR&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;PAYPALISHIRING&quot;, numRows = 4\n<strong>Output:</strong> &quot;PINALSIGYAHRPI&quot;\n<strong>Explanation:</strong>\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;A&quot;, numRows = 1\n<strong>Output:</strong> &quot;A&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> consists of English letters (lower-case and upper-case), <code>&#39;,&#39;</code> and <code>&#39;.&#39;</code>.</li>\n\t<li><code>1 &lt;= numRows &lt;= 1000</code></li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "convert('PAYPALISHIRING', 3)",
            "convert('PAYPALISHIRING', 4)",
            "convert('A', 1)"
        ],
        "sample_test_results": [
            "'PAHNAPLSIIGYIR'",
            "'PINALSIGYAHRPI'",
            "'A'"
        ],
        "hidden_test_cases": [
            "convert('ABCDEF', 2)",
            "convert('HELLO', 1)",
            "convert('WORLD', 5)",
            "convert('TEST.TEST', 3)",
            "convert('A,B,C', 2)",
            "convert('abcdefghijklmnop', 4)",
            "convert('ANTHROPIC', 3)",
            "convert('Testing123', 2)",
            "convert('', 1)",
            "convert('AB', 1)"
        ],
        "hidden_test_results": [
            "'ACEBDF'",
            "'HELLO'",
            "'WORLD'",
            "'T.TETTSSE'",
            "'ABC,,'",
            "'agmbfhlnceikodjp'",
            "'ARCNHOITP'",
            "'Tsig2etn13'",
            "''",
            "'AB'"
        ],
        "boilerplate": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Container With Most Water",
        "source": "https://leetcode.com/problems/container-with-most-water/",
        "description": "<p>You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>i<sup>th</sup></code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.</p>\n\n<p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p>\n\n<p>Return <em>the maximum amount of water a container can store</em>.</p>\n\n<p><strong>Notice</strong> that you may not slant the container.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg\" style=\"width: 600px; height: 287px;\" />\n<pre>\n<strong>Input:</strong> height = [1,8,6,2,5,4,8,3,7]\n<strong>Output:</strong> 49\n<strong>Explanation:</strong> The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> height = [1,1]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == height.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= height[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "maxArea([1,8,6,2,5,4,8,3,7])",
            "maxArea([1,1])"
        ],
        "sample_test_results": [
            "49",
            "1"
        ],
        "hidden_test_cases": [
            "maxArea([4,3,2,1,4])",
            "maxArea([1,2,4,3])",
            "maxArea([1,2])",
            "maxArea([1,1,1])",
            "maxArea([2,3,4,5,18,17,6])",
            "maxArea([1,8,100,2,100,4,8,3,7])",
            "maxArea([1,2,3,4,5,6])",
            "maxArea([6,5,4,3,2,1])",
            "maxArea([0,0])",
            "maxArea([10000,1])"
        ],
        "hidden_test_results": [
            "16",
            "4",
            "1",
            "2",
            "17",
            "200",
            "9",
            "9",
            "0",
            "1"
        ],
        "boilerplate": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        ",
        "compare_func": "return result == int(expected)"
    },
    {
        "title": "3Sum Closest",
        "source": "https://leetcode.com/problems/3sum-closest/",
        "description": "<p>Given an integer array <code>nums</code> of length <code>n</code> and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>.</p>\n\n<p>Return <em>the sum of the three integers</em>.</p>\n\n<p>You may assume that each input would have exactly one solution.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,2,1,-4], target = 1\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0,0], target = 1\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "threeSumClosest([-1,2,1,-4], 1)",
            "threeSumClosest([0,0,0], 1)"
        ],
        "sample_test_results": [
            "2",
            "0"
        ],
        "hidden_test_cases": [
            "threeSumClosest([1,1,1,0], 100)",
            "threeSumClosest([-1,0,1,2,3], 1)",
            "threeSumClosest([0,0,0,0], 1)",
            "threeSumClosest([-5,-4,-3,-2,-1], 0)",
            "threeSumClosest([1,2,3,4,5], 10)",
            "threeSumClosest([-1,-2,-3,1,2,3], 0)",
            "threeSumClosest([1,1,-1,-1,3], -1)",
            "threeSumClosest([-100,-50,0,50,100], 23)",
            "threeSumClosest([-1,2,1,-4,3,-3], 0)",
            "threeSumClosest([-1000,1000,1000], 100)"
        ],
        "hidden_test_results": [
            "3",
            "1",
            "0",
            "-6",
            "10",
            "0",
            "-1",
            "0",
            "0",
            "1000"
        ],
        "boilerplate": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        ",
        "compare_func": "return result == int(expected)"
    },
    {
        "title": "Search in Rotated Sorted Array",
        "source": "https://leetcode.com/problems/search-in-rotated-sorted-array/",
        "description": "<p>There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).</p>\n\n<p>Prior to being passed to your function, <code>nums</code> is <strong>possibly rotated</strong> at an unknown pivot index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.</p>\n\n<p>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of </em><code>target</code><em> if it is in </em><code>nums</code><em>, or </em><code>-1</code><em> if it is not in </em><code>nums</code>.</p>\n\n<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 0\n<strong>Output:</strong> 4\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 3\n<strong>Output:</strong> -1\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [1], target = 0\n<strong>Output:</strong> -1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li>All values of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is an ascending array that is possibly rotated.</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "search([4,5,6,7,0,1,2], 0)",
            "search([4,5,6,7,0,1,2], 3)",
            "search([1], 0)"
        ],
        "sample_test_results": [
            "4",
            "-1",
            "-1"
        ],
        "hidden_test_cases": [
            "search([3,1], 1)",
            "search([1,3,5], 3)",
            "search([5,1,2,3,4], 1)",
            "search([4,5,6,7,0,1,2], 5)",
            "search([1], 1)",
            "search([1,3], 3)",
            "search([3,5,1], 3)",
            "search([5,1,3], 5)",
            "search([4,5,6,7,8,1,2,3], 8)",
            "search([1,2,3,4,5], 6)"
        ],
        "hidden_test_results": [
            "1",
            "1",
            "1",
            "1",
            "0",
            "1",
            "0",
            "0",
            "4",
            "-1"
        ],
        "boilerplate": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        ",
        "compare_func": "return result == int(expected)"
    },
    {
        "title": "Find First and Last Position of Element in Sorted Array",
        "source": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/",
        "description": "<p>Given an array of integers <code>nums</code> sorted in non-decreasing order, find the starting and ending position of a given <code>target</code> value.</p>\n\n<p>If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.</p>\n\n<p>You must&nbsp;write an algorithm with&nbsp;<code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 8\n<strong>Output:</strong> [3,4]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 6\n<strong>Output:</strong> [-1,-1]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [], target = 0\n<strong>Output:</strong> [-1,-1]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= nums[i]&nbsp;&lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums</code> is a non-decreasing array.</li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= target&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "searchRange([5,7,7,8,8,10], 8)",
            "searchRange([5,7,7,8,8,10], 6)",
            "searchRange([], 0)"
        ],
        "sample_test_results": [
            "(3, 4)",
            "(-1, -1)",
            "(-1, -1)"
        ],
        "hidden_test_cases": [
            "searchRange([1], 1)",
            "searchRange([1,1,1,1], 1)",
            "searchRange([1,2,3,4,5], 3)",
            "searchRange([1,2,2,3,4,4,4], 4)",
            "searchRange([1,1,2], 2)",
            "searchRange([1], 2)",
            "searchRange([1,2,3], 4)",
            "searchRange([1,1,1,2,2,3], 2)",
            "searchRange([1,2,3,3,3,4,5], 3)",
            "searchRange([1,2,3,4,5,5,5,5,6], 5)"
        ],
        "hidden_test_results": [
            "(0, 0)",
            "(0, 3)",
            "(2, 2)",
            "(4, 6)",
            "(2, 2)",
            "(-1, -1)",
            "(-1, -1)",
            "(3, 4)",
            "(2, 4)",
            "(4, 7)"
        ],
        "boilerplate": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Count and Say",
        "source": "https://leetcode.com/problems/count-and-say/",
        "description": "<p>The <strong>count-and-say</strong> sequence is a sequence of digit strings defined by the recursive formula:</p>\n\n<ul>\n\t<li><code>countAndSay(1) = &quot;1&quot;</code></li>\n\t<li><code>countAndSay(n)</code> is the run-length encoding of <code>countAndSay(n - 1)</code>.</li>\n</ul>\n\n<p><a href=\"http://en.wikipedia.org/wiki/Run-length_encoding\" target=\"_blank\">Run-length encoding</a> (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string <code>&quot;3322251&quot;</code> we replace <code>&quot;33&quot;</code> with <code>&quot;23&quot;</code>, replace <code>&quot;222&quot;</code> with <code>&quot;32&quot;</code>, replace <code>&quot;5&quot;</code> with <code>&quot;15&quot;</code> and replace <code>&quot;1&quot;</code> with <code>&quot;11&quot;</code>. Thus the compressed string becomes <code>&quot;23321511&quot;</code>.</p>\n\n<p>Given a positive integer <code>n</code>, return <em>the </em><code>n<sup>th</sup></code><em> element of the <strong>count-and-say</strong> sequence</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 4</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;1211&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<pre>\ncountAndSay(1) = &quot;1&quot;\ncountAndSay(2) = RLE of &quot;1&quot; = &quot;11&quot;\ncountAndSay(3) = RLE of &quot;11&quot; = &quot;21&quot;\ncountAndSay(4) = RLE of &quot;21&quot; = &quot;1211&quot;\n</pre>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 1</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;1&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>This is the base case.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it iteratively?",
        "difficulty": "medium",
        "sample_test_cases": [
            "countAndSay(4)",
            "countAndSay(1)",
            "countAndSay(5)"
        ],
        "sample_test_results": [
            "'1211'",
            "'1'",
            "'111221'"
        ],
        "hidden_test_cases": [
            "countAndSay(2)",
            "countAndSay(3)",
            "countAndSay(6)",
            "countAndSay(7)",
            "countAndSay(8)",
            "countAndSay(9)",
            "countAndSay(10)",
            "countAndSay(15)",
            "countAndSay(20)",
            "countAndSay(30)"
        ],
        "hidden_test_results": [
            "'11'",
            "'21'",
            "'312211'",
            "'13112221'",
            "'1113213211'",
            "'31131211131221'",
            "'13211311123113112211'",
            "'311311222113111231131112132112311321322112111312211312111322212311322113212221'",
            "'11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211'",
            "'3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211'"
        ],
        "boilerplate": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Combination Sum II",
        "source": "https://leetcode.com/problems/combination-sum-ii/",
        "description": "<p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code>&nbsp;where the candidate numbers sum to <code>target</code>.</p>\n\n<p>Each number in <code>candidates</code>&nbsp;may only be used <strong>once</strong> in the combination.</p>\n\n<p><strong>Note:</strong>&nbsp;The solution set must not contain duplicate combinations.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [10,1,2,7,6,1,5], target = 8\n<strong>Output:</strong> \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2,5,2,1,2], target = 5\n<strong>Output:</strong> \n[\n[1,2,2],\n[5]\n]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;candidates.length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;candidates[i] &lt;= 50</code></li>\n\t<li><code>1 &lt;= target &lt;= 30</code></li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "combinationSum2([10,1,2,7,6,1,5], 8)",
            "combinationSum2([2,5,2,1,2], 5)",
            "combinationSum2([1,1,1,1,1,1,1], 3)"
        ],
        "sample_test_results": [
            "[[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]",
            "[[1, 2, 2], [5]]",
            "[[1, 1, 1]]"
        ],
        "hidden_test_cases": [
            "combinationSum2([1], 1)",
            "combinationSum2([1,2,3], 6)",
            "combinationSum2([1,1,1,2,2], 3)",
            "combinationSum2([10,20,30,40,50], 60)",
            "combinationSum2([2,2,2,2,2], 4)",
            "combinationSum2([1,2,3,4,5], 10)",
            "combinationSum2([1,1,1,1,1,1,1,1,1,1], 5)",
            "combinationSum2([5,4,3,2,1], 8)",
            "combinationSum2([10,1,2,7,6,1,5], 9)",
            "combinationSum2([1,2,2,2,2,2,3], 7)"
        ],
        "hidden_test_results": [
            "[[1]]",
            "[[1, 2, 3]]",
            "[[1, 1, 1], [1, 2]]",
            "[[10, 20, 30], [10, 50], [20, 40]]",
            "[[2, 2]]",
            "[[1, 2, 3, 4], [1, 4, 5], [2, 3, 5]]",
            "[[1, 1, 1, 1, 1]]",
            "[[1, 2, 5], [1, 3, 4], [3, 5]]",
            "[[1, 1, 2, 5], [1, 1, 7], [1, 2, 6], [2, 7]]",
            "[[1, 2, 2, 2], [2, 2, 3]]"
        ],
        "boilerplate": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        ",
        "compare_func": "return sorted([sorted(x) for x in result]) == eval(expected)"
    },
    {
        "title": "Multiply Strings",
        "source": "https://leetcode.com/problems/multiply-strings/",
        "description": "<p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p>\n\n<p><strong>Note:</strong>&nbsp;You must not use any built-in BigInteger library or convert the inputs to integer directly.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> num1 = \"2\", num2 = \"3\"\n<strong>Output:</strong> \"6\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> num1 = \"123\", num2 = \"456\"\n<strong>Output:</strong> \"56088\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num1.length, num2.length &lt;= 200</code></li>\n\t<li><code>num1</code> and <code>num2</code> consist of digits only.</li>\n\t<li>Both <code>num1</code> and <code>num2</code>&nbsp;do not contain any leading zero, except the number <code>0</code> itself.</li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "multiply(\"2\", \"3\")",
            "multiply(\"123\", \"456\")",
            "multiply(\"9999\", \"9999\")"
        ],
        "sample_test_results": [
            "'6'",
            "'56088'",
            "'99980001'"
        ],
        "hidden_test_cases": [
            "multiply(\"0\", \"0\")",
            "multiply(\"1\", \"1\")",
            "multiply(\"999\", \"999\")",
            "multiply(\"1234\", \"5678\")",
            "multiply(\"99999\", \"99999\")",
            "multiply(\"123456789\", \"987654321\")",
            "multiply(\"1000000\", \"1000000\")",
            "multiply(\"11111111\", \"11111111\")",
            "multiply(\"12345678901234567890\", \"12345678901234567890\")",
            "multiply(\"0\", \"1234567890\")"
        ],
        "hidden_test_results": [
            "'0'",
            "'1'",
            "'998001'",
            "'7006652'",
            "'9999800001'",
            "'121932631112635269'",
            "'1000000000000'",
            "'123456787654321'",
            "'152415787532388367501905199875019052100'",
            "'0'"
        ],
        "boilerplate": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Jump Game II",
        "source": "https://leetcode.com/problems/jump-game-ii/",
        "description": "<p>You are given a <strong>0-indexed</strong> array of integers <code>nums</code> of length <code>n</code>. You are initially positioned at <code>nums[0]</code>.</p>\n\n<p>Each element <code>nums[i]</code> represents the maximum length of a forward jump from index <code>i</code>. In other words, if you are at <code>nums[i]</code>, you can jump to any <code>nums[i + j]</code> where:</p>\n\n<ul>\n\t<li><code>0 &lt;= j &lt;= nums[i]</code> and</li>\n\t<li><code>i + j &lt; n</code></li>\n</ul>\n\n<p>Return <em>the minimum number of jumps to reach </em><code>nums[n - 1]</code>. The test cases are generated such that you can reach <code>nums[n - 1]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,1,1,4]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,0,1,4]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>It&#39;s guaranteed that you can reach <code>nums[n - 1]</code>.</li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "jump([2,3,1,1,4])",
            "jump([2,3,0,1,4])",
            "jump([1,2,3,4,5])"
        ],
        "sample_test_results": [
            "2",
            "2",
            "3"
        ],
        "hidden_test_cases": [
            "jump([1])",
            "jump([2,1])",
            "jump([1,1,1,1])",
            "jump([3,2,1])",
            "jump([1,2,1,1,1])",
            "jump([5,9,3,2,1,0,2,3,3,1,0,0])",
            "jump([1,2,3,4,5])",
            "jump([4,1,1,3,1,1,1])",
            "jump([1,1,1,1,1,1,1,1,1,1])",
            "jump([10,9,8,7,6,5,4,3,2,1])"
        ],
        "hidden_test_results": [
            "0",
            "1",
            "3",
            "1",
            "3",
            "3",
            "3",
            "2",
            "9",
            "1"
        ],
        "boilerplate": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        ",
        "compare_func": "return str(result) == expected"
    },
    {
        "title": "Maximum Subarray",
        "source": "https://leetcode.com/problems/maximum-subarray/",
        "description": "<p>Given an integer array <code>nums</code>, find the <span data-keyword=\"subarray-nonempty\">subarray</span> with the largest sum, and return <em>its sum</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-2,1,-3,4,-1,2,1,-5,4]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The subarray [4,-1,2,1] has the largest sum 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The subarray [1] has the largest sum 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,4,-1,7,8]\n<strong>Output:</strong> 23\n<strong>Explanation:</strong> The subarray [5,4,-1,7,8] has the largest sum 23.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> If you have figured out the <code>O(n)</code> solution, try coding another solution using the <strong>divide and conquer</strong> approach, which is more subtle.</p>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "maxSubArray([-2,1,-3,4,-1,2,1,-5,4])",
            "maxSubArray([1])",
            "maxSubArray([5,4,-1,7,8])"
        ],
        "sample_test_results": [
            "6",
            "1",
            "23"
        ],
        "hidden_test_cases": [
            "maxSubArray([-1])",
            "maxSubArray([-2,-1])",
            "maxSubArray([1,2,3,4,5])",
            "maxSubArray([-1,-2,-3,-4,-5])",
            "maxSubArray([1,-1,1,-1,1,-1])",
            "maxSubArray([-2,1,-3,4,-1,2,1,-5,4])",
            "maxSubArray([0,0,0,0])",
            "maxSubArray([-1,0,-2,2])",
            "maxSubArray([1,-2,3,-4,5,-6,7,-8])",
            "maxSubArray([-1,-1,2,-1,-1])"
        ],
        "hidden_test_results": [
            "-1",
            "-1",
            "15",
            "-1",
            "1",
            "6",
            "0",
            "2",
            "7",
            "2"
        ],
        "boilerplate": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        ",
        "compare_func": "return str(result) == expected"
    },
    {
        "title": "Spiral Matrix",
        "source": "https://leetcode.com/problems/spiral-matrix/",
        "description": "<p>Given an <code>m x n</code> <code>matrix</code>, return <em>all elements of the</em> <code>matrix</code> <em>in spiral order</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>Output:</strong> [1,2,3,6,9,8,7,4,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n<strong>Output:</strong> [1,2,3,4,8,12,11,10,9,5,6,7]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10</code></li>\n\t<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "spiralOrder([[1,2,3],[4,5,6],[7,8,9]])",
            "spiralOrder([[1,2,3,4],[5,6,7,8],[9,10,11,12]])"
        ],
        "sample_test_results": [
            "[1, 2, 3, 6, 9, 8, 7, 4, 5]",
            "[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]"
        ],
        "hidden_test_cases": [
            "spiralOrder([[1]])",
            "spiralOrder([[1,2],[3,4]])",
            "spiralOrder([[1,2,3]])",
            "spiralOrder([[1],[2],[3]])",
            "spiralOrder([[1,2,3,4],[5,6,7,8]])",
            "spiralOrder([[1,2],[3,4],[5,6]])",
            "spiralOrder([[]])",
            "spiralOrder([])",
            "spiralOrder([[1,2,3],[4,5,6]])",
            "spiralOrder([[1,2],[3,4],[5,6],[7,8]])"
        ],
        "hidden_test_results": [
            "[1]",
            "[1, 2, 4, 3]",
            "[1, 2, 3]",
            "[1, 2, 3]",
            "[1, 2, 3, 4, 8, 7, 6, 5]",
            "[1, 2, 4, 6, 5, 3]",
            "[]",
            "[]",
            "[1, 2, 3, 6, 5, 4]",
            "[1, 2, 4, 6, 8, 7, 5, 3]"
        ],
        "boilerplate": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        ",
        "compare_func": "return str(result) == expected"
    },
    {
        "title": "Merge Intervals",
        "source": "https://leetcode.com/problems/merge-intervals/",
        "description": "<p>Given an array&nbsp;of <code>intervals</code>&nbsp;where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,3],[2,6],[8,10],[15,18]]\n<strong>Output:</strong> [[1,6],[8,10],[15,18]]\n<strong>Explanation:</strong> Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,4],[4,5]]\n<strong>Output:</strong> [[1,5]]\n<strong>Explanation:</strong> Intervals [1,4] and [4,5] are considered overlapping.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "merge([[1,3],[2,6],[8,10],[15,18]])",
            "merge([[1,4],[4,5]])"
        ],
        "sample_test_results": [
            "[[1, 6], [8, 10], [15, 18]]",
            "[[1, 5]]"
        ],
        "hidden_test_cases": [
            "merge([[1,4],[0,4]])",
            "merge([[1,4],[2,3]])",
            "merge([[1,4],[0,0]])",
            "merge([[1,4]])",
            "merge([[1,4],[5,6]])",
            "merge([[1,10],[2,3],[4,5],[6,7],[8,9]])",
            "merge([[1,2],[2,3],[3,4],[4,5]])",
            "merge([[1,5],[2,3]])",
            "merge([[1,4],[1,5]])",
            "merge([[1,4],[4,6],[5,7],[6,8]])"
        ],
        "hidden_test_results": [
            "[[0, 4]]",
            "[[1, 4]]",
            "[[0, 0], [1, 4]]",
            "[[1, 4]]",
            "[[1, 4], [5, 6]]",
            "[[1, 10]]",
            "[[1, 5]]",
            "[[1, 5]]",
            "[[1, 5]]",
            "[[1, 8]]"
        ],
        "boilerplate": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        ",
        "compare_func": "return str(sorted(result)) == str(eval(expected))"
    },
    {
        "title": "Insert Interval",
        "source": "https://leetcode.com/problems/insert-interval/",
        "description": "<p>You are given an array of non-overlapping intervals <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> represent the start and the end of the <code>i<sup>th</sup></code> interval and <code>intervals</code> is sorted in ascending order by <code>start<sub>i</sub></code>. You are also given an interval <code>newInterval = [start, end]</code> that represents the start and end of another interval.</p>\n\n<p>Insert <code>newInterval</code> into <code>intervals</code> such that <code>intervals</code> is still sorted in ascending order by <code>start<sub>i</sub></code> and <code>intervals</code> still does not have any overlapping intervals (merge overlapping intervals if necessary).</p>\n\n<p>Return <code>intervals</code><em> after the insertion</em>.</p>\n\n<p><strong>Note</strong> that you don&#39;t need to modify <code>intervals</code> in-place. You can make a new array and return it.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,3],[6,9]], newInterval = [2,5]\n<strong>Output:</strong> [[1,5],[6,9]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n<strong>Output:</strong> [[1,2],[3,10],[12,16]]\n<strong>Explanation:</strong> Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>intervals</code> is sorted by <code>start<sub>i</sub></code> in <strong>ascending</strong> order.</li>\n\t<li><code>newInterval.length == 2</code></li>\n\t<li><code>0 &lt;= start &lt;= end &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "insert([[1,3],[6,9]], [2,5])",
            "insert([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8])"
        ],
        "sample_test_results": [
            "[[1, 5], [6, 9]]",
            "[[1, 2], [3, 10], [12, 16]]"
        ],
        "hidden_test_cases": [
            "insert([], [5,7])",
            "insert([[1,5]], [2,3])",
            "insert([[1,5]], [2,7])",
            "insert([[1,5]], [6,8])",
            "insert([[1,5]], [0,3])",
            "insert([[3,5],[12,15]], [6,6])",
            "insert([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8])",
            "insert([[1,5]], [0,0])",
            "insert([[3,5],[12,15]], [1,2])",
            "insert([[1,5],[6,7]], [0,8])"
        ],
        "hidden_test_results": [
            "[[5, 7]]",
            "[[1, 5]]",
            "[[1, 7]]",
            "[[1, 5], [6, 8]]",
            "[[0, 5]]",
            "[[3, 5], [6, 6], [12, 15]]",
            "[[1, 2], [3, 10], [12, 16]]",
            "[[0, 0], [1, 5]]",
            "[[1, 2], [3, 5], [12, 15]]",
            "[[0, 8]]"
        ],
        "boilerplate": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        ",
        "compare_func": "return str(sorted(result)) == str(eval(expected))"
    },
    {
        "title": "Unique Paths II",
        "source": "https://leetcode.com/problems/unique-paths-ii/",
        "description": "<p>You are given an <code>m x n</code> integer array <code>grid</code>. There is a robot initially located at the <b>top-left corner</b> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p>\n\n<p>An obstacle and space are marked as <code>1</code> or <code>0</code> respectively in <code>grid</code>. A path that the robot takes cannot include <strong>any</strong> square that is an obstacle.</p>\n\n<p>Return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p>\n\n<p>The testcases are generated so that the answer will be less than or equal to <code>2 * 10<sup>9</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -&gt; Right -&gt; Down -&gt; Down\n2. Down -&gt; Down -&gt; Right -&gt; Right\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg\" style=\"width: 162px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> obstacleGrid = [[0,1],[0,0]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == obstacleGrid.length</code></li>\n\t<li><code>n == obstacleGrid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>obstacleGrid[i][j]</code> is <code>0</code> or <code>1</code>.</li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "uniquePathsWithObstacles([[0,0,0],[0,1,0],[0,0,0]])",
            "uniquePathsWithObstacles([[0,1],[0,0]])"
        ],
        "sample_test_results": [
            "2",
            "1"
        ],
        "hidden_test_cases": [
            "uniquePathsWithObstacles([[0]])",
            "uniquePathsWithObstacles([[1]])",
            "uniquePathsWithObstacles([[0,0],[0,1]])",
            "uniquePathsWithObstacles([[0,0],[1,0]])",
            "uniquePathsWithObstacles([[0,0,0]])",
            "uniquePathsWithObstacles([[0],[0],[0]])",
            "uniquePathsWithObstacles([[1,0]])",
            "uniquePathsWithObstacles([[0,1],[1,0]])",
            "uniquePathsWithObstacles([[0,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,0]])",
            "uniquePathsWithObstacles([[0,0,0],[0,0,0],[0,0,1]])"
        ],
        "hidden_test_results": [
            "1",
            "0",
            "0",
            "1",
            "1",
            "1",
            "0",
            "0",
            "4",
            "0"
        ],
        "boilerplate": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        ",
        "compare_func": "return str(result) == expected"
    },
    {
        "title": "Simplify Path",
        "source": "https://leetcode.com/problems/simplify-path/",
        "description": "<p>You are given an <em>absolute</em> path for a Unix-style file system, which always begins with a slash <code>&#39;/&#39;</code>. Your task is to transform this absolute path into its <strong>simplified canonical path</strong>.</p>\n\n<p>The <em>rules</em> of a Unix-style file system are as follows:</p>\n\n<ul>\n\t<li>A single period <code>&#39;.&#39;</code> represents the current directory.</li>\n\t<li>A double period <code>&#39;..&#39;</code> represents the previous/parent directory.</li>\n\t<li>Multiple consecutive slashes such as <code>&#39;//&#39;</code> and <code>&#39;///&#39;</code> are treated as a single slash <code>&#39;/&#39;</code>.</li>\n\t<li>Any sequence of periods that does <strong>not match</strong> the rules above should be treated as a <strong>valid directory or</strong> <strong>file </strong><strong>name</strong>. For example, <code>&#39;...&#39; </code>and <code>&#39;....&#39;</code> are valid directory or file names.</li>\n</ul>\n\n<p>The simplified canonical path should follow these <em>rules</em>:</p>\n\n<ul>\n\t<li>The path must start with a single slash <code>&#39;/&#39;</code>.</li>\n\t<li>Directories within the path must be separated by exactly one slash <code>&#39;/&#39;</code>.</li>\n\t<li>The path must not end with a slash <code>&#39;/&#39;</code>, unless it is the root directory.</li>\n\t<li>The path must not have any single or double periods (<code>&#39;.&#39;</code> and <code>&#39;..&#39;</code>) used to denote current or parent directories.</li>\n</ul>\n\n<p>Return the <strong>simplified canonical path</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">path = &quot;/home/&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;/home&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The trailing slash should be removed.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">path = &quot;/home//foo/&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;/home/foo&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>Multiple consecutive slashes are replaced by a single one.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">path = &quot;/home/user/Documents/../Pictures&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;/home/user/Pictures&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>A double period <code>&quot;..&quot;</code> refers to the directory up a level (the parent directory).</p>\n</div>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">path = &quot;/../&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;/&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>Going one level up from the root directory is not possible.</p>\n</div>\n\n<p><strong class=\"example\">Example 5:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">path = &quot;/.../a/../b/c/../d/./&quot;</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">&quot;/.../b/d&quot;</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><code>&quot;...&quot;</code> is a valid name for a directory in this problem.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= path.length &lt;= 3000</code></li>\n\t<li><code>path</code> consists of English letters, digits, period <code>&#39;.&#39;</code>, slash <code>&#39;/&#39;</code> or <code>&#39;_&#39;</code>.</li>\n\t<li><code>path</code> is a valid absolute Unix path.</li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "simplifyPath(\"/home/\")",
            "simplifyPath(\"/home//foo/\")",
            "simplifyPath(\"/home/user/Documents/../Pictures\")",
            "simplifyPath(\"/../\")",
            "simplifyPath(\"/.../a/../b/c/../d/./\")"
        ],
        "sample_test_results": [
            "'/home'",
            "'/home/foo'",
            "'/home/user/Pictures'",
            "'/'",
            "'/.../b/d'"
        ],
        "hidden_test_cases": [
            "simplifyPath(\"/a/./b/../../c/\")",
            "simplifyPath(\"/home/\")",
            "simplifyPath(\"/...\")",
            "simplifyPath(\"/..hidden\")",
            "simplifyPath(\"//\")",
            "simplifyPath(\"/a//b////c/d//././/..\")",
            "simplifyPath(\"/abc/...\")",
            "simplifyPath(\"/a/./b/./c/./d/\")",
            "simplifyPath(\"/a/../../b/../c//.//\")",
            "simplifyPath(\"/a//b//./c/d/\")"
        ],
        "hidden_test_results": [
            "'/c'",
            "'/home'",
            "'/...'",
            "'/..hidden'",
            "'/'",
            "'/a/b/c'",
            "'/abc/...'",
            "'/a/b/c/d'",
            "'/c'",
            "'/a/b/c/d'"
        ],
        "boilerplate": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Edit Distance",
        "source": "https://leetcode.com/problems/edit-distance/",
        "description": "<p>Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of operations required to convert <code>word1</code> to <code>word2</code></em>.</p>\n\n<p>You have the following three operations permitted on a word:</p>\n\n<ul>\n\t<li>Insert a character</li>\n\t<li>Delete a character</li>\n\t<li>Replace a character</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> word1 = &quot;horse&quot;, word2 = &quot;ros&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> \nhorse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)\nrorse -&gt; rose (remove &#39;r&#39;)\nrose -&gt; ros (remove &#39;e&#39;)\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> word1 = &quot;intention&quot;, word2 = &quot;execution&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> \nintention -&gt; inention (remove &#39;t&#39;)\ninention -&gt; enention (replace &#39;i&#39; with &#39;e&#39;)\nenention -&gt; exention (replace &#39;n&#39; with &#39;x&#39;)\nexention -&gt; exection (replace &#39;n&#39; with &#39;c&#39;)\nexection -&gt; execution (insert &#39;u&#39;)\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>\n\t<li><code>word1</code> and <code>word2</code> consist of lowercase English letters.</li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "minDistance('horse', 'ros')",
            "minDistance('intention', 'execution')",
            "minDistance('', 'a')"
        ],
        "sample_test_results": [
            "3",
            "5",
            "1"
        ],
        "hidden_test_cases": [
            "minDistance('', '')",
            "minDistance('a', '')",
            "minDistance('abc', 'abc')",
            "minDistance('abcde', 'ace')",
            "minDistance('sea', 'eat')",
            "minDistance('leetcode', 'practice')",
            "minDistance('hello', 'world')",
            "minDistance('pneumonoultramicroscopicsilicovolcanoconiosis', 'ultramicroscopically')",
            "minDistance('abc', 'def')",
            "minDistance('aaa', 'bbb')"
        ],
        "hidden_test_results": [
            "0",
            "1",
            "0",
            "2",
            "2",
            "7",
            "4",
            "27",
            "3",
            "3"
        ],
        "boilerplate": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        ",
        "compare_func": "return str(result) == expected"
    },
    {
        "title": "Search a 2D Matrix",
        "source": "https://leetcode.com/problems/search-a-2d-matrix/",
        "description": "<p>You are given an <code>m x n</code> integer matrix <code>matrix</code> with the following two properties:</p>\n\n<ul>\n\t<li>Each row is sorted in non-decreasing order.</li>\n\t<li>The first integer of each row is greater than the last integer of the previous row.</li>\n</ul>\n\n<p>Given an integer <code>target</code>, return <code>true</code> <em>if</em> <code>target</code> <em>is in</em> <code>matrix</code> <em>or</em> <code>false</code> <em>otherwise</em>.</p>\n\n<p>You must write a solution in <code>O(log(m * n))</code> time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/mat.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= matrix[i][j], target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "searchMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 3)",
            "searchMatrix([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 13)",
            "searchMatrix([[1]], 1)"
        ],
        "sample_test_results": [
            "True",
            "False",
            "True"
        ],
        "hidden_test_cases": [
            "searchMatrix([[1]], 2)",
            "searchMatrix([[1,2,3]], 2)",
            "searchMatrix([[1],[2],[3]], 2)",
            "searchMatrix([[1,2],[3,4]], 4)",
            "searchMatrix([[-10,-8],[15,20]], -8)",
            "searchMatrix([[1,2,3,4],[5,6,7,8]], 6)",
            "searchMatrix([[1,2,3],[4,5,6],[7,8,9]], 9)",
            "searchMatrix([[1]], 0)",
            "searchMatrix([[1,3,5]], 5)",
            "searchMatrix([[1],[3],[5]], 3)"
        ],
        "hidden_test_results": [
            "False",
            "True",
            "True",
            "True",
            "True",
            "True",
            "True",
            "False",
            "True",
            "True"
        ],
        "boilerplate": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        ",
        "compare_func": "return str(result).lower() == expected.lower()"
    },
    {
        "title": "Word Search",
        "source": "https://leetcode.com/problems/word-search/",
        "description": "<p>Given an <code>m x n</code> grid of characters <code>board</code> and a string <code>word</code>, return <code>true</code> <em>if</em> <code>word</code> <em>exists in the grid</em>.</p>\n\n<p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word2.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/word3.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n = board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 6</code></li>\n\t<li><code>1 &lt;= word.length &lt;= 15</code></li>\n\t<li><code>board</code> and <code>word</code> consists of only lowercase and uppercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you use search pruning to make your solution faster with a larger <code>board</code>?</p>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "exist([['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], 'ABCCED')",
            "exist([['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], 'SEE')",
            "exist([['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], 'ABCB')"
        ],
        "sample_test_results": [
            "True",
            "True",
            "False"
        ],
        "hidden_test_cases": [
            "exist([['A']], 'A')",
            "exist([['A','B'],['C','D']], 'ABDC')",
            "exist([['A','B']], 'BA')",
            "exist([['A','B','C'],['D','E','F']], 'CBA')",
            "exist([['A']], 'B')",
            "exist([['A','A']], 'AAA')",
            "exist([['A','B','C']], 'ABC')",
            "exist([['A'],['B'],['C']], 'ABC')",
            "exist([['A','B'],['C','D']], 'AC')",
            "exist([['A','B','C'],['D','E','F'],['G','H','I']], 'ABCFIHG')"
        ],
        "hidden_test_results": [
            "True",
            "True",
            "True",
            "True",
            "False",
            "False",
            "True",
            "True",
            "True",
            "True"
        ],
        "boilerplate": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        ",
        "compare_func": "return str(result).lower() == expected.lower()"
    },
    {
        "title": "Subsets II",
        "source": "https://leetcode.com/problems/subsets-ii/",
        "description": "<p>Given an integer array <code>nums</code> that may contain duplicates, return <em>all possible</em> <span data-keyword=\"subset\"><em>subsets</em></span><em> (the power set)</em>.</p>\n\n<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,2]\n<strong>Output:</strong> [[],[1],[1,2],[1,2,2],[2],[2,2]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [0]\n<strong>Output:</strong> [[],[0]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "subsetsWithDup([1,2,2])",
            "subsetsWithDup([0])",
            "subsetsWithDup([1,1,1])"
        ],
        "sample_test_results": [
            "[[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]",
            "[[], [0]]",
            "[[], [1], [1, 1], [1, 1, 1]]"
        ],
        "hidden_test_cases": [
            "subsetsWithDup([1])",
            "subsetsWithDup([1,2])",
            "subsetsWithDup([1,2,3])",
            "subsetsWithDup([2,2,2,2])",
            "subsetsWithDup([1,2,2,3])",
            "subsetsWithDup([1,1,2,2])",
            "subsetsWithDup([3,2,1])",
            "subsetsWithDup([-1,0,1])",
            "subsetsWithDup([0,0,0])",
            "subsetsWithDup([4,4,4,1,4])"
        ],
        "hidden_test_results": [
            "[[], [1]]",
            "[[], [1], [1, 2], [2]]",
            "[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]",
            "[[], [2], [2, 2], [2, 2, 2], [2, 2, 2, 2]]",
            "[[], [1], [1, 2], [1, 2, 2], [1, 2, 2, 3], [1, 2, 3], [1, 3], [2], [2, 2], [2, 2, 3], [2, 3], [3]]",
            "[[], [1], [1, 1], [1, 1, 2], [1, 1, 2, 2], [1, 2], [1, 2, 2], [2], [2, 2]]",
            "[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]",
            "[[], [-1], [-1, 0], [-1, 0, 1], [-1, 1], [0], [0, 1], [1]]",
            "[[], [0], [0, 0], [0, 0, 0]]",
            "[[], [1], [1, 4], [1, 4, 4], [1, 4, 4, 4], [1, 4, 4, 4, 4], [4], [4, 4], [4, 4, 4], [4, 4, 4, 4]]"
        ],
        "boilerplate": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        ",
        "compare_func": "return sorted([sorted(x) for x in result]) == sorted(eval(expected))"
    },
    {
        "title": "Restore IP Addresses",
        "source": "https://leetcode.com/problems/restore-ip-addresses/",
        "description": "<p>A <strong>valid IP address</strong> consists of exactly four integers separated by single dots. Each integer is between <code>0</code> and <code>255</code> (<strong>inclusive</strong>) and cannot have leading zeros.</p>\n\n<ul>\n\t<li>For example, <code>&quot;0.1.2.201&quot;</code> and <code>&quot;192.168.1.1&quot;</code> are <strong>valid</strong> IP addresses, but <code>&quot;0.011.255.245&quot;</code>, <code>&quot;192.168.1.312&quot;</code> and <code>&quot;192.168@1.1&quot;</code> are <strong>invalid</strong> IP addresses.</li>\n</ul>\n\n<p>Given a string <code>s</code> containing only digits, return <em>all possible valid IP addresses that can be formed by inserting dots into </em><code>s</code>. You are <strong>not</strong> allowed to reorder or remove any digits in <code>s</code>. You may return the valid IP addresses in <strong>any</strong> order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;25525511135&quot;\n<strong>Output:</strong> [&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;0000&quot;\n<strong>Output:</strong> [&quot;0.0.0.0&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;101023&quot;\n<strong>Output:</strong> [&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>s</code> consists of digits only.</li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "restoreIpAddresses('25525511135')",
            "restoreIpAddresses('0000')",
            "restoreIpAddresses('101023')"
        ],
        "sample_test_results": [
            "['255.255.11.135', '255.255.111.35']",
            "['0.0.0.0']",
            "['1.0.10.23', '1.0.102.3', '10.1.0.23', '10.10.2.3', '101.0.2.3']"
        ],
        "hidden_test_cases": [
            "restoreIpAddresses('1111')",
            "restoreIpAddresses('010010')",
            "restoreIpAddresses('0')",
            "restoreIpAddresses('999999')",
            "restoreIpAddresses('1921680')",
            "restoreIpAddresses('2552551113')",
            "restoreIpAddresses('00001')",
            "restoreIpAddresses('100100')",
            "restoreIpAddresses('12345')",
            "restoreIpAddresses('1111111')"
        ],
        "hidden_test_results": [
            "['1.1.1.1']",
            "['0.10.0.10', '0.100.1.0']",
            "[]",
            "['9.9.99.99', '9.99.9.99', '9.99.99.9', '99.9.9.99', '99.9.99.9', '99.99.9.9']",
            "['1.9.216.80', '1.92.16.80', '1.92.168.0', '19.2.16.80', '19.2.168.0', '19.21.6.80', '19.21.68.0', '19.216.8.0', '192.1.6.80', '192.1.68.0', '192.16.8.0']",
            "['255.25.51.113', '255.255.1.113', '255.255.11.13', '255.255.111.3']",
            "[]",
            "['1.0.0.100', '10.0.10.0', '100.1.0.0']",
            "['1.2.3.45', '1.2.34.5', '1.23.4.5', '12.3.4.5']",
            "['1.1.11.111', '1.1.111.11', '1.11.1.111', '1.11.11.11', '1.11.111.1', '1.111.1.11', '1.111.11.1', '11.1.1.111', '11.1.11.11', '11.1.111.1', '11.11.1.11', '11.11.11.1', '11.111.1.1', '111.1.1.11', '111.1.11.1', '111.11.1.1']"
        ],
        "boilerplate": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        ",
        "compare_func": "return sorted(result) == sorted(eval(expected))"
    },
    {
        "title": "Interleaving String",
        "source": "https://leetcode.com/problems/interleaving-string/",
        "description": "<p>Given strings <code>s1</code>, <code>s2</code>, and <code>s3</code>, find whether <code>s3</code> is formed by an <strong>interleaving</strong> of <code>s1</code> and <code>s2</code>.</p>\n\n<p>An <strong>interleaving</strong> of two strings <code>s</code> and <code>t</code> is a configuration where <code>s</code> and <code>t</code> are divided into <code>n</code> and <code>m</code> <span data-keyword=\"substring-nonempty\">substrings</span> respectively, such that:</p>\n\n<ul>\n\t<li><code>s = s<sub>1</sub> + s<sub>2</sub> + ... + s<sub>n</sub></code></li>\n\t<li><code>t = t<sub>1</sub> + t<sub>2</sub> + ... + t<sub>m</sub></code></li>\n\t<li><code>|n - m| &lt;= 1</code></li>\n\t<li>The <strong>interleaving</strong> is <code>s<sub>1</sub> + t<sub>1</sub> + s<sub>2</sub> + t<sub>2</sub> + s<sub>3</sub> + t<sub>3</sub> + ...</code> or <code>t<sub>1</sub> + s<sub>1</sub> + t<sub>2</sub> + s<sub>2</sub> + t<sub>3</sub> + s<sub>3</sub> + ...</code></li>\n</ul>\n\n<p><strong>Note:</strong> <code>a + b</code> is the concatenation of strings <code>a</code> and <code>b</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg\" style=\"width: 561px; height: 203px;\" />\n<pre>\n<strong>Input:</strong> s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> One way to obtain s3 is:\nSplit s1 into s1 = &quot;aa&quot; + &quot;bc&quot; + &quot;c&quot;, and s2 into s2 = &quot;dbbc&quot; + &quot;a&quot;.\nInterleaving the two splits, we get &quot;aa&quot; + &quot;dbbc&quot; + &quot;bc&quot; + &quot;a&quot; + &quot;c&quot; = &quot;aadbbcbcac&quot;.\nSince s3 can be obtained by interleaving s1 and s2, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Notice how it is impossible to interleave s2 with any other string to obtain s3.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;&quot;, s2 = &quot;&quot;, s3 = &quot;&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s1.length, s2.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= s3.length &lt;= 200</code></li>\n\t<li><code>s1</code>, <code>s2</code>, and <code>s3</code> consist of lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you solve it using only <code>O(s2.length)</code> additional memory space?</p>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "isInterleave('aabcc', 'dbbca', 'aadbbcbcac')",
            "isInterleave('aabcc', 'dbbca', 'aadbbbaccc')",
            "isInterleave('', '', '')"
        ],
        "sample_test_results": [
            "True",
            "False",
            "True"
        ],
        "hidden_test_cases": [
            "isInterleave('abc', 'def', 'adbecf')",
            "isInterleave('a', 'b', 'ab')",
            "isInterleave('a', 'b', 'ba')",
            "isInterleave('aa', 'ab', 'aaba')",
            "isInterleave('aaa', 'bbb', 'ababab')",
            "isInterleave('', 'abc', 'abc')",
            "isInterleave('abc', '', 'abc')",
            "isInterleave('abc', 'def', 'abcdef')",
            "isInterleave('aaa', 'aaa', 'aaaaaa')",
            "isInterleave('abc', 'def', 'abcef')"
        ],
        "hidden_test_results": [
            "True",
            "True",
            "True",
            "True",
            "True",
            "True",
            "True",
            "True",
            "True",
            "False"
        ],
        "boilerplate": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        ",
        "compare_func": "return str(result).lower() == expected.lower()"
    },
    {
        "title": "Triangle",
        "source": "https://leetcode.com/problems/triangle/",
        "description": "<p>Given a <code>triangle</code> array, return <em>the minimum path sum from top to bottom</em>.</p>\n\n<p>For each step, you may move to an adjacent number of the row below. More formally, if you are on index <code>i</code> on the current row, you may move to either index <code>i</code> or index <code>i + 1</code> on the next row.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> The triangle looks like:\n   <u>2</u>\n  <u>3</u> 4\n 6 <u>5</u> 7\n4 <u>1</u> 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> triangle = [[-10]]\n<strong>Output:</strong> -10\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= triangle.length &lt;= 200</code></li>\n\t<li><code>triangle[0].length == 1</code></li>\n\t<li><code>triangle[i].length == triangle[i - 1].length + 1</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= triangle[i][j] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you&nbsp;do this using only <code>O(n)</code> extra space, where <code>n</code> is the total number of rows in the triangle?",
        "difficulty": "medium",
        "sample_test_cases": [
            "minimumTotal([[2],[3,4],[6,5,7],[4,1,8,3]])",
            "minimumTotal([[-10]])"
        ],
        "sample_test_results": [
            "11",
            "-10"
        ],
        "hidden_test_cases": [
            "minimumTotal([[1]])",
            "minimumTotal([[1],[2,3]])",
            "minimumTotal([[-1],[2,3],[1,-1,3]])",
            "minimumTotal([[1],[1,2],[1,2,3],[1,2,3,4]])",
            "minimumTotal([[0],[-1,2],[1,-2,3],[-3,1,-1,2]])",
            "minimumTotal([[1],[-5,2],[2,-1,3],[1,2,-4,5]])",
            "minimumTotal([[0],[0,0],[0,0,0]])",
            "minimumTotal([[1],[-1,-2],[3,-3,1],[-4,5,-6,2]])",
            "minimumTotal([[10],[-2,-3],[1,2,-1]])",
            "minimumTotal([[1],[2,1],[3,3,1]])"
        ],
        "hidden_test_results": [
            "1",
            "3",
            "0",
            "4",
            "-4",
            "-9",
            "0",
            "-10",
            "6",
            "3"
        ],
        "boilerplate": "class Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        ",
        "compare_func": "return str(result) == expected"
    },
    {
        "title": "Longest Consecutive Sequence",
        "source": "https://leetcode.com/problems/longest-consecutive-sequence/",
        "description": "<p>Given an unsorted array of integers <code>nums</code>, return <em>the length of the longest consecutive elements sequence.</em></p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [100,4,200,1,3,2]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Therefore its length is 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,3,7,2,5,8,4,6,0,1]\n<strong>Output:</strong> 9\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "longestConsecutive([100,4,200,1,3,2])",
            "longestConsecutive([0,3,7,2,5,8,4,6,0,1])"
        ],
        "sample_test_results": [
            "4",
            "9"
        ],
        "hidden_test_cases": [
            "longestConsecutive([])",
            "longestConsecutive([1])",
            "longestConsecutive([1,2,3,4,5])",
            "longestConsecutive([1,3,5,7,9])",
            "longestConsecutive([-5,-4,-3,-2,-1])",
            "longestConsecutive([1,1,1,1,1])",
            "longestConsecutive([1,2,0,1])",
            "longestConsecutive([0,-1,2,-2,3,-3])",
            "longestConsecutive([1000,1,2,3,4,999])",
            "longestConsecutive([5,4,3,2,1,6,7,8,9])"
        ],
        "hidden_test_results": [
            "0",
            "1",
            "5",
            "1",
            "5",
            "1",
            "3",
            "4",
            "4",
            "9"
        ],
        "boilerplate": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        ",
        "compare_func": "return str(result) == expected"
    },
    {
        "title": "Gas Station",
        "source": "https://leetcode.com/problems/gas-station/",
        "description": "<p>There are <code>n</code> gas stations along a circular route, where the amount of gas at the <code>i<sup>th</sup></code> station is <code>gas[i]</code>.</p>\n\n<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from the <code>i<sup>th</sup></code> station to its next <code>(i + 1)<sup>th</sup></code> station. You begin the journey with an empty tank at one of the gas stations.</p>\n\n<p>Given two integer arrays <code>gas</code> and <code>cost</code>, return <em>the starting gas station&#39;s index if you can travel around the circuit once in the clockwise direction, otherwise return</em> <code>-1</code>. If there exists a solution, it is <strong>guaranteed</strong> to be <strong>unique</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> gas = [2,3,4], cost = [3,4,3]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong>\nYou can&#39;t start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet&#39;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can&#39;t travel around the circuit once no matter where you start.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == gas.length == cost.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= gas[i], cost[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "canCompleteCircuit([1,2,3,4,5], [3,4,5,1,2])",
            "canCompleteCircuit([2,3,4], [3,4,3])"
        ],
        "sample_test_results": [
            "3",
            "-1"
        ],
        "hidden_test_cases": [
            "canCompleteCircuit([1], [1])",
            "canCompleteCircuit([2], [1])",
            "canCompleteCircuit([1,2], [2,1])",
            "canCompleteCircuit([5,1,2,3,4], [4,4,1,5,1])",
            "canCompleteCircuit([4,5,2,6,5,3], [3,2,7,3,2,9])",
            "canCompleteCircuit([1,2,3], [2,3,1])",
            "canCompleteCircuit([3,1,1], [1,2,2])",
            "canCompleteCircuit([5,8,2,8], [6,5,6,6])",
            "canCompleteCircuit([1,1,1], [1,1,1])",
            "canCompleteCircuit([2,0,1], [1,1,1])"
        ],
        "hidden_test_results": [
            "0",
            "0",
            "1",
            "4",
            "-1",
            "2",
            "0",
            "3",
            "0",
            "0"
        ],
        "boilerplate": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        ",
        "compare_func": "return str(result) == expected"
    },
    {
        "title": "Word Break",
        "source": "https://leetcode.com/problems/word-break/",
        "description": "<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p>\n\n<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;,&quot;code&quot;]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.\nNote that you are allowed to reuse a dictionary word.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>\n\t<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>\n\t<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "wordBreak('leetcode', ['leet','code'])",
            "wordBreak('applepenapple', ['apple','pen'])",
            "wordBreak('catsandog', ['cats','dog','sand','and','cat'])"
        ],
        "sample_test_results": [
            "True",
            "True",
            "False"
        ],
        "hidden_test_cases": [
            "wordBreak('a', ['a'])",
            "wordBreak('ab', ['a','b'])",
            "wordBreak('cars', ['car','ca','rs'])",
            "wordBreak('goalspecial', ['go','goal','goals','special'])",
            "wordBreak('aaaaaaa', ['aaa','aaaa'])",
            "wordBreak('impossible', ['imp','possible'])",
            "wordBreak('python', ['py','thon'])",
            "wordBreak('abcd', ['ab','abc','cd','abcd'])",
            "wordBreak('helloworld', ['hello','world','hell','or'])",
            "wordBreak('noway', ['no','way','now','ay'])"
        ],
        "hidden_test_results": [
            "True",
            "True",
            "True",
            "True",
            "True",
            "False",
            "True",
            "True",
            "True",
            "True"
        ],
        "boilerplate": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        ",
        "compare_func": "return str(result).lower() == expected.lower()"
    },
    {
        "title": "Evaluate Reverse Polish Notation",
        "source": "https://leetcode.com/problems/evaluate-reverse-polish-notation/",
        "description": "<p>You are given an array of strings <code>tokens</code> that represents an arithmetic expression in a <a href=\"http://en.wikipedia.org/wiki/Reverse_Polish_notation\" target=\"_blank\">Reverse Polish Notation</a>.</p>\n\n<p>Evaluate the expression. Return <em>an integer that represents the value of the expression</em>.</p>\n\n<p><strong>Note</strong> that:</p>\n\n<ul>\n\t<li>The valid operators are <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, and <code>&#39;/&#39;</code>.</li>\n\t<li>Each operand may be an integer or another expression.</li>\n\t<li>The division between two integers always <strong>truncates toward zero</strong>.</li>\n\t<li>There will not be any division by zero.</li>\n\t<li>The input represents a valid arithmetic expression in a reverse polish notation.</li>\n\t<li>The answer and all the intermediate calculations can be represented in a <strong>32-bit</strong> integer.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> ((2 + 1) * 3) = 9\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> (4 + (13 / 5)) = 6\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]\n<strong>Output:</strong> 22\n<strong>Explanation:</strong> ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tokens.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>tokens[i]</code> is either an operator: <code>&quot;+&quot;</code>, <code>&quot;-&quot;</code>, <code>&quot;*&quot;</code>, or <code>&quot;/&quot;</code>, or an integer in the range <code>[-200, 200]</code>.</li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "evalRPN([\"2\",\"1\",\"+\",\"3\",\"*\"])",
            "evalRPN([\"4\",\"13\",\"5\",\"/\",\"+\"])",
            "evalRPN([\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"])"
        ],
        "sample_test_results": [
            "9",
            "6",
            "22"
        ],
        "hidden_test_cases": [
            "evalRPN([\"1\"])",
            "evalRPN([\"2\",\"3\",\"+\"])",
            "evalRPN([\"4\",\"5\",\"*\"])",
            "evalRPN([\"10\",\"5\",\"/\"])",
            "evalRPN([\"15\",\"7\",\"-\"])",
            "evalRPN([\"2\",\"1\",\"3\",\"*\",\"+\"])",
            "evalRPN([\"-2\",\"3\",\"*\",\"4\",\"+\"])",
            "evalRPN([\"10\",\"2\",\"*\",\"3\",\"4\",\"*\",\"+\"])",
            "evalRPN([\"5\",\"3\",\"/\",\"2\",\"*\"])",
            "evalRPN([\"100\",\"200\",\"+\",\"2\",\"/\"])"
        ],
        "hidden_test_results": [
            "1",
            "5",
            "20",
            "2",
            "8",
            "5",
            "-2",
            "32",
            "2",
            "150"
        ],
        "boilerplate": "class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        ",
        "compare_func": "return int(result) == int(expected)"
    },
    {
        "title": "Reverse Words in a String",
        "source": "https://leetcode.com/problems/reverse-words-in-a-string/",
        "description": "<p>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p>\n\n<p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code> will be separated by at least one space.</p>\n\n<p>Return <em>a string of the words in reverse order concatenated by a single space.</em></p>\n\n<p><b>Note</b> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;the sky is blue&quot;\n<strong>Output:</strong> &quot;blue is sky the&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;  hello world  &quot;\n<strong>Output:</strong> &quot;world hello&quot;\n<strong>Explanation:</strong> Your reversed string should not contain leading or trailing spaces.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a good   example&quot;\n<strong>Output:</strong> &quot;example good a&quot;\n<strong>Explanation:</strong> You need to reduce multiple spaces between two words to a single space in the reversed string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> contains English letters (upper-case and lower-case), digits, and spaces <code>&#39; &#39;</code>.</li>\n\t<li>There is <strong>at least one</strong> word in <code>s</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><b data-stringify-type=\"bold\">Follow-up:&nbsp;</b>If the string data type is mutable in your language, can&nbsp;you solve it&nbsp;<b data-stringify-type=\"bold\">in-place</b>&nbsp;with&nbsp;<code data-stringify-type=\"code\">O(1)</code>&nbsp;extra space?</p>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "reverseWords(\"the sky is blue\")",
            "reverseWords(\"  hello world  \")",
            "reverseWords(\"a good   example\")"
        ],
        "sample_test_results": [
            "'blue is sky the'",
            "'world hello'",
            "'example good a'"
        ],
        "hidden_test_cases": [
            "reverseWords(\"hello\")",
            "reverseWords(\"   spaces   \")",
            "reverseWords(\"first second third\")",
            "reverseWords(\"  multiple   spaces  here  \")",
            "reverseWords(\"1 2 3 4 5\")",
            "reverseWords(\"a\")",
            "reverseWords(\"  start  end  \")",
            "reverseWords(\"comma,no space\")",
            "reverseWords(\"mixed   Case   woRDs\")",
            "reverseWords(\"   lots   of    spaces   \")"
        ],
        "hidden_test_results": [
            "'hello'",
            "'spaces'",
            "'third second first'",
            "'here spaces multiple'",
            "'5 4 3 2 1'",
            "'a'",
            "'end start'",
            "'space comma,no'",
            "'woRDs Case mixed'",
            "'spaces of lots'"
        ],
        "boilerplate": "class Solution:\n    def reverseWords(self, s: str) -> str:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Find Minimum in Rotated Sorted Array",
        "source": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
        "description": "<p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,2,4,5,6,7]</code> might become:</p>\n\n<ul>\n\t<li><code>[4,5,6,7,0,1,2]</code> if it was rotated <code>4</code> times.</li>\n\t<li><code>[0,1,2,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>\n</ul>\n\n<p>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>\n\n<p>Given the sorted rotated array <code>nums</code> of <strong>unique</strong> elements, return <em>the minimum element of this array</em>.</p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(log n) time</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,4,5,1,2]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The original array was [1,2,3,4,5] rotated 3 times.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,5,6,7,0,1,2]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [11,13,15,17]\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> The original array was [11,13,15,17] and it was rotated 4 times. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>\n\t<li>All the integers of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times.</li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "findMin([3,4,5,1,2])",
            "findMin([4,5,6,7,0,1,2])",
            "findMin([11,13,15,17])"
        ],
        "sample_test_results": [
            "1",
            "0",
            "11"
        ],
        "hidden_test_cases": [
            "findMin([45, 19, 22, 27, 32, 36, 41])",
            "findMin([-29])",
            "findMin([29, 30, 35, 38, 41, 46, 50, 54, 59, 61, 63, 68, 20, 22, 26])",
            "findMin([56, 16, 19, 23, 26, 31, 34, 35, 36, 37, 41, 44, 46, 49, 51])",
            "findMin([11, 16, 19, 21, 26, 30, 35, 37, 41, -3, -2, 0, 5, 6, 7])",
            "findMin([43, 47, 29, 30, 35, 40, 41])",
            "findMin([14, 19, 20, 25, 28, 29, -1, 2, 6, 9])",
            "findMin([14, 19, 20, 25, 28, 29, -1, 2, 6, 9])",
            "findMin([31, 33, 29, 30])",
            "findMin([47, 48, 52, 14, 18, 23, 26, 29, 34, 39, 44])"
        ],
        "hidden_test_results": [
            "19",
            "-29",
            "20",
            "16",
            "-3",
            "29",
            "-1",
            "-1",
            "29",
            "14"
        ],
        "boilerplate": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        ",
        "compare_func": "return int(result) == int(expected)"
    },
    {
        "title": "Find Peak Element",
        "source": "https://leetcode.com/problems/find-peak-element/",
        "description": "<p>A peak element is an element that is strictly greater than its neighbors.</p>\n\n<p>Given a <strong>0-indexed</strong> integer array <code>nums</code>, find a peak element, and return its index. If the array contains multiple peaks, return the index to <strong>any of the peaks</strong>.</p>\n\n<p>You may imagine that <code>nums[-1] = nums[n] = -&infin;</code>. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.</p>\n\n<p>You must write an algorithm that runs in <code>O(log n)</code> time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> 3 is a peak element and your function should return the index number 2.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,1,3,5,6,4]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>nums[i] != nums[i + 1]</code> for all valid <code>i</code>.</li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "findPeakElement([1,2,3,1])",
            "findPeakElement([1,2,1,3,5,6,4])"
        ],
        "sample_test_results": [
            "2",
            "5"
        ],
        "hidden_test_cases": [
            "findPeakElement([1])",
            "findPeakElement([1,2])",
            "findPeakElement([2,1])",
            "findPeakElement([1,2,3])",
            "findPeakElement([3,2,1])",
            "findPeakElement([1,3,2,4,5])",
            "findPeakElement([5,4,3,2,1])",
            "findPeakElement([1,5,3,7,4])",
            "findPeakElement([1,2,3,4,3])",
            "findPeakElement([3,1,4,5,2])"
        ],
        "hidden_test_results": [
            "0",
            "1",
            "0",
            "2",
            "0",
            "4",
            "0",
            "3",
            "3",
            "3"
        ],
        "boilerplate": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Maximum Gap",
        "source": "https://leetcode.com/problems/maximum-gap/",
        "description": "<p>Given an integer array <code>nums</code>, return <em>the maximum difference between two successive elements in its sorted form</em>. If the array contains less than two elements, return <code>0</code>.</p>\n\n<p>You must write an algorithm that runs in linear time and uses linear extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,6,9,1]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The array contains less than 2 elements, therefore return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "difficulty": "medium",
        "sample_test_cases": [
            "maximumGap([3,6,9,1])",
            "maximumGap([10])"
        ],
        "sample_test_results": [
            "3",
            "0"
        ],
        "hidden_test_cases": [
            "maximumGap([1,2,3,4])",
            "maximumGap([1,10])",
            "maximumGap([1,1,1,1])",
            "maximumGap([1,3,100])",
            "maximumGap([1])",
            "maximumGap([1,5,2,8,3])",
            "maximumGap([87,53,100,1])",
            "maximumGap([1000,1,500,2])",
            "maximumGap([1,10000,1,10000])",
            "maximumGap([1,2,3,5,6,7,8,9,10,100])"
        ],
        "hidden_test_results": [
            "1",
            "9",
            "0",
            "97",
            "0",
            "3",
            "52",
            "500",
            "9999",
            "90"
        ],
        "boilerplate": "class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        ",
        "compare_func": "return int(result) == int(expected)"
    },
    {
        "title": "Median of Two Sorted Arrays",
        "source": "https://leetcode.com/problems/median-of-two-sorted-arrays/",
        "description": "<p>Given two sorted arrays <code>nums1</code> and <code>nums2</code> of size <code>m</code> and <code>n</code> respectively, return <strong>the median</strong> of the two sorted arrays.</p>\n\n<p>The overall run time complexity should be <code>O(log (m+n))</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,3], nums2 = [2]\n<strong>Output:</strong> 2.00000\n<strong>Explanation:</strong> merged array = [1,2,3] and median is 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2], nums2 = [3,4]\n<strong>Output:</strong> 2.50000\n<strong>Explanation:</strong> merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>nums1.length == m</code></li>\n\t<li><code>nums2.length == n</code></li>\n\t<li><code>0 &lt;= m &lt;= 1000</code></li>\n\t<li><code>0 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m + n &lt;= 2000</code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "difficulty": "hard",
        "sample_test_cases": [
            "findMedianSortedArrays([1,3], [2])",
            "findMedianSortedArrays([1,2], [3,4])",
            "findMedianSortedArrays([], [1])"
        ],
        "sample_test_results": [
            "2",
            "2.5",
            "1"
        ],
        "hidden_test_cases": [
            "findMedianSortedArrays([1], [1])",
            "findMedianSortedArrays([1,2,3,4,5], [])",
            "findMedianSortedArrays([], [1,2,3,4,5])",
            "findMedianSortedArrays([1], [2,3,4,5,6])",
            "findMedianSortedArrays([1,2,3,4,5], [6])",
            "findMedianSortedArrays([1,3,5,7], [2,4,6,8])",
            "findMedianSortedArrays([1,1,1,1], [1,1,1,1])",
            "findMedianSortedArrays([-1,0,1], [-2,2])",
            "findMedianSortedArrays([10000], [-10000])",
            "findMedianSortedArrays([1,2], [1,2,3])"
        ],
        "hidden_test_results": [
            "1.0",
            "3",
            "3",
            "3.5",
            "3.5",
            "4.5",
            "1.0",
            "0",
            "0.0",
            "2"
        ],
        "boilerplate": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        ",
        "compare_func": "return abs(float(result) - float(expected)) < 0.00001"
    },
    {
        "title": "First Missing Positive",
        "source": "https://leetcode.com/problems/first-missing-positive/",
        "description": "<p>Given an unsorted integer array <code>nums</code>. Return the <em>smallest positive integer</em> that is <em>not present</em> in <code>nums</code>.</p>\n\n<p>You must implement an algorithm that runs in <code>O(n)</code> time and uses <code>O(1)</code> auxiliary space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,0]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The numbers in the range [1,2] are all in the array.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,4,-1,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> 1 is in the array but 2 is missing.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [7,8,9,11,12]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The smallest positive integer 1 is missing.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "difficulty": "hard",
        "sample_test_cases": [
            "firstMissingPositive([1,2,0])",
            "firstMissingPositive([3,4,-1,1])",
            "firstMissingPositive([7,8,9,11,12])"
        ],
        "sample_test_results": [
            "3",
            "2",
            "1"
        ],
        "hidden_test_cases": [
            "firstMissingPositive([1])",
            "firstMissingPositive([1,1])",
            "firstMissingPositive([-1,-2,-3])",
            "firstMissingPositive([1,2,3,4,5])",
            "firstMissingPositive([2])",
            "firstMissingPositive([1,2,4])",
            "firstMissingPositive([1,1,1,1,1])",
            "firstMissingPositive([2147483647])",
            "firstMissingPositive([-2147483648])",
            "firstMissingPositive([1,2,3,3,3])"
        ],
        "hidden_test_results": [
            "2",
            "2",
            "1",
            "6",
            "1",
            "3",
            "2",
            "1",
            "1",
            "4"
        ],
        "boilerplate": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        ",
        "compare_func": "return str(result) == expected"
    },
    {
        "title": "Permutation Sequence",
        "source": "https://leetcode.com/problems/permutation-sequence/",
        "description": "<p>The set <code>[1, 2, 3, ...,&nbsp;n]</code> contains a total of <code>n!</code> unique permutations.</p>\n\n<p>By listing and labeling all of the permutations in order, we get the following sequence for <code>n = 3</code>:</p>\n\n<ol>\n\t<li><code>&quot;123&quot;</code></li>\n\t<li><code>&quot;132&quot;</code></li>\n\t<li><code>&quot;213&quot;</code></li>\n\t<li><code>&quot;231&quot;</code></li>\n\t<li><code>&quot;312&quot;</code></li>\n\t<li><code>&quot;321&quot;</code></li>\n</ol>\n\n<p>Given <code>n</code> and <code>k</code>, return the <code>k<sup>th</sup></code> permutation sequence.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 3, k = 3\n<strong>Output:</strong> \"213\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 4, k = 9\n<strong>Output:</strong> \"2314\"\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> n = 3, k = 1\n<strong>Output:</strong> \"123\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 9</code></li>\n\t<li><code>1 &lt;= k &lt;= n!</code></li>\n</ul>\n",
        "difficulty": "hard",
        "sample_test_cases": [
            "getPermutation(3, 3)",
            "getPermutation(4, 9)",
            "getPermutation(3, 1)"
        ],
        "sample_test_results": [
            "'213'",
            "'2314'",
            "'123'"
        ],
        "hidden_test_cases": [
            "getPermutation(1, 1)",
            "getPermutation(2, 1)",
            "getPermutation(2, 2)",
            "getPermutation(3, 6)",
            "getPermutation(4, 1)",
            "getPermutation(4, 24)",
            "getPermutation(5, 5)",
            "getPermutation(6, 720)",
            "getPermutation(7, 1)",
            "getPermutation(8, 40320)"
        ],
        "hidden_test_results": [
            "'1'",
            "'12'",
            "'21'",
            "'321'",
            "'1234'",
            "'4321'",
            "'12534'",
            "'654321'",
            "'1234567'",
            "'87654321'"
        ],
        "boilerplate": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Text Justification",
        "source": "https://leetcode.com/problems/text-justification/",
        "description": "<p>Given an array of strings <code>words</code> and a width <code>maxWidth</code>, format the text such that each line has exactly <code>maxWidth</code> characters and is fully (left and right) justified.</p>\n\n<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces <code>&#39; &#39;</code> when necessary so that each line has exactly <code>maxWidth</code> characters.</p>\n\n<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>\n\n<p>For the last line of text, it should be left-justified, and no extra space is inserted between words.</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>A word is defined as a character sequence consisting of non-space characters only.</li>\n\t<li>Each word&#39;s length is guaranteed to be greater than <code>0</code> and not exceed <code>maxWidth</code>.</li>\n\t<li>The input array <code>words</code> contains at least one word.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;], maxWidth = 16\n<strong>Output:</strong>\n[\n&nbsp; &nbsp;&quot;This &nbsp; &nbsp;is &nbsp; &nbsp;an&quot;,\n&nbsp; &nbsp;&quot;example &nbsp;of text&quot;,\n&nbsp; &nbsp;&quot;justification. &nbsp;&quot;\n]</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;], maxWidth = 16\n<strong>Output:</strong>\n[\n&nbsp; &quot;What &nbsp; must &nbsp; be&quot;,\n&nbsp; &quot;acknowledgment &nbsp;&quot;,\n&nbsp; &quot;shall be &nbsp; &nbsp; &nbsp; &nbsp;&quot;\n]\n<strong>Explanation:</strong> Note that the last line is &quot;shall be    &quot; instead of &quot;shall     be&quot;, because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,&quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;], maxWidth = 20\n<strong>Output:</strong>\n[\n&nbsp; &quot;Science &nbsp;is &nbsp;what we&quot;,\n  &quot;understand &nbsp; &nbsp; &nbsp;well&quot;,\n&nbsp; &quot;enough to explain to&quot;,\n&nbsp; &quot;a &nbsp;computer. &nbsp;Art is&quot;,\n&nbsp; &quot;everything &nbsp;else &nbsp;we&quot;,\n&nbsp; &quot;do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;\n]</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li><code>words[i]</code> consists of only English letters and symbols.</li>\n\t<li><code>1 &lt;= maxWidth &lt;= 100</code></li>\n\t<li><code>words[i].length &lt;= maxWidth</code></li>\n</ul>\n",
        "difficulty": "hard",
        "sample_test_cases": [
            "fullJustify(['This', 'is', 'an', 'example', 'of', 'text', 'justification.'], 16)",
            "fullJustify(['What','must','be','acknowledgment','shall','be'], 16)",
            "fullJustify(['Science','is','what','we','understand','well','enough','to','explain','to','a','computer.','Art','is','everything','else','we','do'], 20)"
        ],
        "sample_test_results": [
            "['This    is    an', 'example  of text', 'justification.  ']",
            "['What   must   be', 'acknowledgment  ', 'shall be        ']",
            "['Science  is  what we', 'understand      well', 'enough to explain to', 'a  computer.  Art is', 'everything  else  we', 'do                  ']"
        ],
        "hidden_test_cases": [
            "fullJustify(['a'], 1)",
            "fullJustify(['a','b','c'], 1)",
            "fullJustify(['hello'], 10)",
            "fullJustify(['a','b','c','d'], 3)",
            "fullJustify(['This','is','a','test'], 4)",
            "fullJustify(['ab','cd','ef'], 10)",
            "fullJustify(['a','b'], 4)",
            "fullJustify(['word'], 5)",
            "fullJustify(['a','b','c','d','e'], 3)",
            "fullJustify(['Hello','World'], 12)"
        ],
        "hidden_test_results": [
            "['a']",
            "['a', 'b', 'c']",
            "['hello     ']",
            "['a b', 'c d']",
            "['This', 'is a', 'test']",
            "['ab cd ef  ']",
            "['a b ']",
            "['word ']",
            "['a b', 'c d', 'e  ']",
            "['Hello World ']"
        ],
        "boilerplate": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Minimum Window Substring",
        "source": "https://leetcode.com/problems/minimum-window-substring/",
        "description": "<p>Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return <em>the <strong>minimum window</strong></em> <span data-keyword=\"substring-nonempty\"><strong><em>substring</em></strong></span><em> of </em><code>s</code><em> such that every character in </em><code>t</code><em> (<strong>including duplicates</strong>) is included in the window</em>. If there is no such substring, return <em>the empty string </em><code>&quot;&quot;</code>.</p>\n\n<p>The testcases will be generated such that the answer is <strong>unique</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;\n<strong>Output:</strong> &quot;BANC&quot;\n<strong>Explanation:</strong> The minimum window substring &quot;BANC&quot; includes &#39;A&#39;, &#39;B&#39;, and &#39;C&#39; from string t.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;, t = &quot;a&quot;\n<strong>Output:</strong> &quot;a&quot;\n<strong>Explanation:</strong> The entire string s is the minimum window.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;, t = &quot;aa&quot;\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> Both &#39;a&#39;s from t must be included in the window.\nSince the largest window of s only has one &#39;a&#39;, return empty string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == s.length</code></li>\n\t<li><code>n == t.length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you find an algorithm that runs in <code>O(m + n)</code> time?</p>\n",
        "difficulty": "hard",
        "sample_test_cases": [
            "minWindow('ADOBECODEBANC', 'ABC')",
            "minWindow('a', 'a')",
            "minWindow('a', 'aa')"
        ],
        "sample_test_results": [
            "'BANC'",
            "'a'",
            "''"
        ],
        "hidden_test_cases": [
            "minWindow('a', 'b')",
            "minWindow('ab', 'a')",
            "minWindow('ABCDEFG', 'AC')",
            "minWindow('aaaaaaa', 'a')",
            "minWindow('ADOBECODEBANC', 'ABBC')",
            "minWindow('this is a test string', 'tist')",
            "minWindow('ADOBECODEBANC', 'ABCDE')",
            "minWindow('aaabbaaba', 'abb')",
            "minWindow('abc', 'cba')",
            "minWindow('bba', 'ab')"
        ],
        "hidden_test_results": [
            "''",
            "'a'",
            "'ABC'",
            "'a'",
            "'BECODEBA'",
            "'t stri'",
            "'ADOBEC'",
            "'abb'",
            "'abc'",
            "'ba'"
        ],
        "boilerplate": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Largest Rectangle in Histogram",
        "source": "https://leetcode.com/problems/largest-rectangle-in-histogram/",
        "description": "<p>Given an array of integers <code>heights</code> representing the histogram&#39;s bar height where the width of each bar is <code>1</code>, return <em>the area of the largest rectangle in the histogram</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg\" style=\"width: 522px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> heights = [2,1,5,6,2,3]\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg\" style=\"width: 202px; height: 362px;\" />\n<pre>\n<strong>Input:</strong> heights = [2,4]\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= heights.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= heights[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "difficulty": "hard",
        "sample_test_cases": [
            "largestRectangleArea([2,1,5,6,2,3])",
            "largestRectangleArea([2,4])"
        ],
        "sample_test_results": [
            "10",
            "4"
        ],
        "hidden_test_cases": [
            "largestRectangleArea([2,1,2])",
            "largestRectangleArea([1])",
            "largestRectangleArea([0])",
            "largestRectangleArea([1,1,1,1])",
            "largestRectangleArea([2,1,2,3,1])",
            "largestRectangleArea([5,4,3,2,1])",
            "largestRectangleArea([1,2,3,4,5])",
            "largestRectangleArea([2,2,2,2])",
            "largestRectangleArea([1,2,3,4,5,4,3,2,1])",
            "largestRectangleArea([0,0,0])"
        ],
        "hidden_test_results": [
            "3",
            "1",
            "0",
            "4",
            "5",
            "9",
            "9",
            "8",
            "15",
            "0"
        ],
        "boilerplate": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        ",
        "compare_func": "return int(result) == int(expected)"
    },
    {
        "title": "Maximal Rectangle",
        "source": "https://leetcode.com/problems/maximal-rectangle/",
        "description": "<p>Given a <code>rows x cols</code>&nbsp;binary <code>matrix</code> filled with <code>0</code>&#39;s and <code>1</code>&#39;s, find the largest rectangle containing only <code>1</code>&#39;s and return <em>its area</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg\" style=\"width: 402px; height: 322px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The maximal rectangle is shown in the above picture.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[&quot;0&quot;]]\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[&quot;1&quot;]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>rows == matrix.length</code></li>\n\t<li><code>cols == matrix[i].length</code></li>\n\t<li><code>1 &lt;= row, cols &lt;= 200</code></li>\n\t<li><code>matrix[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n",
        "difficulty": "hard",
        "sample_test_cases": [
            "maximalRectangle([[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]])",
            "maximalRectangle([[\"0\"]])",
            "maximalRectangle([[\"1\"]])"
        ],
        "sample_test_results": [
            "6",
            "0",
            "1"
        ],
        "hidden_test_cases": [
            "maximalRectangle([[\"1\",\"1\"],[\"1\",\"1\"]])",
            "maximalRectangle([[\"0\",\"0\"],[\"0\",\"0\"]])",
            "maximalRectangle([[\"1\"],[\"1\"]])",
            "maximalRectangle([[\"1\",\"0\"],[\"1\",\"0\"]])",
            "maximalRectangle([[\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\"]])",
            "maximalRectangle([[\"1\",\"0\",\"1\"],[\"0\",\"1\",\"0\"],[\"1\",\"0\",\"1\"]])",
            "maximalRectangle([[\"0\",\"1\"],[\"1\",\"0\"]])",
            "maximalRectangle([[\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\"],[\"1\",\"1\",\"1\"]])",
            "maximalRectangle([[\"1\"],[\"1\"],[\"1\"]])",
            "maximalRectangle([[\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\"]])"
        ],
        "hidden_test_results": [
            "4",
            "0",
            "2",
            "2",
            "9",
            "1",
            "1",
            "3",
            "3",
            "0"
        ],
        "boilerplate": "class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        ",
        "compare_func": "return int(result) == int(expected)"
    },
    {
        "title": "Scramble String",
        "source": "https://leetcode.com/problems/scramble-string/",
        "description": "<p>We can scramble a string s to get a string t using the following algorithm:</p>\n\n<ol>\n\t<li>If the length of the string is 1, stop.</li>\n\t<li>If the length of the string is &gt; 1, do the following:\n\t<ul>\n\t\t<li>Split the string into two non-empty substrings at a random index, i.e., if the string is <code>s</code>, divide it to <code>x</code> and <code>y</code> where <code>s = x + y</code>.</li>\n\t\t<li><strong>Randomly</strong>&nbsp;decide to swap the two substrings or to keep them in the same order. i.e., after this step, <code>s</code> may become <code>s = x + y</code> or <code>s = y + x</code>.</li>\n\t\t<li>Apply step 1 recursively on each of the two substrings <code>x</code> and <code>y</code>.</li>\n\t</ul>\n\t</li>\n</ol>\n\n<p>Given two strings <code>s1</code> and <code>s2</code> of <strong>the same length</strong>, return <code>true</code> if <code>s2</code> is a scrambled string of <code>s1</code>, otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> One possible scenario applied on s1 is:\n&quot;great&quot; --&gt; &quot;gr/eat&quot; // divide at random index.\n&quot;gr/eat&quot; --&gt; &quot;gr/eat&quot; // random decision is not to swap the two substrings and keep them in order.\n&quot;gr/eat&quot; --&gt; &quot;g/r / e/at&quot; // apply the same algorithm recursively on both substrings. divide at random index each of them.\n&quot;g/r / e/at&quot; --&gt; &quot;r/g / e/at&quot; // random decision was to swap the first substring and to keep the second substring in the same order.\n&quot;r/g / e/at&quot; --&gt; &quot;r/g / e/ a/t&quot; // again apply the algorithm recursively, divide &quot;at&quot; to &quot;a/t&quot;.\n&quot;r/g / e/ a/t&quot; --&gt; &quot;r/g / e/ a/t&quot; // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is &quot;rgeat&quot; which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;a&quot;, s2 = &quot;a&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>s1.length == s2.length</code></li>\n\t<li><code>1 &lt;= s1.length &lt;= 30</code></li>\n\t<li><code>s1</code> and <code>s2</code> consist of lowercase English letters.</li>\n</ul>\n",
        "difficulty": "hard",
        "sample_test_cases": [
            "isScramble(\"great\", \"rgeat\")",
            "isScramble(\"abcde\", \"caebd\")",
            "isScramble(\"a\", \"a\")"
        ],
        "sample_test_results": [
            "True",
            "False",
            "True"
        ],
        "hidden_test_cases": [
            "isScramble(\"ab\", \"ba\")",
            "isScramble(\"abc\", \"bac\")",
            "isScramble(\"abc\", \"cab\")",
            "isScramble(\"abb\", \"bba\")",
            "isScramble(\"aaab\", \"abaa\")",
            "isScramble(\"abcd\", \"bdac\")",
            "isScramble(\"abcde\", \"badce\")",
            "isScramble(\"abc\", \"acb\")",
            "isScramble(\"abcdbdacbdac\", \"bdacabcdbdac\")",
            "isScramble(\"xstjzkfpkggnhjzkpfjoguxvkbuopi\", \"xbouipkvxugojfpkzjhnggkpfzjts\")"
        ],
        "hidden_test_results": [
            "True",
            "True",
            "True",
            "True",
            "True",
            "False",
            "True",
            "True",
            "True",
            "False"
        ],
        "boilerplate": "class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        ",
        "compare_func": "return str(result).lower() == expected.lower()"
    },
    {
        "title": "Distinct Subsequences",
        "source": "https://leetcode.com/problems/distinct-subsequences/",
        "description": "<p>Given two strings s and t, return <i>the number of distinct</i> <b><i>subsequences</i></b><i> of </i>s<i> which equals </i>t.</p>\n\n<p>The test cases are generated so that the answer fits on a 32-bit signed integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\nAs shown below, there are 3 ways you can generate &quot;rabbit&quot; from s.\n<code><strong><u>rabb</u></strong>b<strong><u>it</u></strong></code>\n<code><strong><u>ra</u></strong>b<strong><u>bbit</u></strong></code>\n<code><strong><u>rab</u></strong>b<strong><u>bit</u></strong></code>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;babgbag&quot;, t = &quot;bag&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong>\nAs shown below, there are 5 ways you can generate &quot;bag&quot; from s.\n<code><strong><u>ba</u></strong>b<u><strong>g</strong></u>bag</code>\n<code><strong><u>ba</u></strong>bgba<strong><u>g</u></strong></code>\n<code><u><strong>b</strong></u>abgb<strong><u>ag</u></strong></code>\n<code>ba<u><strong>b</strong></u>gb<u><strong>ag</strong></u></code>\n<code>babg<strong><u>bag</u></strong></code></pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 1000</code></li>\n\t<li><code>s</code> and <code>t</code> consist of English letters.</li>\n</ul>\n",
        "difficulty": "hard",
        "sample_test_cases": [
            "numDistinct(\"rabbbit\", \"rabbit\")",
            "numDistinct(\"babgbag\", \"bag\")"
        ],
        "sample_test_results": [
            "3",
            "5"
        ],
        "hidden_test_cases": [
            "numDistinct(\"a\", \"a\")",
            "numDistinct(\"aa\", \"a\")",
            "numDistinct(\"aaa\", \"aa\")",
            "numDistinct(\"abc\", \"abc\")",
            "numDistinct(\"abcde\", \"ace\")",
            "numDistinct(\"aabb\", \"ab\")",
            "numDistinct(\"xslledayhxhadmctrliaxqpokyezcfhzaskeykchkmhpyjipxtsuljkwkovmvelvwxzwieeuqnjozrfwmzsylcwvsthnxujvrkszqwtglewkycikdaiocglwzukwovsghkhyidevhbgffoqkpabthmqihcfxxzdejletqjoxmwftlxfcxgxgvpperwbqvhxgsbbkmphyomtbjzdjhcrcsggleiczpbfjcgtpycpmrjnckslrwduqlccqmgrdhxolfjafmsrfdghnatexyanldrdpxvvgujsztuffoymrfteholgonuaqndinadtumnuhkboyzaqguwqijwxxszngextfcozpetyownmyneehdwqmtpjloztswmzzdzqhuoxrblppqvyvsqhnhryvqsqogpnlqfulurexdtovqpqkfxxnqykgscxaskmksivoazlducanrqxynxlgvwonalpsyddqmaemcrrwvrjmjjnygyebwtqxehrclwsxzylbqexnxjcgspeynlbmetlkacnnbhmaizbadynajpibepbuacggxrqavfnwpcwxbzxfymhjcslghmajrirqzjqxpgtgisfjreqrqabssobbadmtmdknmakdigjqyqcruujlwmfoagrckdwyiglviyyrekjealvvigiesnvuumxgsveadrxlpwetioxibtdjblowblqvzpbrmhupyrdophjxvhgzclidzybajuxllacyhyphssvhcffxonysahvzhzbttyeeyiefhunbokiqrpqfcoxdxvefugapeevdoakxwzykmhbdytjbhigffkmbqmqxsoaiomgmmgwapzdosorcxxhejvgajyzdmzlcntqbapbpofdjtulstuzdrffafedufqwsknumcxbschdybosxkrabyfdejgyozwillcxpcaiehlelczioskqtptzaczobvyojdlyflilvwqgyrqmjaeepydrcchfyftjighntqzoo\", \"rwmimatmhydhbujebqehjprarwfkoebcxxqfktayaaeheys\")",
            "numDistinct(\"aaaaaaaaaa\", \"aaaaaaa\")",
            "numDistinct(\"abcdef\", \"xyz\")",
            "numDistinct(\"wbyhqihmwwux\", \"byhwu\")"
        ],
        "hidden_test_results": [
            "1",
            "2",
            "3",
            "1",
            "1",
            "4",
            "1456742400",
            "120",
            "0",
            "4"
        ],
        "boilerplate": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        ",
        "compare_func": "return int(result) == int(expected)"
    },
    {
        "title": "Best Time to Buy and Sell Stock III",
        "source": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/",
        "description": "<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>\n\n<p>Find the maximum profit you can achieve. You may complete <strong>at most two transactions</strong>.</p>\n\n<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [3,3,5,0,0,3,1,4]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1,2,3,4,5]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,6,4,3,1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> In this case, no transaction is done, i.e. max profit = 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "difficulty": "hard",
        "sample_test_cases": [
            "maxProfit([3,3,5,0,0,3,1,4])",
            "maxProfit([1,2,3,4,5])",
            "maxProfit([7,6,4,3,1])"
        ],
        "sample_test_results": [
            "6",
            "4",
            "0"
        ],
        "hidden_test_cases": [
            "maxProfit([1])",
            "maxProfit([1,2])",
            "maxProfit([2,1])",
            "maxProfit([1,2,4,2,5,7,2,4,9,0])",
            "maxProfit([0,0,0,0])",
            "maxProfit([1,2,3,4,5,4,3,2,1])",
            "maxProfit([3,2,6,5,0,3])",
            "maxProfit([1,4,5,7,6,3,2,9])",
            "maxProfit([8,3,6,2,8,8,8,4,2,0,7,2,9,4,9])",
            "maxProfit([1,2,4,2,5,7,2,4,9,0,9])"
        ],
        "hidden_test_results": [
            "0",
            "1",
            "0",
            "13",
            "0",
            "4",
            "7",
            "13",
            "15",
            "17"
        ],
        "boilerplate": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        ",
        "compare_func": "return int(result) == int(expected)"
    },
    {
        "title": "Word Ladder",
        "source": "https://leetcode.com/problems/word-ladder/",
        "description": "<p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> such that:</p>\n\n<ul>\n\t<li>Every adjacent pair of words differs by a single letter.</li>\n\t<li>Every <code>s<sub>i</sub></code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>\n\t<li><code>s<sub>k</sub> == endWord</code></li>\n</ul>\n\n<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>the <strong>number of words</strong> in the <strong>shortest transformation sequence</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or </em><code>0</code><em> if no such sequence exists.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> One shortest transformation sequence is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; cog&quot;, which is 5 words long.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beginWord.length &lt;= 10</code></li>\n\t<li><code>endWord.length == beginWord.length</code></li>\n\t<li><code>1 &lt;= wordList.length &lt;= 5000</code></li>\n\t<li><code>wordList[i].length == beginWord.length</code></li>\n\t<li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li>\n\t<li><code>beginWord != endWord</code></li>\n\t<li>All the words in <code>wordList</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "difficulty": "hard",
        "sample_test_cases": [
            "ladderLength('hit', 'cog', ['hot','dot','dog','lot','log','cog'])",
            "ladderLength('hit', 'cog', ['hot','dot','dog','lot','log'])",
            "ladderLength('lost', 'cost', ['most','cost','lost'])"
        ],
        "sample_test_results": [
            "5",
            "0",
            "2"
        ],
        "hidden_test_cases": [
            "ladderLength('hit', 'dog', ['hot','dot','dog'])",
            "ladderLength('cat', 'rat', ['hat','rat','cat'])",
            "ladderLength('a', 'c', ['a','b','c'])",
            "ladderLength('red', 'tax', ['ted','tex','red','tax','tad'])",
            "ladderLength('log', 'dog', ['fog','fig','dig','dog','log'])",
            "ladderLength('abc', 'def', ['abf','acf','aef','def'])",
            "ladderLength('hot', 'dog', ['hot','dog'])",
            "ladderLength('hit', 'cog', [])",
            "ladderLength('cat', 'cat', ['cat'])",
            "ladderLength('hit', 'hat', ['hat','hot'])"
        ],
        "hidden_test_results": [
            "4",
            "2",
            "2",
            "4",
            "2",
            "4",
            "0",
            "0",
            "2",
            "2"
        ],
        "boilerplate": "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        ",
        "compare_func": "return str(result) == expected"
    },
    {
        "title": "Candy",
        "source": "https://leetcode.com/problems/candy/",
        "description": "<p>There are <code>n</code> children standing in a line. Each child is assigned a rating value given in the integer array <code>ratings</code>.</p>\n\n<p>You are giving candies to these children subjected to the following requirements:</p>\n\n<ul>\n\t<li>Each child must have at least one candy.</li>\n\t<li>Children with a higher rating get more candies than their neighbors.</li>\n</ul>\n\n<p>Return <em>the minimum number of candies you need to have to distribute the candies to the children</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> ratings = [1,0,2]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> ratings = [1,2,2]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == ratings.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= ratings[i] &lt;= 2 * 10<sup>4</sup></code></li>\n</ul>\n",
        "difficulty": "hard",
        "sample_test_cases": [
            "candy([1,0,2])",
            "candy([1,2,2])",
            "candy([1,3,2,2,1])"
        ],
        "sample_test_results": [
            "5",
            "4",
            "7"
        ],
        "hidden_test_cases": [
            "candy([1,2,3,4,5])",
            "candy([5,4,3,2,1])",
            "candy([1,1,1,1,1])",
            "candy([1,3,4,5,2])",
            "candy([1,2,87,87,87,2,1])",
            "candy([1,2,2,3,1,2])",
            "candy([0])",
            "candy([1,0,1,0,1])",
            "candy([2,0,1,0,2])",
            "candy([1,6,10,8,7,3,2])"
        ],
        "hidden_test_results": [
            "15",
            "15",
            "5",
            "11",
            "13",
            "9",
            "1",
            "8",
            "8",
            "18"
        ],
        "boilerplate": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        ",
        "compare_func": "return str(result) == expected"
    },
    {
        "title": "Word Break II",
        "source": "https://leetcode.com/problems/word-break-ii/",
        "description": "<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, add spaces in <code>s</code> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in <strong>any order</strong>.</p>\n\n<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsanddog&quot;, wordDict = [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]\n<strong>Output:</strong> [&quot;cats and dog&quot;,&quot;cat sand dog&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;pineapplepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]\n<strong>Output:</strong> [&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]\n<strong>Explanation:</strong> Note that you are allowed to reuse a dictionary word.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li>\n\t<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>\n\t<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>\n\t<li>Input is generated in a way that the length of the answer doesn&#39;t exceed&nbsp;10<sup>5</sup>.</li>\n</ul>\n",
        "difficulty": "hard",
        "sample_test_cases": [
            "wordBreak('catsanddog', ['cat','cats','and','sand','dog'])",
            "wordBreak('pineapplepenapple', ['apple','pen','applepen','pine','pineapple'])",
            "wordBreak('catsandog', ['cats','dog','sand','and','cat'])"
        ],
        "sample_test_results": [
            "['cat sand dog', 'cats and dog']",
            "['pine apple pen apple', 'pine applepen apple', 'pineapple pen apple']",
            "[]"
        ],
        "hidden_test_cases": [
            "wordBreak('leetcode', ['leet','code'])",
            "wordBreak('applepenapple', ['apple','pen'])",
            "wordBreak('a', ['a'])",
            "wordBreak('aaaa', ['a','aa','aaa'])",
            "wordBreak('cars', ['car','ca','rs'])",
            "wordBreak('bb', ['a','b','bbb'])",
            "wordBreak('catsanddogs', ['cats','cat','and','sand','dog','dogs'])",
            "wordBreak('ab', ['a','b'])",
            "wordBreak('impossible', ['imp','possible'])",
            "wordBreak('aaa', ['a','aa'])"
        ],
        "hidden_test_results": [
            "['leet code']",
            "['apple pen apple']",
            "['a']",
            "['a a a a', 'a a aa', 'a aa a', 'a aaa', 'aa a a', 'aa aa', 'aaa a']",
            "['ca rs']",
            "['b b']",
            "['cat sand dogs', 'cats and dogs']",
            "['a b']",
            "[]",
            "['a a a', 'a aa', 'aa a']"
        ],
        "boilerplate": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        ",
        "compare_func": "def normalize(s): return sorted([x.strip() for x in eval(s)])\n    return normalize(str(result)) == normalize(expected)"
    },
    {
        "title": "Find Minimum in Rotated Sorted Array II",
        "source": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/",
        "description": "<p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,4,4,5,6,7]</code> might become:</p>\n\n<ul>\n\t<li><code>[4,5,6,7,0,1,4]</code> if it was rotated <code>4</code> times.</li>\n\t<li><code>[0,1,4,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>\n</ul>\n\n<p>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>\n\n<p>Given the sorted rotated array <code>nums</code> that may contain <strong>duplicates</strong>, return <em>the minimum element of this array</em>.</p>\n\n<p>You must decrease the overall operation steps as much as possible.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,3,5]\n<strong>Output:</strong> 1\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [2,2,2,0,1]\n<strong>Output:</strong> 0\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>\n\t<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> This problem is similar to&nbsp;<a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/\" target=\"_blank\">Find Minimum in Rotated Sorted Array</a>, but&nbsp;<code>nums</code> may contain <strong>duplicates</strong>. Would this affect the runtime complexity? How and why?</p>\n\n<p>&nbsp;</p>\n",
        "difficulty": "hard",
        "sample_test_cases": [
            "findMin([1,3,5])",
            "findMin([2,2,2,0,1])",
            "findMin([3,1,3])"
        ],
        "sample_test_results": [
            "1",
            "0",
            "1"
        ],
        "hidden_test_cases": [
            "findMin([1,1,1,1,1])",
            "findMin([3,3,1,3])",
            "findMin([2,2,2,0,1,2])",
            "findMin([4,5,6,7,0,1,2])",
            "findMin([1,1,1,0,1])",
            "findMin([3,4,5,1,2])",
            "findMin([5,1,2,3,4])",
            "findMin([2,2,2,2,2,2])",
            "findMin([3,1,1,1,1])",
            "findMin([4,4,5,5,6,6,7,0])"
        ],
        "hidden_test_results": [
            "1",
            "1",
            "0",
            "0",
            "0",
            "1",
            "1",
            "2",
            "1",
            "0"
        ],
        "boilerplate": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        ",
        "compare_func": "return str(result) == expected"
    },
    {
        "title": "Best Time to Buy and Sell Stock IV",
        "source": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/",
        "description": "<p>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day, and an integer <code>k</code>.</p>\n\n<p>Find the maximum profit you can achieve. You may complete at most <code>k</code> transactions: i.e. you may buy at most <code>k</code> times and sell at most <code>k</code> times.</p>\n\n<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 2, prices = [2,4,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 2, prices = [3,2,6,5,0,3]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n\t<li><code>1 &lt;= prices.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>\n</ul>\n",
        "difficulty": "hard",
        "sample_test_cases": [
            "maxProfit(2, [2,4,1])",
            "maxProfit(2, [3,2,6,5,0,3])",
            "maxProfit(1, [1,2])"
        ],
        "sample_test_results": [
            "2",
            "7",
            "1"
        ],
        "hidden_test_cases": [
            "maxProfit(2, [1,2,4,2,5,7,2,4,9,0])",
            "maxProfit(1, [7,1,5,3,6,4])",
            "maxProfit(3, [3,3,5,0,0,3,1,4])",
            "maxProfit(4, [1,2,3,4,5])",
            "maxProfit(2, [1,4,5,7,6,3,2,1])",
            "maxProfit(3, [1])",
            "maxProfit(1, [7,6,5,4,3,2])",
            "maxProfit(2, [1,2,3,4,5,6])",
            "maxProfit(5, [3,2,6,5,0,3,1,4])",
            "maxProfit(2, [2,1,4,5,2,9,7])"
        ],
        "hidden_test_results": [
            "13",
            "5",
            "8",
            "4",
            "6",
            "0",
            "0",
            "5",
            "10",
            "11"
        ],
        "boilerplate": "class Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        ",
        "compare_func": "return str(result) == expected"
    },
    {
        "title": "The Skyline Problem",
        "source": "https://leetcode.com/problems/the-skyline-problem/",
        "description": "<p>A city&#39;s <strong>skyline</strong> is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return <em>the <strong>skyline</strong> formed by these buildings collectively</em>.</p>\n\n<p>The geometric information of each building is given in the array <code>buildings</code> where <code>buildings[i] = [left<sub>i</sub>, right<sub>i</sub>, height<sub>i</sub>]</code>:</p>\n\n<ul>\n\t<li><code>left<sub>i</sub></code> is the x coordinate of the left edge of the <code>i<sup>th</sup></code> building.</li>\n\t<li><code>right<sub>i</sub></code> is the x coordinate of the right edge of the <code>i<sup>th</sup></code> building.</li>\n\t<li><code>height<sub>i</sub></code> is the height of the <code>i<sup>th</sup></code> building.</li>\n</ul>\n\n<p>You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height <code>0</code>.</p>\n\n<p>The <strong>skyline</strong> should be represented as a list of &quot;key points&quot; <strong>sorted by their x-coordinate</strong> in the form <code>[[x<sub>1</sub>,y<sub>1</sub>],[x<sub>2</sub>,y<sub>2</sub>],...]</code>. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate <code>0</code> and is used to mark the skyline&#39;s termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline&#39;s contour.</p>\n\n<p><b>Note:</b> There must be no consecutive horizontal lines of equal height in the output skyline. For instance, <code>[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]</code> is not acceptable; the three lines of height 5 should be merged into one in the final output as such: <code>[...,[2 3],[4 5],[12 7],...]</code></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/merged.jpg\" style=\"width: 800px; height: 331px;\" />\n<pre>\n<strong>Input:</strong> buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\n<strong>Output:</strong> [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\n<strong>Explanation:</strong>\nFigure A shows the buildings of the input.\nFigure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> buildings = [[0,2,3],[2,5,3]]\n<strong>Output:</strong> [[0,3],[5,0]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= buildings.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= left<sub>i</sub> &lt; right<sub>i</sub> &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>1 &lt;= height<sub>i</sub> &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>buildings</code> is sorted by <code>left<sub>i</sub></code> in&nbsp;non-decreasing order.</li>\n</ul>\n",
        "difficulty": "hard",
        "sample_test_cases": [
            "getSkyline([[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]])",
            "getSkyline([[0,2,3],[2,5,3]])"
        ],
        "sample_test_results": [
            "[[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]]",
            "[[0, 3], [5, 0]]"
        ],
        "hidden_test_cases": [
            "getSkyline([[1,5,11],[2,7,6],[3,9,13],[12,16,7],[14,25,3],[19,22,18],[23,29,13],[24,28,4]])",
            "getSkyline([[1,2,1],[1,2,2],[1,2,3]])",
            "getSkyline([[1,10,10]])",
            "getSkyline([[1,5,3],[2,4,4]])",
            "getSkyline([[1,5,11],[2,3,13]])",
            "getSkyline([[0,3,3],[1,5,3],[2,4,3]])",
            "getSkyline([[2,4,70],[3,8,30],[6,100,41],[7,15,70],[10,30,102],[15,25,76],[60,80,91],[70,90,72],[85,120,59]])",
            "getSkyline([[1,20,1],[1,21,2],[1,22,3]])",
            "getSkyline([[0,5,7],[5,10,7],[5,10,12],[10,15,7],[15,20,7],[15,20,12],[20,25,7]])",
            "getSkyline([[1,2,1]])"
        ],
        "hidden_test_results": [
            "[[1, 11], [3, 13], [9, 0], [12, 7], [16, 3], [19, 18], [22, 3], [23, 13], [29, 0]]",
            "[[1, 3], [2, 0]]",
            "[[1, 10], [10, 0]]",
            "[[1, 3], [2, 4], [4, 3], [5, 0]]",
            "[[1, 11], [2, 13], [3, 11], [5, 0]]",
            "[[0, 3], [5, 0]]",
            "[[2, 70], [4, 30], [6, 41], [7, 70], [10, 102], [30, 41], [60, 91], [80, 72], [90, 59], [120, 0]]",
            "[[1, 3], [22, 0]]",
            "[[0, 7], [5, 12], [10, 7], [15, 12], [20, 7], [25, 0]]",
            "[[1, 1], [2, 0]]"
        ],
        "boilerplate": "class Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Basic Calculator",
        "source": "https://leetcode.com/problems/basic-calculator/",
        "description": "<p>Given a string <code>s</code> representing a valid expression, implement a basic calculator to evaluate it, and return <em>the result of the evaluation</em>.</p>\n\n<p><strong>Note:</strong> You are <strong>not</strong> allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;1 + 1&quot;\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot; 2-1 + 2 &quot;\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(1+(4+5+2)-3)+(6+8)&quot;\n<strong>Output:</strong> 23\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of digits, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, and <code>&#39; &#39;</code>.</li>\n\t<li><code>s</code> represents a valid expression.</li>\n\t<li><code>&#39;+&#39;</code> is <strong>not</strong> used as a unary operation (i.e., <code>&quot;+1&quot;</code> and <code>&quot;+(2 + 3)&quot;</code> is invalid).</li>\n\t<li><code>&#39;-&#39;</code> could be used as a unary operation (i.e., <code>&quot;-1&quot;</code> and <code>&quot;-(2 + 3)&quot;</code> is valid).</li>\n\t<li>There will be no two consecutive operators in the input.</li>\n\t<li>Every number and running calculation will fit in a signed 32-bit integer.</li>\n</ul>\n",
        "difficulty": "hard",
        "sample_test_cases": [
            "calculate(\"1 + 1\")",
            "calculate(\" 2-1 + 2 \")",
            "calculate(\"(1+(4+5+2)-3)+(6+8)\")"
        ],
        "sample_test_results": [
            "2",
            "3",
            "23"
        ],
        "hidden_test_cases": [
            "calculate(\"2147483647\")",
            "calculate(\"1 + (2 + 3)\")",
            "calculate(\"-(2 + 3)\")",
            "calculate(\"(1+(4+5+2)-3)+(6+8)\")",
            "calculate(\"2-4-(8+2-6+(8+4-(1)+8-10))\")",
            "calculate(\"(5-(1+(5)))\")",
            "calculate(\"(-2)+3\")",
            "calculate(\"1-(-2)\")",
            "calculate(\"1+2-3+(4+5-6)\")",
            "calculate(\"(7)-(0)+(4)\")"
        ],
        "hidden_test_results": [
            "2147483647",
            "6",
            "-5",
            "23",
            "-15",
            "-1",
            "1",
            "3",
            "3",
            "11"
        ],
        "boilerplate": "class Solution:\n    def calculate(self, s: str) -> int:\n        ",
        "compare_func": "return int(result) == int(expected)"
    },
    {
        "title": "Sliding Window Maximum",
        "source": "https://leetcode.com/problems/sliding-window-maximum/",
        "description": "<p>You are given an array of integers&nbsp;<code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>\n\n<p>Return <em>the max sliding window</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,-1,-3,5,3,6,7], k = 3\n<strong>Output:</strong> [3,3,5,5,6,7]\n<strong>Explanation:</strong> \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       <strong>3</strong>\n 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>\n 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>\n 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>\n 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>\n 1  3  -1  -3  5 [3  6  7]      <strong>7</strong>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1], k = 1\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "difficulty": "hard",
        "sample_test_cases": [
            "maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3)",
            "maxSlidingWindow([1], 1)"
        ],
        "sample_test_results": [
            "[3, 3, 5, 5, 6, 7]",
            "[1]"
        ],
        "hidden_test_cases": [
            "maxSlidingWindow([1,3,1,2,0,5], 3)",
            "maxSlidingWindow([7,2,4], 2)",
            "maxSlidingWindow([1,-1], 1)",
            "maxSlidingWindow([1,2,3,4,5], 5)",
            "maxSlidingWindow([1,2,3,4,5,6], 1)",
            "maxSlidingWindow([-7,-8,7,5,7,1,6,0], 4)",
            "maxSlidingWindow([1,1,1,1], 2)",
            "maxSlidingWindow([4,2,0,-1,3,5], 3)",
            "maxSlidingWindow([-1,-2,-3,-4], 2)",
            "maxSlidingWindow([1,2,3,2,1], 3)"
        ],
        "hidden_test_results": [
            "[3, 3, 2, 5]",
            "[7, 4]",
            "[1, -1]",
            "[5]",
            "[1, 2, 3, 4, 5, 6]",
            "[7, 7, 7, 7, 7]",
            "[1, 1, 1]",
            "[4, 2, 3, 5]",
            "[-1, -2, -3]",
            "[3, 3, 3]"
        ],
        "boilerplate": "class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        ",
        "compare_func": "return result == eval(expected)"
    },
    {
        "title": "Expression Add Operators",
        "source": "https://leetcode.com/problems/expression-add-operators/",
        "description": "<p>Given a string <code>num</code> that contains only digits and an integer <code>target</code>, return <em><strong>all possibilities</strong> to insert the binary operators </em><code>&#39;+&#39;</code><em>, </em><code>&#39;-&#39;</code><em>, and/or </em><code>&#39;*&#39;</code><em> between the digits of </em><code>num</code><em> so that the resultant expression evaluates to the </em><code>target</code><em> value</em>.</p>\n\n<p>Note that operands in the returned expressions <strong>should not</strong> contain leading zeros.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;123&quot;, target = 6\n<strong>Output:</strong> [&quot;1*2*3&quot;,&quot;1+2+3&quot;]\n<strong>Explanation:</strong> Both &quot;1*2*3&quot; and &quot;1+2+3&quot; evaluate to 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;232&quot;, target = 8\n<strong>Output:</strong> [&quot;2*3+2&quot;,&quot;2+3*2&quot;]\n<strong>Explanation:</strong> Both &quot;2*3+2&quot; and &quot;2+3*2&quot; evaluate to 8.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;3456237490&quot;, target = 9191\n<strong>Output:</strong> []\n<strong>Explanation:</strong> There are no expressions that can be created from &quot;3456237490&quot; to evaluate to 9191.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10</code></li>\n\t<li><code>num</code> consists of only digits.</li>\n\t<li><code>-2<sup>31</sup> &lt;= target &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "difficulty": "hard",
        "sample_test_cases": [
            "addOperators(\"123\", 6)",
            "addOperators(\"232\", 8)",
            "addOperators(\"3456237490\", 9191)"
        ],
        "sample_test_results": [
            "['1+2+3', '1*2*3']",
            "['2+3*2', '2*3+2']",
            "[]"
        ],
        "hidden_test_cases": [
            "addOperators(\"123\", 6)",
            "addOperators(\"232\", 8)",
            "addOperators(\"105\", 5)",
            "addOperators(\"00\", 0)",
            "addOperators(\"3456237490\", 9191)",
            "addOperators(\"1000000009\", 9)",
            "addOperators(\"2147483648\", -2147483648)",
            "addOperators(\"999999999\", 999999999)",
            "addOperators(\"01\", 1)",
            "addOperators(\"1234\", 11)"
        ],
        "hidden_test_results": [
            "['1+2+3', '1*2*3']",
            "['2+3*2', '2*3+2']",
            "['1*0+5', '10-5']",
            "['0+0', '0-0', '0*0']",
            "[]",
            "['1*0+0+0+0+0+0+0+0+9', '1*0+0+0+0+0+0+0-0+9', '1*0+0+0+0+0+0+0*0+9', '1*0+0+0+0+0+0-0+0+9', '1*0+0+0+0+0+0-0-0+9', '1*0+0+0+0+0+0-0*0+9', '1*0+0+0+0+0+0*0+0+9', '1*0+0+0+0+0+0*0-0+9', '1*0+0+0+0+0+0*0*0+9', '1*0+0+0+0+0-0+0+0+9', '1*0+0+0+0+0-0+0-0+9', '1*0+0+0+0+0-0+0*0+9', '1*0+0+0+0+0-0-0+0+9', '1*0+0+0+0+0-0-0-0+9', '1*0+0+0+0+0-0-0*0+9', '1*0+0+0+0+0-0*0+0+9', '1*0+0+0+0+0-0*0-0+9', '1*0+0+0+0+0-0*0*0+9', '1*0+0+0+0+0*0+0+0+9', '1*0+0+0+0+0*0+0-0+9', '1*0+0+0+0+0*0+0*0+9', '1*0+0+0+0+0*0-0+0+9', '1*0+0+0+0+0*0-0-0+9', '1*0+0+0+0+0*0-0*0+9', '1*0+0+0+0+0*0*0+0+9', '1*0+0+0+0+0*0*0-0+9', '1*0+0+0+0+0*0*0*0+9', '1*0+0+0+0-0+0+0+0+9', '1*0+0+0+0-0+0+0-0+9', '1*0+0+0+0-0+0+0*0+9', '1*0+0+0+0-0+0-0+0+9', '1*0+0+0+0-0+0-0-0+9', '1*0+0+0+0-0+0-0*0+9', '1*0+0+0+0-0+0*0+0+9', '1*0+0+0+0-0+0*0-0+9', '1*0+0+0+0-0+0*0*0+9', '1*0+0+0+0-0-0+0+0+9', '1*0+0+0+0-0-0+0-0+9', '1*0+0+0+0-0-0+0*0+9', '1*0+0+0+0-0-0-0+0+9', '1*0+0+0+0-0-0-0-0+9', '1*0+0+0+0-0-0-0*0+9', '1*0+0+0+0-0-0*0+0+9', '1*0+0+0+0-0-0*0-0+9', '1*0+0+0+0-0-0*0*0+9', '1*0+0+0+0-0*0+0+0+9', '1*0+0+0+0-0*0+0-0+9', '1*0+0+0+0-0*0+0*0+9', '1*0+0+0+0-0*0-0+0+9', '1*0+0+0+0-0*0-0-0+9', '1*0+0+0+0-0*0-0*0+9', '1*0+0+0+0-0*0*0+0+9', '1*0+0+0+0-0*0*0-0+9', '1*0+0+0+0-0*0*0*0+9', '1*0+0+0+0*0+0+0+0+9', '1*0+0+0+0*0+0+0-0+9', '1*0+0+0+0*0+0+0*0+9', '1*0+0+0+0*0+0-0+0+9', '1*0+0+0+0*0+0-0-0+9', '1*0+0+0+0*0+0-0*0+9', '1*0+0+0+0*0+0*0+0+9', '1*0+0+0+0*0+0*0-0+9', '1*0+0+0+0*0+0*0*0+9', '1*0+0+0+0*0-0+0+0+9', '1*0+0+0+0*0-0+0-0+9', '1*0+0+0+0*0-0+0*0+9', '1*0+0+0+0*0-0-0+0+9', '1*0+0+0+0*0-0-0-0+9', '1*0+0+0+0*0-0-0*0+9', '1*0+0+0+0*0-0*0+0+9', '1*0+0+0+0*0-0*0-0+9', '1*0+0+0+0*0-0*0*0+9', '1*0+0+0+0*0*0+0+0+9', '1*0+0+0+0*0*0+0-0+9', '1*0+0+0+0*0*0+0*0+9', '1*0+0+0+0*0*0-0+0+9', '1*0+0+0+0*0*0-0-0+9', '1*0+0+0+0*0*0-0*0+9', '1*0+0+0+0*0*0*0+0+9', '1*0+0+0+0*0*0*0-0+9', '1*0+0+0+0*0*0*0*0+9', '1*0+0+0-0+0+0+0+0+9', '1*0+0+0-0+0+0+0-0+9', '1*0+0+0-0+0+0+0*0+9', '1*0+0+0-0+0+0-0+0+9', '1*0+0+0-0+0+0-0-0+9', '1*0+0+0-0+0+0-0*0+9', '1*0+0+0-0+0+0*0+0+9', '1*0+0+0-0+0+0*0-0+9', '1*0+0+0-0+0+0*0*0+9', '1*0+0+0-0+0-0+0+0+9', '1*0+0+0-0+0-0+0-0+9', '1*0+0+0-0+0-0+0*0+9', '1*0+0+0-0+0-0-0+0+9', '1*0+0+0-0+0-0-0-0+9', '1*0+0+0-0+0-0-0*0+9', '1*0+0+0-0+0-0*0+0+9', '1*0+0+0-0+0-0*0-0+9', '1*0+0+0-0+0-0*0*0+9', '1*0+0+0-0+0*0+0+0+9', '1*0+0+0-0+0*0+0-0+9', '1*0+0+0-0+0*0+0*0+9', '1*0+0+0-0+0*0-0+0+9', '1*0+0+0-0+0*0-0-0+9', '1*0+0+0-0+0*0-0*0+9', '1*0+0+0-0+0*0*0+0+9', '1*0+0+0-0+0*0*0-0+9', '1*0+0+0-0+0*0*0*0+9', '1*0+0+0-0-0+0+0+0+9', '1*0+0+0-0-0+0+0-0+9', '1*0+0+0-0-0+0+0*0+9', '1*0+0+0-0-0+0-0+0+9', '1*0+0+0-0-0+0-0-0+9', '1*0+0+0-0-0+0-0*0+9', '1*0+0+0-0-0+0*0+0+9', '1*0+0+0-0-0+0*0-0+9', '1*0+0+0-0-0+0*0*0+9', '1*0+0+0-0-0-0+0+0+9', '1*0+0+0-0-0-0+0-0+9', '1*0+0+0-0-0-0+0*0+9', '1*0+0+0-0-0-0-0+0+9', '1*0+0+0-0-0-0-0-0+9', '1*0+0+0-0-0-0-0*0+9', '1*0+0+0-0-0-0*0+0+9', '1*0+0+0-0-0-0*0-0+9', '1*0+0+0-0-0-0*0*0+9', '1*0+0+0-0-0*0+0+0+9', '1*0+0+0-0-0*0+0-0+9', '1*0+0+0-0-0*0+0*0+9', '1*0+0+0-0-0*0-0+0+9', '1*0+0+0-0-0*0-0-0+9', '1*0+0+0-0-0*0-0*0+9', '1*0+0+0-0-0*0*0+0+9', '1*0+0+0-0-0*0*0-0+9', '1*0+0+0-0-0*0*0*0+9', '1*0+0+0-0*0+0+0+0+9', '1*0+0+0-0*0+0+0-0+9', '1*0+0+0-0*0+0+0*0+9', '1*0+0+0-0*0+0-0+0+9', '1*0+0+0-0*0+0-0-0+9', '1*0+0+0-0*0+0-0*0+9', '1*0+0+0-0*0+0*0+0+9', '1*0+0+0-0*0+0*0-0+9', '1*0+0+0-0*0+0*0*0+9', '1*0+0+0-0*0-0+0+0+9', '1*0+0+0-0*0-0+0-0+9', '1*0+0+0-0*0-0+0*0+9', '1*0+0+0-0*0-0-0+0+9', '1*0+0+0-0*0-0-0-0+9', '1*0+0+0-0*0-0-0*0+9', '1*0+0+0-0*0-0*0+0+9', '1*0+0+0-0*0-0*0-0+9', '1*0+0+0-0*0-0*0*0+9', '1*0+0+0-0*0*0+0+0+9', '1*0+0+0-0*0*0+0-0+9', '1*0+0+0-0*0*0+0*0+9', '1*0+0+0-0*0*0-0+0+9', '1*0+0+0-0*0*0-0-0+9', '1*0+0+0-0*0*0-0*0+9', '1*0+0+0-0*0*0*0+0+9', '1*0+0+0-0*0*0*0-0+9', '1*0+0+0-0*0*0*0*0+9', '1*0+0+0*0+0+0+0+0+9', '1*0+0+0*0+0+0+0-0+9', '1*0+0+0*0+0+0+0*0+9', '1*0+0+0*0+0+0-0+0+9', '1*0+0+0*0+0+0-0-0+9', '1*0+0+0*0+0+0-0*0+9', '1*0+0+0*0+0+0*0+0+9', '1*0+0+0*0+0+0*0-0+9', '1*0+0+0*0+0+0*0*0+9', '1*0+0+0*0+0-0+0+0+9', '1*0+0+0*0+0-0+0-0+9', '1*0+0+0*0+0-0+0*0+9', '1*0+0+0*0+0-0-0+0+9', '1*0+0+0*0+0-0-0-0+9', '1*0+0+0*0+0-0-0*0+9', '1*0+0+0*0+0-0*0+0+9', '1*0+0+0*0+0-0*0-0+9', '1*0+0+0*0+0-0*0*0+9', '1*0+0+0*0+0*0+0+0+9', '1*0+0+0*0+0*0+0-0+9', '1*0+0+0*0+0*0+0*0+9', '1*0+0+0*0+0*0-0+0+9', '1*0+0+0*0+0*0-0-0+9', '1*0+0+0*0+0*0-0*0+9', '1*0+0+0*0+0*0*0+0+9', '1*0+0+0*0+0*0*0-0+9', '1*0+0+0*0+0*0*0*0+9', '1*0+0+0*0-0+0+0+0+9', '1*0+0+0*0-0+0+0-0+9', '1*0+0+0*0-0+0+0*0+9', '1*0+0+0*0-0+0-0+0+9', '1*0+0+0*0-0+0-0-0+9', '1*0+0+0*0-0+0-0*0+9', '1*0+0+0*0-0+0*0+0+9', '1*0+0+0*0-0+0*0-0+9', '1*0+0+0*0-0+0*0*0+9', '1*0+0+0*0-0-0+0+0+9', '1*0+0+0*0-0-0+0-0+9', '1*0+0+0*0-0-0+0*0+9', '1*0+0+0*0-0-0-0+0+9', '1*0+0+0*0-0-0-0-0+9', '1*0+0+0*0-0-0-0*0+9', '1*0+0+0*0-0-0*0+0+9', '1*0+0+0*0-0-0*0-0+9', '1*0+0+0*0-0-0*0*0+9', '1*0+0+0*0-0*0+0+0+9', '1*0+0+0*0-0*0+0-0+9', '1*0+0+0*0-0*0+0*0+9', '1*0+0+0*0-0*0-0+0+9', '1*0+0+0*0-0*0-0-0+9', '1*0+0+0*0-0*0-0*0+9', '1*0+0+0*0-0*0*0+0+9', '1*0+0+0*0-0*0*0-0+9', '1*0+0+0*0-0*0*0*0+9', '1*0+0+0*0*0+0+0+0+9', '1*0+0+0*0*0+0+0-0+9', '1*0+0+0*0*0+0+0*0+9', '1*0+0+0*0*0+0-0+0+9', '1*0+0+0*0*0+0-0-0+9', '1*0+0+0*0*0+0-0*0+9', '1*0+0+0*0*0+0*0+0+9', '1*0+0+0*0*0+0*0-0+9', '1*0+0+0*0*0+0*0*0+9', '1*0+0+0*0*0-0+0+0+9', '1*0+0+0*0*0-0+0-0+9', '1*0+0+0*0*0-0+0*0+9', '1*0+0+0*0*0-0-0+0+9', '1*0+0+0*0*0-0-0-0+9', '1*0+0+0*0*0-0-0*0+9', '1*0+0+0*0*0-0*0+0+9', '1*0+0+0*0*0-0*0-0+9', '1*0+0+0*0*0-0*0*0+9', '1*0+0+0*0*0*0+0+0+9', '1*0+0+0*0*0*0+0-0+9', '1*0+0+0*0*0*0+0*0+9', '1*0+0+0*0*0*0-0+0+9', '1*0+0+0*0*0*0-0-0+9', '1*0+0+0*0*0*0-0*0+9', '1*0+0+0*0*0*0*0+0+9', '1*0+0+0*0*0*0*0-0+9', '1*0+0+0*0*0*0*0*0+9', '1*0+0-0+0+0+0+0+0+9', '1*0+0-0+0+0+0+0-0+9', '1*0+0-0+0+0+0+0*0+9', '1*0+0-0+0+0+0-0+0+9', '1*0+0-0+0+0+0-0-0+9', '1*0+0-0+0+0+0-0*0+9', '1*0+0-0+0+0+0*0+0+9', '1*0+0-0+0+0+0*0-0+9', '1*0+0-0+0+0+0*0*0+9', '1*0+0-0+0+0-0+0+0+9', '1*0+0-0+0+0-0+0-0+9', '1*0+0-0+0+0-0+0*0+9', '1*0+0-0+0+0-0-0+0+9', '1*0+0-0+0+0-0-0-0+9', '1*0+0-0+0+0-0-0*0+9', '1*0+0-0+0+0-0*0+0+9', '1*0+0-0+0+0-0*0-0+9', '1*0+0-0+0+0-0*0*0+9', '1*0+0-0+0+0*0+0+0+9', '1*0+0-0+0+0*0+0-0+9', '1*0+0-0+0+0*0+0*0+9', '1*0+0-0+0+0*0-0+0+9', '1*0+0-0+0+0*0-0-0+9', '1*0+0-0+0+0*0-0*0+9', '1*0+0-0+0+0*0*0+0+9', '1*0+0-0+0+0*0*0-0+9', '1*0+0-0+0+0*0*0*0+9', '1*0+0-0+0-0+0+0+0+9', '1*0+0-0+0-0+0+0-0+9', '1*0+0-0+0-0+0+0*0+9', '1*0+0-0+0-0+0-0+0+9', '1*0+0-0+0-0+0-0-0+9', '1*0+0-0+0-0+0-0*0+9', '1*0+0-0+0-0+0*0+0+9', '1*0+0-0+0-0+0*0-0+9', '1*0+0-0+0-0+0*0*0+9', '1*0+0-0+0-0-0+0+0+9', '1*0+0-0+0-0-0+0-0+9', '1*0+0-0+0-0-0+0*0+9', '1*0+0-0+0-0-0-0+0+9', '1*0+0-0+0-0-0-0-0+9', '1*0+0-0+0-0-0-0*0+9', '1*0+0-0+0-0-0*0+0+9', '1*0+0-0+0-0-0*0-0+9', '1*0+0-0+0-0-0*0*0+9', '1*0+0-0+0-0*0+0+0+9', '1*0+0-0+0-0*0+0-0+9', '1*0+0-0+0-0*0+0*0+9', '1*0+0-0+0-0*0-0+0+9', '1*0+0-0+0-0*0-0-0+9', '1*0+0-0+0-0*0-0*0+9', '1*0+0-0+0-0*0*0+0+9', '1*0+0-0+0-0*0*0-0+9', '1*0+0-0+0-0*0*0*0+9', '1*0+0-0+0*0+0+0+0+9', '1*0+0-0+0*0+0+0-0+9', '1*0+0-0+0*0+0+0*0+9', '1*0+0-0+0*0+0-0+0+9', '1*0+0-0+0*0+0-0-0+9', '1*0+0-0+0*0+0-0*0+9', '1*0+0-0+0*0+0*0+0+9', '1*0+0-0+0*0+0*0-0+9', '1*0+0-0+0*0+0*0*0+9', '1*0+0-0+0*0-0+0+0+9', '1*0+0-0+0*0-0+0-0+9', '1*0+0-0+0*0-0+0*0+9', '1*0+0-0+0*0-0-0+0+9', '1*0+0-0+0*0-0-0-0+9', '1*0+0-0+0*0-0-0*0+9', '1*0+0-0+0*0-0*0+0+9', '1*0+0-0+0*0-0*0-0+9', '1*0+0-0+0*0-0*0*0+9', '1*0+0-0+0*0*0+0+0+9', '1*0+0-0+0*0*0+0-0+9', '1*0+0-0+0*0*0+0*0+9', '1*0+0-0+0*0*0-0+0+9', '1*0+0-0+0*0*0-0-0+9', '1*0+0-0+0*0*0-0*0+9', '1*0+0-0+0*0*0*0+0+9', '1*0+0-0+0*0*0*0-0+9', '1*0+0-0+0*0*0*0*0+9', '1*0+0-0-0+0+0+0+0+9', '1*0+0-0-0+0+0+0-0+9', '1*0+0-0-0+0+0+0*0+9', '1*0+0-0-0+0+0-0+0+9', '1*0+0-0-0+0+0-0-0+9', '1*0+0-0-0+0+0-0*0+9', '1*0+0-0-0+0+0*0+0+9', '1*0+0-0-0+0+0*0-0+9', '1*0+0-0-0+0+0*0*0+9', '1*0+0-0-0+0-0+0+0+9', '1*0+0-0-0+0-0+0-0+9', '1*0+0-0-0+0-0+0*0+9', '1*0+0-0-0+0-0-0+0+9', '1*0+0-0-0+0-0-0-0+9', '1*0+0-0-0+0-0-0*0+9', '1*0+0-0-0+0-0*0+0+9', '1*0+0-0-0+0-0*0-0+9', '1*0+0-0-0+0-0*0*0+9', '1*0+0-0-0+0*0+0+0+9', '1*0+0-0-0+0*0+0-0+9', '1*0+0-0-0+0*0+0*0+9', '1*0+0-0-0+0*0-0+0+9', '1*0+0-0-0+0*0-0-0+9', '1*0+0-0-0+0*0-0*0+9', '1*0+0-0-0+0*0*0+0+9', '1*0+0-0-0+0*0*0-0+9', '1*0+0-0-0+0*0*0*0+9', '1*0+0-0-0-0+0+0+0+9', '1*0+0-0-0-0+0+0-0+9', '1*0+0-0-0-0+0+0*0+9', '1*0+0-0-0-0+0-0+0+9', '1*0+0-0-0-0+0-0-0+9', '1*0+0-0-0-0+0-0*0+9', '1*0+0-0-0-0+0*0+0+9', '1*0+0-0-0-0+0*0-0+9', '1*0+0-0-0-0+0*0*0+9', '1*0+0-0-0-0-0+0+0+9', '1*0+0-0-0-0-0+0-0+9', '1*0+0-0-0-0-0+0*0+9', '1*0+0-0-0-0-0-0+0+9', '1*0+0-0-0-0-0-0-0+9', '1*0+0-0-0-0-0-0*0+9', '1*0+0-0-0-0-0*0+0+9', '1*0+0-0-0-0-0*0-0+9', '1*0+0-0-0-0-0*0*0+9', '1*0+0-0-0-0*0+0+0+9', '1*0+0-0-0-0*0+0-0+9', '1*0+0-0-0-0*0+0*0+9', '1*0+0-0-0-0*0-0+0+9', '1*0+0-0-0-0*0-0-0+9', '1*0+0-0-0-0*0-0*0+9', '1*0+0-0-0-0*0*0+0+9', '1*0+0-0-0-0*0*0-0+9', '1*0+0-0-0-0*0*0*0+9', '1*0+0-0-0*0+0+0+0+9', '1*0+0-0-0*0+0+0-0+9', '1*0+0-0-0*0+0+0*0+9', '1*0+0-0-0*0+0-0+0+9', '1*0+0-0-0*0+0-0-0+9', '1*0+0-0-0*0+0-0*0+9', '1*0+0-0-0*0+0*0+0+9', '1*0+0-0-0*0+0*0-0+9', '1*0+0-0-0*0+0*0*0+9', '1*0+0-0-0*0-0+0+0+9', '1*0+0-0-0*0-0+0-0+9', '1*0+0-0-0*0-0+0*0+9', '1*0+0-0-0*0-0-0+0+9', '1*0+0-0-0*0-0-0-0+9', '1*0+0-0-0*0-0-0*0+9', '1*0+0-0-0*0-0*0+0+9', '1*0+0-0-0*0-0*0-0+9', '1*0+0-0-0*0-0*0*0+9', '1*0+0-0-0*0*0+0+0+9', '1*0+0-0-0*0*0+0-0+9', '1*0+0-0-0*0*0+0*0+9', '1*0+0-0-0*0*0-0+0+9', '1*0+0-0-0*0*0-0-0+9', '1*0+0-0-0*0*0-0*0+9', '1*0+0-0-0*0*0*0+0+9', '1*0+0-0-0*0*0*0-0+9', '1*0+0-0-0*0*0*0*0+9', '1*0+0-0*0+0+0+0+0+9', '1*0+0-0*0+0+0+0-0+9', '1*0+0-0*0+0+0+0*0+9', '1*0+0-0*0+0+0-0+0+9', '1*0+0-0*0+0+0-0-0+9', '1*0+0-0*0+0+0-0*0+9', '1*0+0-0*0+0+0*0+0+9', '1*0+0-0*0+0+0*0-0+9', '1*0+0-0*0+0+0*0*0+9', '1*0+0-0*0+0-0+0+0+9', '1*0+0-0*0+0-0+0-0+9', '1*0+0-0*0+0-0+0*0+9', '1*0+0-0*0+0-0-0+0+9', '1*0+0-0*0+0-0-0-0+9', '1*0+0-0*0+0-0-0*0+9', '1*0+0-0*0+0-0*0+0+9', '1*0+0-0*0+0-0*0-0+9', '1*0+0-0*0+0-0*0*0+9', '1*0+0-0*0+0*0+0+0+9', '1*0+0-0*0+0*0+0-0+9', '1*0+0-0*0+0*0+0*0+9', '1*0+0-0*0+0*0-0+0+9', '1*0+0-0*0+0*0-0-0+9', '1*0+0-0*0+0*0-0*0+9', '1*0+0-0*0+0*0*0+0+9', '1*0+0-0*0+0*0*0-0+9', '1*0+0-0*0+0*0*0*0+9', '1*0+0-0*0-0+0+0+0+9', '1*0+0-0*0-0+0+0-0+9', '1*0+0-0*0-0+0+0*0+9', '1*0+0-0*0-0+0-0+0+9', '1*0+0-0*0-0+0-0-0+9', '1*0+0-0*0-0+0-0*0+9', '1*0+0-0*0-0+0*0+0+9', '1*0+0-0*0-0+0*0-0+9', '1*0+0-0*0-0+0*0*0+9', '1*0+0-0*0-0-0+0+0+9', '1*0+0-0*0-0-0+0-0+9', '1*0+0-0*0-0-0+0*0+9', '1*0+0-0*0-0-0-0+0+9', '1*0+0-0*0-0-0-0-0+9', '1*0+0-0*0-0-0-0*0+9', '1*0+0-0*0-0-0*0+0+9', '1*0+0-0*0-0-0*0-0+9', '1*0+0-0*0-0-0*0*0+9', '1*0+0-0*0-0*0+0+0+9', '1*0+0-0*0-0*0+0-0+9', '1*0+0-0*0-0*0+0*0+9', '1*0+0-0*0-0*0-0+0+9', '1*0+0-0*0-0*0-0-0+9', '1*0+0-0*0-0*0-0*0+9', '1*0+0-0*0-0*0*0+0+9', '1*0+0-0*0-0*0*0-0+9', '1*0+0-0*0-0*0*0*0+9', '1*0+0-0*0*0+0+0+0+9', '1*0+0-0*0*0+0+0-0+9', '1*0+0-0*0*0+0+0*0+9', '1*0+0-0*0*0+0-0+0+9', '1*0+0-0*0*0+0-0-0+9', '1*0+0-0*0*0+0-0*0+9', '1*0+0-0*0*0+0*0+0+9', '1*0+0-0*0*0+0*0-0+9', '1*0+0-0*0*0+0*0*0+9', '1*0+0-0*0*0-0+0+0+9', '1*0+0-0*0*0-0+0-0+9', '1*0+0-0*0*0-0+0*0+9', '1*0+0-0*0*0-0-0+0+9', '1*0+0-0*0*0-0-0-0+9', '1*0+0-0*0*0-0-0*0+9', '1*0+0-0*0*0-0*0+0+9', '1*0+0-0*0*0-0*0-0+9', '1*0+0-0*0*0-0*0*0+9', '1*0+0-0*0*0*0+0+0+9', '1*0+0-0*0*0*0+0-0+9', '1*0+0-0*0*0*0+0*0+9', '1*0+0-0*0*0*0-0+0+9', '1*0+0-0*0*0*0-0-0+9', '1*0+0-0*0*0*0-0*0+9', '1*0+0-0*0*0*0*0+0+9', '1*0+0-0*0*0*0*0-0+9', '1*0+0-0*0*0*0*0*0+9', '1*0+0*0+0+0+0+0+0+9', '1*0+0*0+0+0+0+0-0+9', '1*0+0*0+0+0+0+0*0+9', '1*0+0*0+0+0+0-0+0+9', '1*0+0*0+0+0+0-0-0+9', '1*0+0*0+0+0+0-0*0+9', '1*0+0*0+0+0+0*0+0+9', '1*0+0*0+0+0+0*0-0+9', '1*0+0*0+0+0+0*0*0+9', '1*0+0*0+0+0-0+0+0+9', '1*0+0*0+0+0-0+0-0+9', '1*0+0*0+0+0-0+0*0+9', '1*0+0*0+0+0-0-0+0+9', '1*0+0*0+0+0-0-0-0+9', '1*0+0*0+0+0-0-0*0+9', '1*0+0*0+0+0-0*0+0+9', '1*0+0*0+0+0-0*0-0+9', '1*0+0*0+0+0-0*0*0+9', '1*0+0*0+0+0*0+0+0+9', '1*0+0*0+0+0*0+0-0+9', '1*0+0*0+0+0*0+0*0+9', '1*0+0*0+0+0*0-0+0+9', '1*0+0*0+0+0*0-0-0+9', '1*0+0*0+0+0*0-0*0+9', '1*0+0*0+0+0*0*0+0+9', '1*0+0*0+0+0*0*0-0+9', '1*0+0*0+0+0*0*0*0+9', '1*0+0*0+0-0+0+0+0+9', '1*0+0*0+0-0+0+0-0+9', '1*0+0*0+0-0+0+0*0+9', '1*0+0*0+0-0+0-0+0+9', '1*0+0*0+0-0+0-0-0+9', '1*0+0*0+0-0+0-0*0+9', '1*0+0*0+0-0+0*0+0+9', '1*0+0*0+0-0+0*0-0+9', '1*0+0*0+0-0+0*0*0+9', '1*0+0*0+0-0-0+0+0+9', '1*0+0*0+0-0-0+0-0+9', '1*0+0*0+0-0-0+0*0+9', '1*0+0*0+0-0-0-0+0+9', '1*0+0*0+0-0-0-0-0+9', '1*0+0*0+0-0-0-0*0+9', '1*0+0*0+0-0-0*0+0+9', '1*0+0*0+0-0-0*0-0+9', '1*0+0*0+0-0-0*0*0+9', '1*0+0*0+0-0*0+0+0+9', '1*0+0*0+0-0*0+0-0+9', '1*0+0*0+0-0*0+0*0+9', '1*0+0*0+0-0*0-0+0+9', '1*0+0*0+0-0*0-0-0+9', '1*0+0*0+0-0*0-0*0+9', '1*0+0*0+0-0*0*0+0+9', '1*0+0*0+0-0*0*0-0+9', '1*0+0*0+0-0*0*0*0+9', '1*0+0*0+0*0+0+0+0+9', '1*0+0*0+0*0+0+0-0+9', '1*0+0*0+0*0+0+0*0+9', '1*0+0*0+0*0+0-0+0+9', '1*0+0*0+0*0+0-0-0+9', '1*0+0*0+0*0+0-0*0+9', '1*0+0*0+0*0+0*0+0+9', '1*0+0*0+0*0+0*0-0+9', '1*0+0*0+0*0+0*0*0+9', '1*0+0*0+0*0-0+0+0+9', '1*0+0*0+0*0-0+0-0+9', '1*0+0*0+0*0-0+0*0+9', '1*0+0*0+0*0-0-0+0+9', '1*0+0*0+0*0-0-0-0+9', '1*0+0*0+0*0-0-0*0+9', '1*0+0*0+0*0-0*0+0+9', '1*0+0*0+0*0-0*0-0+9', '1*0+0*0+0*0-0*0*0+9', '1*0+0*0+0*0*0+0+0+9', '1*0+0*0+0*0*0+0-0+9', '1*0+0*0+0*0*0+0*0+9', '1*0+0*0+0*0*0-0+0+9', '1*0+0*0+0*0*0-0-0+9', '1*0+0*0+0*0*0-0*0+9', '1*0+0*0+0*0*0*0+0+9', '1*0+0*0+0*0*0*0-0+9', '1*0+0*0+0*0*0*0*0+9', '1*0+0*0-0+0+0+0+0+9', '1*0+0*0-0+0+0+0-0+9', '1*0+0*0-0+0+0+0*0+9', '1*0+0*0-0+0+0-0+0+9', '1*0+0*0-0+0+0-0-0+9', '1*0+0*0-0+0+0-0*0+9', '1*0+0*0-0+0+0*0+0+9', '1*0+0*0-0+0+0*0-0+9', '1*0+0*0-0+0+0*0*0+9', '1*0+0*0-0+0-0+0+0+9', '1*0+0*0-0+0-0+0-0+9', '1*0+0*0-0+0-0+0*0+9', '1*0+0*0-0+0-0-0+0+9', '1*0+0*0-0+0-0-0-0+9', '1*0+0*0-0+0-0-0*0+9', '1*0+0*0-0+0-0*0+0+9', '1*0+0*0-0+0-0*0-0+9', '1*0+0*0-0+0-0*0*0+9', '1*0+0*0-0+0*0+0+0+9', '1*0+0*0-0+0*0+0-0+9', '1*0+0*0-0+0*0+0*0+9', '1*0+0*0-0+0*0-0+0+9', '1*0+0*0-0+0*0-0-0+9', '1*0+0*0-0+0*0-0*0+9', '1*0+0*0-0+0*0*0+0+9', '1*0+0*0-0+0*0*0-0+9', '1*0+0*0-0+0*0*0*0+9', '1*0+0*0-0-0+0+0+0+9', '1*0+0*0-0-0+0+0-0+9', '1*0+0*0-0-0+0+0*0+9', '1*0+0*0-0-0+0-0+0+9', '1*0+0*0-0-0+0-0-0+9', '1*0+0*0-0-0+0-0*0+9', '1*0+0*0-0-0+0*0+0+9', '1*0+0*0-0-0+0*0-0+9', '1*0+0*0-0-0+0*0*0+9', '1*0+0*0-0-0-0+0+0+9', '1*0+0*0-0-0-0+0-0+9', '1*0+0*0-0-0-0+0*0+9', '1*0+0*0-0-0-0-0+0+9', '1*0+0*0-0-0-0-0-0+9', '1*0+0*0-0-0-0-0*0+9', '1*0+0*0-0-0-0*0+0+9', '1*0+0*0-0-0-0*0-0+9', '1*0+0*0-0-0-0*0*0+9', '1*0+0*0-0-0*0+0+0+9', '1*0+0*0-0-0*0+0-0+9', '1*0+0*0-0-0*0+0*0+9', '1*0+0*0-0-0*0-0+0+9', '1*0+0*0-0-0*0-0-0+9', '1*0+0*0-0-0*0-0*0+9', '1*0+0*0-0-0*0*0+0+9', '1*0+0*0-0-0*0*0-0+9', '1*0+0*0-0-0*0*0*0+9', '1*0+0*0-0*0+0+0+0+9', '1*0+0*0-0*0+0+0-0+9', '1*0+0*0-0*0+0+0*0+9', '1*0+0*0-0*0+0-0+0+9', '1*0+0*0-0*0+0-0-0+9', '1*0+0*0-0*0+0-0*0+9', '1*0+0*0-0*0+0*0+0+9', '1*0+0*0-0*0+0*0-0+9', '1*0+0*0-0*0+0*0*0+9', '1*0+0*0-0*0-0+0+0+9', '1*0+0*0-0*0-0+0-0+9', '1*0+0*0-0*0-0+0*0+9', '1*0+0*0-0*0-0-0+0+9', '1*0+0*0-0*0-0-0-0+9', '1*0+0*0-0*0-0-0*0+9', '1*0+0*0-0*0-0*0+0+9', '1*0+0*0-0*0-0*0-0+9', '1*0+0*0-0*0-0*0*0+9', '1*0+0*0-0*0*0+0+0+9', '1*0+0*0-0*0*0+0-0+9', '1*0+0*0-0*0*0+0*0+9', '1*0+0*0-0*0*0-0+0+9', '1*0+0*0-0*0*0-0-0+9', '1*0+0*0-0*0*0-0*0+9', '1*0+0*0-0*0*0*0+0+9', '1*0+0*0-0*0*0*0-0+9', '1*0+0*0-0*0*0*0*0+9', '1*0+0*0*0+0+0+0+0+9', '1*0+0*0*0+0+0+0-0+9', '1*0+0*0*0+0+0+0*0+9', '1*0+0*0*0+0+0-0+0+9', '1*0+0*0*0+0+0-0-0+9', '1*0+0*0*0+0+0-0*0+9', '1*0+0*0*0+0+0*0+0+9', '1*0+0*0*0+0+0*0-0+9', '1*0+0*0*0+0+0*0*0+9', '1*0+0*0*0+0-0+0+0+9', '1*0+0*0*0+0-0+0-0+9', '1*0+0*0*0+0-0+0*0+9', '1*0+0*0*0+0-0-0+0+9', '1*0+0*0*0+0-0-0-0+9', '1*0+0*0*0+0-0-0*0+9', '1*0+0*0*0+0-0*0+0+9', '1*0+0*0*0+0-0*0-0+9', '1*0+0*0*0+0-0*0*0+9', '1*0+0*0*0+0*0+0+0+9', '1*0+0*0*0+0*0+0-0+9', '1*0+0*0*0+0*0+0*0+9', '1*0+0*0*0+0*0-0+0+9', '1*0+0*0*0+0*0-0-0+9', '1*0+0*0*0+0*0-0*0+9', '1*0+0*0*0+0*0*0+0+9', '1*0+0*0*0+0*0*0-0+9', '1*0+0*0*0+0*0*0*0+9', '1*0+0*0*0-0+0+0+0+9', '1*0+0*0*0-0+0+0-0+9', '1*0+0*0*0-0+0+0*0+9', '1*0+0*0*0-0+0-0+0+9', '1*0+0*0*0-0+0-0-0+9', '1*0+0*0*0-0+0-0*0+9', '1*0+0*0*0-0+0*0+0+9', '1*0+0*0*0-0+0*0-0+9', '1*0+0*0*0-0+0*0*0+9', '1*0+0*0*0-0-0+0+0+9', '1*0+0*0*0-0-0+0-0+9', '1*0+0*0*0-0-0+0*0+9', '1*0+0*0*0-0-0-0+0+9', '1*0+0*0*0-0-0-0-0+9', '1*0+0*0*0-0-0-0*0+9', '1*0+0*0*0-0-0*0+0+9', '1*0+0*0*0-0-0*0-0+9', '1*0+0*0*0-0-0*0*0+9', '1*0+0*0*0-0*0+0+0+9', '1*0+0*0*0-0*0+0-0+9', '1*0+0*0*0-0*0+0*0+9', '1*0+0*0*0-0*0-0+0+9', '1*0+0*0*0-0*0-0-0+9', '1*0+0*0*0-0*0-0*0+9', '1*0+0*0*0-0*0*0+0+9', '1*0+0*0*0-0*0*0-0+9', '1*0+0*0*0-0*0*0*0+9', '1*0+0*0*0*0+0+0+0+9', '1*0+0*0*0*0+0+0-0+9', '1*0+0*0*0*0+0+0*0+9', '1*0+0*0*0*0+0-0+0+9', '1*0+0*0*0*0+0-0-0+9', '1*0+0*0*0*0+0-0*0+9', '1*0+0*0*0*0+0*0+0+9', '1*0+0*0*0*0+0*0-0+9', '1*0+0*0*0*0+0*0*0+9', '1*0+0*0*0*0-0+0+0+9', '1*0+0*0*0*0-0+0-0+9', '1*0+0*0*0*0-0+0*0+9', '1*0+0*0*0*0-0-0+0+9', '1*0+0*0*0*0-0-0-0+9', '1*0+0*0*0*0-0-0*0+9', '1*0+0*0*0*0-0*0+0+9', '1*0+0*0*0*0-0*0-0+9', '1*0+0*0*0*0-0*0*0+9', '1*0+0*0*0*0*0+0+0+9', '1*0+0*0*0*0*0+0-0+9', '1*0+0*0*0*0*0+0*0+9', '1*0+0*0*0*0*0-0+0+9', '1*0+0*0*0*0*0-0-0+9', '1*0+0*0*0*0*0-0*0+9', '1*0+0*0*0*0*0*0+0+9', '1*0+0*0*0*0*0*0-0+9', '1*0+0*0*0*0*0*0*0+9', '1*0-0+0+0+0+0+0+0+9', '1*0-0+0+0+0+0+0-0+9', '1*0-0+0+0+0+0+0*0+9', '1*0-0+0+0+0+0-0+0+9', '1*0-0+0+0+0+0-0-0+9', '1*0-0+0+0+0+0-0*0+9', '1*0-0+0+0+0+0*0+0+9', '1*0-0+0+0+0+0*0-0+9', '1*0-0+0+0+0+0*0*0+9', '1*0-0+0+0+0-0+0+0+9', '1*0-0+0+0+0-0+0-0+9', '1*0-0+0+0+0-0+0*0+9', '1*0-0+0+0+0-0-0+0+9', '1*0-0+0+0+0-0-0-0+9', '1*0-0+0+0+0-0-0*0+9', '1*0-0+0+0+0-0*0+0+9', '1*0-0+0+0+0-0*0-0+9', '1*0-0+0+0+0-0*0*0+9', '1*0-0+0+0+0*0+0+0+9', '1*0-0+0+0+0*0+0-0+9', '1*0-0+0+0+0*0+0*0+9', '1*0-0+0+0+0*0-0+0+9', '1*0-0+0+0+0*0-0-0+9', '1*0-0+0+0+0*0-0*0+9', '1*0-0+0+0+0*0*0+0+9', '1*0-0+0+0+0*0*0-0+9', '1*0-0+0+0+0*0*0*0+9', '1*0-0+0+0-0+0+0+0+9', '1*0-0+0+0-0+0+0-0+9', '1*0-0+0+0-0+0+0*0+9', '1*0-0+0+0-0+0-0+0+9', '1*0-0+0+0-0+0-0-0+9', '1*0-0+0+0-0+0-0*0+9', '1*0-0+0+0-0+0*0+0+9', '1*0-0+0+0-0+0*0-0+9', '1*0-0+0+0-0+0*0*0+9', '1*0-0+0+0-0-0+0+0+9', '1*0-0+0+0-0-0+0-0+9', '1*0-0+0+0-0-0+0*0+9', '1*0-0+0+0-0-0-0+0+9', '1*0-0+0+0-0-0-0-0+9', '1*0-0+0+0-0-0-0*0+9', '1*0-0+0+0-0-0*0+0+9', '1*0-0+0+0-0-0*0-0+9', '1*0-0+0+0-0-0*0*0+9', '1*0-0+0+0-0*0+0+0+9', '1*0-0+0+0-0*0+0-0+9', '1*0-0+0+0-0*0+0*0+9', '1*0-0+0+0-0*0-0+0+9', '1*0-0+0+0-0*0-0-0+9', '1*0-0+0+0-0*0-0*0+9', '1*0-0+0+0-0*0*0+0+9', '1*0-0+0+0-0*0*0-0+9', '1*0-0+0+0-0*0*0*0+9', '1*0-0+0+0*0+0+0+0+9', '1*0-0+0+0*0+0+0-0+9', '1*0-0+0+0*0+0+0*0+9', '1*0-0+0+0*0+0-0+0+9', '1*0-0+0+0*0+0-0-0+9', '1*0-0+0+0*0+0-0*0+9', '1*0-0+0+0*0+0*0+0+9', '1*0-0+0+0*0+0*0-0+9', '1*0-0+0+0*0+0*0*0+9', '1*0-0+0+0*0-0+0+0+9', '1*0-0+0+0*0-0+0-0+9', '1*0-0+0+0*0-0+0*0+9', '1*0-0+0+0*0-0-0+0+9', '1*0-0+0+0*0-0-0-0+9', '1*0-0+0+0*0-0-0*0+9', '1*0-0+0+0*0-0*0+0+9', '1*0-0+0+0*0-0*0-0+9', '1*0-0+0+0*0-0*0*0+9', '1*0-0+0+0*0*0+0+0+9', '1*0-0+0+0*0*0+0-0+9', '1*0-0+0+0*0*0+0*0+9', '1*0-0+0+0*0*0-0+0+9', '1*0-0+0+0*0*0-0-0+9', '1*0-0+0+0*0*0-0*0+9', '1*0-0+0+0*0*0*0+0+9', '1*0-0+0+0*0*0*0-0+9', '1*0-0+0+0*0*0*0*0+9', '1*0-0+0-0+0+0+0+0+9', '1*0-0+0-0+0+0+0-0+9', '1*0-0+0-0+0+0+0*0+9', '1*0-0+0-0+0+0-0+0+9', '1*0-0+0-0+0+0-0-0+9', '1*0-0+0-0+0+0-0*0+9', '1*0-0+0-0+0+0*0+0+9', '1*0-0+0-0+0+0*0-0+9', '1*0-0+0-0+0+0*0*0+9', '1*0-0+0-0+0-0+0+0+9', '1*0-0+0-0+0-0+0-0+9', '1*0-0+0-0+0-0+0*0+9', '1*0-0+0-0+0-0-0+0+9', '1*0-0+0-0+0-0-0-0+9', '1*0-0+0-0+0-0-0*0+9', '1*0-0+0-0+0-0*0+0+9', '1*0-0+0-0+0-0*0-0+9', '1*0-0+0-0+0-0*0*0+9', '1*0-0+0-0+0*0+0+0+9', '1*0-0+0-0+0*0+0-0+9', '1*0-0+0-0+0*0+0*0+9', '1*0-0+0-0+0*0-0+0+9', '1*0-0+0-0+0*0-0-0+9', '1*0-0+0-0+0*0-0*0+9', '1*0-0+0-0+0*0*0+0+9', '1*0-0+0-0+0*0*0-0+9', '1*0-0+0-0+0*0*0*0+9', '1*0-0+0-0-0+0+0+0+9', '1*0-0+0-0-0+0+0-0+9', '1*0-0+0-0-0+0+0*0+9', '1*0-0+0-0-0+0-0+0+9', '1*0-0+0-0-0+0-0-0+9', '1*0-0+0-0-0+0-0*0+9', '1*0-0+0-0-0+0*0+0+9', '1*0-0+0-0-0+0*0-0+9', '1*0-0+0-0-0+0*0*0+9', '1*0-0+0-0-0-0+0+0+9', '1*0-0+0-0-0-0+0-0+9', '1*0-0+0-0-0-0+0*0+9', '1*0-0+0-0-0-0-0+0+9', '1*0-0+0-0-0-0-0-0+9', '1*0-0+0-0-0-0-0*0+9', '1*0-0+0-0-0-0*0+0+9', '1*0-0+0-0-0-0*0-0+9', '1*0-0+0-0-0-0*0*0+9', '1*0-0+0-0-0*0+0+0+9', '1*0-0+0-0-0*0+0-0+9', '1*0-0+0-0-0*0+0*0+9', '1*0-0+0-0-0*0-0+0+9', '1*0-0+0-0-0*0-0-0+9', '1*0-0+0-0-0*0-0*0+9', '1*0-0+0-0-0*0*0+0+9', '1*0-0+0-0-0*0*0-0+9', '1*0-0+0-0-0*0*0*0+9', '1*0-0+0-0*0+0+0+0+9', '1*0-0+0-0*0+0+0-0+9', '1*0-0+0-0*0+0+0*0+9', '1*0-0+0-0*0+0-0+0+9', '1*0-0+0-0*0+0-0-0+9', '1*0-0+0-0*0+0-0*0+9', '1*0-0+0-0*0+0*0+0+9', '1*0-0+0-0*0+0*0-0+9', '1*0-0+0-0*0+0*0*0+9', '1*0-0+0-0*0-0+0+0+9', '1*0-0+0-0*0-0+0-0+9', '1*0-0+0-0*0-0+0*0+9', '1*0-0+0-0*0-0-0+0+9', '1*0-0+0-0*0-0-0-0+9', '1*0-0+0-0*0-0-0*0+9', '1*0-0+0-0*0-0*0+0+9', '1*0-0+0-0*0-0*0-0+9', '1*0-0+0-0*0-0*0*0+9', '1*0-0+0-0*0*0+0+0+9', '1*0-0+0-0*0*0+0-0+9', '1*0-0+0-0*0*0+0*0+9', '1*0-0+0-0*0*0-0+0+9', '1*0-0+0-0*0*0-0-0+9', '1*0-0+0-0*0*0-0*0+9', '1*0-0+0-0*0*0*0+0+9', '1*0-0+0-0*0*0*0-0+9', '1*0-0+0-0*0*0*0*0+9', '1*0-0+0*0+0+0+0+0+9', '1*0-0+0*0+0+0+0-0+9', '1*0-0+0*0+0+0+0*0+9', '1*0-0+0*0+0+0-0+0+9', '1*0-0+0*0+0+0-0-0+9', '1*0-0+0*0+0+0-0*0+9', '1*0-0+0*0+0+0*0+0+9', '1*0-0+0*0+0+0*0-0+9', '1*0-0+0*0+0+0*0*0+9', '1*0-0+0*0+0-0+0+0+9', '1*0-0+0*0+0-0+0-0+9', '1*0-0+0*0+0-0+0*0+9', '1*0-0+0*0+0-0-0+0+9', '1*0-0+0*0+0-0-0-0+9', '1*0-0+0*0+0-0-0*0+9', '1*0-0+0*0+0-0*0+0+9', '1*0-0+0*0+0-0*0-0+9', '1*0-0+0*0+0-0*0*0+9', '1*0-0+0*0+0*0+0+0+9', '1*0-0+0*0+0*0+0-0+9', '1*0-0+0*0+0*0+0*0+9', '1*0-0+0*0+0*0-0+0+9', '1*0-0+0*0+0*0-0-0+9', '1*0-0+0*0+0*0-0*0+9', '1*0-0+0*0+0*0*0+0+9', '1*0-0+0*0+0*0*0-0+9', '1*0-0+0*0+0*0*0*0+9', '1*0-0+0*0-0+0+0+0+9', '1*0-0+0*0-0+0+0-0+9', '1*0-0+0*0-0+0+0*0+9', '1*0-0+0*0-0+0-0+0+9', '1*0-0+0*0-0+0-0-0+9', '1*0-0+0*0-0+0-0*0+9', '1*0-0+0*0-0+0*0+0+9', '1*0-0+0*0-0+0*0-0+9', '1*0-0+0*0-0+0*0*0+9', '1*0-0+0*0-0-0+0+0+9', '1*0-0+0*0-0-0+0-0+9', '1*0-0+0*0-0-0+0*0+9', '1*0-0+0*0-0-0-0+0+9', '1*0-0+0*0-0-0-0-0+9', '1*0-0+0*0-0-0-0*0+9', '1*0-0+0*0-0-0*0+0+9', '1*0-0+0*0-0-0*0-0+9', '1*0-0+0*0-0-0*0*0+9', '1*0-0+0*0-0*0+0+0+9', '1*0-0+0*0-0*0+0-0+9', '1*0-0+0*0-0*0+0*0+9', '1*0-0+0*0-0*0-0+0+9', '1*0-0+0*0-0*0-0-0+9', '1*0-0+0*0-0*0-0*0+9', '1*0-0+0*0-0*0*0+0+9', '1*0-0+0*0-0*0*0-0+9', '1*0-0+0*0-0*0*0*0+9', '1*0-0+0*0*0+0+0+0+9', '1*0-0+0*0*0+0+0-0+9', '1*0-0+0*0*0+0+0*0+9', '1*0-0+0*0*0+0-0+0+9', '1*0-0+0*0*0+0-0-0+9', '1*0-0+0*0*0+0-0*0+9', '1*0-0+0*0*0+0*0+0+9', '1*0-0+0*0*0+0*0-0+9', '1*0-0+0*0*0+0*0*0+9', '1*0-0+0*0*0-0+0+0+9', '1*0-0+0*0*0-0+0-0+9', '1*0-0+0*0*0-0+0*0+9', '1*0-0+0*0*0-0-0+0+9', '1*0-0+0*0*0-0-0-0+9', '1*0-0+0*0*0-0-0*0+9', '1*0-0+0*0*0-0*0+0+9', '1*0-0+0*0*0-0*0-0+9', '1*0-0+0*0*0-0*0*0+9', '1*0-0+0*0*0*0+0+0+9', '1*0-0+0*0*0*0+0-0+9', '1*0-0+0*0*0*0+0*0+9', '1*0-0+0*0*0*0-0+0+9', '1*0-0+0*0*0*0-0-0+9', '1*0-0+0*0*0*0-0*0+9', '1*0-0+0*0*0*0*0+0+9', '1*0-0+0*0*0*0*0-0+9', '1*0-0+0*0*0*0*0*0+9', '1*0-0-0+0+0+0+0+0+9', '1*0-0-0+0+0+0+0-0+9', '1*0-0-0+0+0+0+0*0+9', '1*0-0-0+0+0+0-0+0+9', '1*0-0-0+0+0+0-0-0+9', '1*0-0-0+0+0+0-0*0+9', '1*0-0-0+0+0+0*0+0+9', '1*0-0-0+0+0+0*0-0+9', '1*0-0-0+0+0+0*0*0+9', '1*0-0-0+0+0-0+0+0+9', '1*0-0-0+0+0-0+0-0+9', '1*0-0-0+0+0-0+0*0+9', '1*0-0-0+0+0-0-0+0+9', '1*0-0-0+0+0-0-0-0+9', '1*0-0-0+0+0-0-0*0+9', '1*0-0-0+0+0-0*0+0+9', '1*0-0-0+0+0-0*0-0+9', '1*0-0-0+0+0-0*0*0+9', '1*0-0-0+0+0*0+0+0+9', '1*0-0-0+0+0*0+0-0+9', '1*0-0-0+0+0*0+0*0+9', '1*0-0-0+0+0*0-0+0+9', '1*0-0-0+0+0*0-0-0+9', '1*0-0-0+0+0*0-0*0+9', '1*0-0-0+0+0*0*0+0+9', '1*0-0-0+0+0*0*0-0+9', '1*0-0-0+0+0*0*0*0+9', '1*0-0-0+0-0+0+0+0+9', '1*0-0-0+0-0+0+0-0+9', '1*0-0-0+0-0+0+0*0+9', '1*0-0-0+0-0+0-0+0+9', '1*0-0-0+0-0+0-0-0+9', '1*0-0-0+0-0+0-0*0+9', '1*0-0-0+0-0+0*0+0+9', '1*0-0-0+0-0+0*0-0+9', '1*0-0-0+0-0+0*0*0+9', '1*0-0-0+0-0-0+0+0+9', '1*0-0-0+0-0-0+0-0+9', '1*0-0-0+0-0-0+0*0+9', '1*0-0-0+0-0-0-0+0+9', '1*0-0-0+0-0-0-0-0+9', '1*0-0-0+0-0-0-0*0+9', '1*0-0-0+0-0-0*0+0+9', '1*0-0-0+0-0-0*0-0+9', '1*0-0-0+0-0-0*0*0+9', '1*0-0-0+0-0*0+0+0+9', '1*0-0-0+0-0*0+0-0+9', '1*0-0-0+0-0*0+0*0+9', '1*0-0-0+0-0*0-0+0+9', '1*0-0-0+0-0*0-0-0+9', '1*0-0-0+0-0*0-0*0+9', '1*0-0-0+0-0*0*0+0+9', '1*0-0-0+0-0*0*0-0+9', '1*0-0-0+0-0*0*0*0+9', '1*0-0-0+0*0+0+0+0+9', '1*0-0-0+0*0+0+0-0+9', '1*0-0-0+0*0+0+0*0+9', '1*0-0-0+0*0+0-0+0+9', '1*0-0-0+0*0+0-0-0+9', '1*0-0-0+0*0+0-0*0+9', '1*0-0-0+0*0+0*0+0+9', '1*0-0-0+0*0+0*0-0+9', '1*0-0-0+0*0+0*0*0+9', '1*0-0-0+0*0-0+0+0+9', '1*0-0-0+0*0-0+0-0+9', '1*0-0-0+0*0-0+0*0+9', '1*0-0-0+0*0-0-0+0+9', '1*0-0-0+0*0-0-0-0+9', '1*0-0-0+0*0-0-0*0+9', '1*0-0-0+0*0-0*0+0+9', '1*0-0-0+0*0-0*0-0+9', '1*0-0-0+0*0-0*0*0+9', '1*0-0-0+0*0*0+0+0+9', '1*0-0-0+0*0*0+0-0+9', '1*0-0-0+0*0*0+0*0+9', '1*0-0-0+0*0*0-0+0+9', '1*0-0-0+0*0*0-0-0+9', '1*0-0-0+0*0*0-0*0+9', '1*0-0-0+0*0*0*0+0+9', '1*0-0-0+0*0*0*0-0+9', '1*0-0-0+0*0*0*0*0+9', '1*0-0-0-0+0+0+0+0+9', '1*0-0-0-0+0+0+0-0+9', '1*0-0-0-0+0+0+0*0+9', '1*0-0-0-0+0+0-0+0+9', '1*0-0-0-0+0+0-0-0+9', '1*0-0-0-0+0+0-0*0+9', '1*0-0-0-0+0+0*0+0+9', '1*0-0-0-0+0+0*0-0+9', '1*0-0-0-0+0+0*0*0+9', '1*0-0-0-0+0-0+0+0+9', '1*0-0-0-0+0-0+0-0+9', '1*0-0-0-0+0-0+0*0+9', '1*0-0-0-0+0-0-0+0+9', '1*0-0-0-0+0-0-0-0+9', '1*0-0-0-0+0-0-0*0+9', '1*0-0-0-0+0-0*0+0+9', '1*0-0-0-0+0-0*0-0+9', '1*0-0-0-0+0-0*0*0+9', '1*0-0-0-0+0*0+0+0+9', '1*0-0-0-0+0*0+0-0+9', '1*0-0-0-0+0*0+0*0+9', '1*0-0-0-0+0*0-0+0+9', '1*0-0-0-0+0*0-0-0+9', '1*0-0-0-0+0*0-0*0+9', '1*0-0-0-0+0*0*0+0+9', '1*0-0-0-0+0*0*0-0+9', '1*0-0-0-0+0*0*0*0+9', '1*0-0-0-0-0+0+0+0+9', '1*0-0-0-0-0+0+0-0+9', '1*0-0-0-0-0+0+0*0+9', '1*0-0-0-0-0+0-0+0+9', '1*0-0-0-0-0+0-0-0+9', '1*0-0-0-0-0+0-0*0+9', '1*0-0-0-0-0+0*0+0+9', '1*0-0-0-0-0+0*0-0+9', '1*0-0-0-0-0+0*0*0+9', '1*0-0-0-0-0-0+0+0+9', '1*0-0-0-0-0-0+0-0+9', '1*0-0-0-0-0-0+0*0+9', '1*0-0-0-0-0-0-0+0+9', '1*0-0-0-0-0-0-0-0+9', '1*0-0-0-0-0-0-0*0+9', '1*0-0-0-0-0-0*0+0+9', '1*0-0-0-0-0-0*0-0+9', '1*0-0-0-0-0-0*0*0+9', '1*0-0-0-0-0*0+0+0+9', '1*0-0-0-0-0*0+0-0+9', '1*0-0-0-0-0*0+0*0+9', '1*0-0-0-0-0*0-0+0+9', '1*0-0-0-0-0*0-0-0+9', '1*0-0-0-0-0*0-0*0+9', '1*0-0-0-0-0*0*0+0+9', '1*0-0-0-0-0*0*0-0+9', '1*0-0-0-0-0*0*0*0+9', '1*0-0-0-0*0+0+0+0+9', '1*0-0-0-0*0+0+0-0+9', '1*0-0-0-0*0+0+0*0+9', '1*0-0-0-0*0+0-0+0+9', '1*0-0-0-0*0+0-0-0+9', '1*0-0-0-0*0+0-0*0+9', '1*0-0-0-0*0+0*0+0+9', '1*0-0-0-0*0+0*0-0+9', '1*0-0-0-0*0+0*0*0+9', '1*0-0-0-0*0-0+0+0+9', '1*0-0-0-0*0-0+0-0+9', '1*0-0-0-0*0-0+0*0+9', '1*0-0-0-0*0-0-0+0+9', '1*0-0-0-0*0-0-0-0+9', '1*0-0-0-0*0-0-0*0+9', '1*0-0-0-0*0-0*0+0+9', '1*0-0-0-0*0-0*0-0+9', '1*0-0-0-0*0-0*0*0+9', '1*0-0-0-0*0*0+0+0+9', '1*0-0-0-0*0*0+0-0+9', '1*0-0-0-0*0*0+0*0+9', '1*0-0-0-0*0*0-0+0+9', '1*0-0-0-0*0*0-0-0+9', '1*0-0-0-0*0*0-0*0+9', '1*0-0-0-0*0*0*0+0+9', '1*0-0-0-0*0*0*0-0+9', '1*0-0-0-0*0*0*0*0+9', '1*0-0-0*0+0+0+0+0+9', '1*0-0-0*0+0+0+0-0+9', '1*0-0-0*0+0+0+0*0+9', '1*0-0-0*0+0+0-0+0+9', '1*0-0-0*0+0+0-0-0+9', '1*0-0-0*0+0+0-0*0+9', '1*0-0-0*0+0+0*0+0+9', '1*0-0-0*0+0+0*0-0+9', '1*0-0-0*0+0+0*0*0+9', '1*0-0-0*0+0-0+0+0+9', '1*0-0-0*0+0-0+0-0+9', '1*0-0-0*0+0-0+0*0+9', '1*0-0-0*0+0-0-0+0+9', '1*0-0-0*0+0-0-0-0+9', '1*0-0-0*0+0-0-0*0+9', '1*0-0-0*0+0-0*0+0+9', '1*0-0-0*0+0-0*0-0+9', '1*0-0-0*0+0-0*0*0+9', '1*0-0-0*0+0*0+0+0+9', '1*0-0-0*0+0*0+0-0+9', '1*0-0-0*0+0*0+0*0+9', '1*0-0-0*0+0*0-0+0+9', '1*0-0-0*0+0*0-0-0+9', '1*0-0-0*0+0*0-0*0+9', '1*0-0-0*0+0*0*0+0+9', '1*0-0-0*0+0*0*0-0+9', '1*0-0-0*0+0*0*0*0+9', '1*0-0-0*0-0+0+0+0+9', '1*0-0-0*0-0+0+0-0+9', '1*0-0-0*0-0+0+0*0+9', '1*0-0-0*0-0+0-0+0+9', '1*0-0-0*0-0+0-0-0+9', '1*0-0-0*0-0+0-0*0+9', '1*0-0-0*0-0+0*0+0+9', '1*0-0-0*0-0+0*0-0+9', '1*0-0-0*0-0+0*0*0+9', '1*0-0-0*0-0-0+0+0+9', '1*0-0-0*0-0-0+0-0+9', '1*0-0-0*0-0-0+0*0+9', '1*0-0-0*0-0-0-0+0+9', '1*0-0-0*0-0-0-0-0+9', '1*0-0-0*0-0-0-0*0+9', '1*0-0-0*0-0-0*0+0+9', '1*0-0-0*0-0-0*0-0+9', '1*0-0-0*0-0-0*0*0+9', '1*0-0-0*0-0*0+0+0+9', '1*0-0-0*0-0*0+0-0+9', '1*0-0-0*0-0*0+0*0+9', '1*0-0-0*0-0*0-0+0+9', '1*0-0-0*0-0*0-0-0+9', '1*0-0-0*0-0*0-0*0+9', '1*0-0-0*0-0*0*0+0+9', '1*0-0-0*0-0*0*0-0+9', '1*0-0-0*0-0*0*0*0+9', '1*0-0-0*0*0+0+0+0+9', '1*0-0-0*0*0+0+0-0+9', '1*0-0-0*0*0+0+0*0+9', '1*0-0-0*0*0+0-0+0+9', '1*0-0-0*0*0+0-0-0+9', '1*0-0-0*0*0+0-0*0+9', '1*0-0-0*0*0+0*0+0+9', '1*0-0-0*0*0+0*0-0+9', '1*0-0-0*0*0+0*0*0+9', '1*0-0-0*0*0-0+0+0+9', '1*0-0-0*0*0-0+0-0+9', '1*0-0-0*0*0-0+0*0+9', '1*0-0-0*0*0-0-0+0+9', '1*0-0-0*0*0-0-0-0+9', '1*0-0-0*0*0-0-0*0+9', '1*0-0-0*0*0-0*0+0+9', '1*0-0-0*0*0-0*0-0+9', '1*0-0-0*0*0-0*0*0+9', '1*0-0-0*0*0*0+0+0+9', '1*0-0-0*0*0*0+0-0+9', '1*0-0-0*0*0*0+0*0+9', '1*0-0-0*0*0*0-0+0+9', '1*0-0-0*0*0*0-0-0+9', '1*0-0-0*0*0*0-0*0+9', '1*0-0-0*0*0*0*0+0+9', '1*0-0-0*0*0*0*0-0+9', '1*0-0-0*0*0*0*0*0+9', '1*0-0*0+0+0+0+0+0+9', '1*0-0*0+0+0+0+0-0+9', '1*0-0*0+0+0+0+0*0+9', '1*0-0*0+0+0+0-0+0+9', '1*0-0*0+0+0+0-0-0+9', '1*0-0*0+0+0+0-0*0+9', '1*0-0*0+0+0+0*0+0+9', '1*0-0*0+0+0+0*0-0+9', '1*0-0*0+0+0+0*0*0+9', '1*0-0*0+0+0-0+0+0+9', '1*0-0*0+0+0-0+0-0+9', '1*0-0*0+0+0-0+0*0+9', '1*0-0*0+0+0-0-0+0+9', '1*0-0*0+0+0-0-0-0+9', '1*0-0*0+0+0-0-0*0+9', '1*0-0*0+0+0-0*0+0+9', '1*0-0*0+0+0-0*0-0+9', '1*0-0*0+0+0-0*0*0+9', '1*0-0*0+0+0*0+0+0+9', '1*0-0*0+0+0*0+0-0+9', '1*0-0*0+0+0*0+0*0+9', '1*0-0*0+0+0*0-0+0+9', '1*0-0*0+0+0*0-0-0+9', '1*0-0*0+0+0*0-0*0+9', '1*0-0*0+0+0*0*0+0+9', '1*0-0*0+0+0*0*0-0+9', '1*0-0*0+0+0*0*0*0+9', '1*0-0*0+0-0+0+0+0+9', '1*0-0*0+0-0+0+0-0+9', '1*0-0*0+0-0+0+0*0+9', '1*0-0*0+0-0+0-0+0+9', '1*0-0*0+0-0+0-0-0+9', '1*0-0*0+0-0+0-0*0+9', '1*0-0*0+0-0+0*0+0+9', '1*0-0*0+0-0+0*0-0+9', '1*0-0*0+0-0+0*0*0+9', '1*0-0*0+0-0-0+0+0+9', '1*0-0*0+0-0-0+0-0+9', '1*0-0*0+0-0-0+0*0+9', '1*0-0*0+0-0-0-0+0+9', '1*0-0*0+0-0-0-0-0+9', '1*0-0*0+0-0-0-0*0+9', '1*0-0*0+0-0-0*0+0+9', '1*0-0*0+0-0-0*0-0+9', '1*0-0*0+0-0-0*0*0+9', '1*0-0*0+0-0*0+0+0+9', '1*0-0*0+0-0*0+0-0+9', '1*0-0*0+0-0*0+0*0+9', '1*0-0*0+0-0*0-0+0+9', '1*0-0*0+0-0*0-0-0+9', '1*0-0*0+0-0*0-0*0+9', '1*0-0*0+0-0*0*0+0+9', '1*0-0*0+0-0*0*0-0+9', '1*0-0*0+0-0*0*0*0+9', '1*0-0*0+0*0+0+0+0+9', '1*0-0*0+0*0+0+0-0+9', '1*0-0*0+0*0+0+0*0+9', '1*0-0*0+0*0+0-0+0+9', '1*0-0*0+0*0+0-0-0+9', '1*0-0*0+0*0+0-0*0+9', '1*0-0*0+0*0+0*0+0+9', '1*0-0*0+0*0+0*0-0+9', '1*0-0*0+0*0+0*0*0+9', '1*0-0*0+0*0-0+0+0+9', '1*0-0*0+0*0-0+0-0+9', '1*0-0*0+0*0-0+0*0+9', '1*0-0*0+0*0-0-0+0+9', '1*0-0*0+0*0-0-0-0+9', '1*0-0*0+0*0-0-0*0+9', '1*0-0*0+0*0-0*0+0+9', '1*0-0*0+0*0-0*0-0+9', '1*0-0*0+0*0-0*0*0+9', '1*0-0*0+0*0*0+0+0+9', '1*0-0*0+0*0*0+0-0+9', '1*0-0*0+0*0*0+0*0+9', '1*0-0*0+0*0*0-0+0+9', '1*0-0*0+0*0*0-0-0+9', '1*0-0*0+0*0*0-0*0+9', '1*0-0*0+0*0*0*0+0+9', '1*0-0*0+0*0*0*0-0+9', '1*0-0*0+0*0*0*0*0+9', '1*0-0*0-0+0+0+0+0+9', '1*0-0*0-0+0+0+0-0+9', '1*0-0*0-0+0+0+0*0+9', '1*0-0*0-0+0+0-0+0+9', '1*0-0*0-0+0+0-0-0+9', '1*0-0*0-0+0+0-0*0+9', '1*0-0*0-0+0+0*0+0+9', '1*0-0*0-0+0+0*0-0+9', '1*0-0*0-0+0+0*0*0+9', '1*0-0*0-0+0-0+0+0+9', '1*0-0*0-0+0-0+0-0+9', '1*0-0*0-0+0-0+0*0+9', '1*0-0*0-0+0-0-0+0+9', '1*0-0*0-0+0-0-0-0+9', '1*0-0*0-0+0-0-0*0+9', '1*0-0*0-0+0-0*0+0+9', '1*0-0*0-0+0-0*0-0+9', '1*0-0*0-0+0-0*0*0+9', '1*0-0*0-0+0*0+0+0+9', '1*0-0*0-0+0*0+0-0+9', '1*0-0*0-0+0*0+0*0+9', '1*0-0*0-0+0*0-0+0+9', '1*0-0*0-0+0*0-0-0+9', '1*0-0*0-0+0*0-0*0+9', '1*0-0*0-0+0*0*0+0+9', '1*0-0*0-0+0*0*0-0+9', '1*0-0*0-0+0*0*0*0+9', '1*0-0*0-0-0+0+0+0+9', '1*0-0*0-0-0+0+0-0+9', '1*0-0*0-0-0+0+0*0+9', '1*0-0*0-0-0+0-0+0+9', '1*0-0*0-0-0+0-0-0+9', '1*0-0*0-0-0+0-0*0+9', '1*0-0*0-0-0+0*0+0+9', '1*0-0*0-0-0+0*0-0+9', '1*0-0*0-0-0+0*0*0+9', '1*0-0*0-0-0-0+0+0+9', '1*0-0*0-0-0-0+0-0+9', '1*0-0*0-0-0-0+0*0+9', '1*0-0*0-0-0-0-0+0+9', '1*0-0*0-0-0-0-0-0+9', '1*0-0*0-0-0-0-0*0+9', '1*0-0*0-0-0-0*0+0+9', '1*0-0*0-0-0-0*0-0+9', '1*0-0*0-0-0-0*0*0+9', '1*0-0*0-0-0*0+0+0+9', '1*0-0*0-0-0*0+0-0+9', '1*0-0*0-0-0*0+0*0+9', '1*0-0*0-0-0*0-0+0+9', '1*0-0*0-0-0*0-0-0+9', '1*0-0*0-0-0*0-0*0+9', '1*0-0*0-0-0*0*0+0+9', '1*0-0*0-0-0*0*0-0+9', '1*0-0*0-0-0*0*0*0+9', '1*0-0*0-0*0+0+0+0+9', '1*0-0*0-0*0+0+0-0+9', '1*0-0*0-0*0+0+0*0+9', '1*0-0*0-0*0+0-0+0+9', '1*0-0*0-0*0+0-0-0+9', '1*0-0*0-0*0+0-0*0+9', '1*0-0*0-0*0+0*0+0+9', '1*0-0*0-0*0+0*0-0+9', '1*0-0*0-0*0+0*0*0+9', '1*0-0*0-0*0-0+0+0+9', '1*0-0*0-0*0-0+0-0+9', '1*0-0*0-0*0-0+0*0+9', '1*0-0*0-0*0-0-0+0+9', '1*0-0*0-0*0-0-0-0+9', '1*0-0*0-0*0-0-0*0+9', '1*0-0*0-0*0-0*0+0+9', '1*0-0*0-0*0-0*0-0+9', '1*0-0*0-0*0-0*0*0+9', '1*0-0*0-0*0*0+0+0+9', '1*0-0*0-0*0*0+0-0+9', '1*0-0*0-0*0*0+0*0+9', '1*0-0*0-0*0*0-0+0+9', '1*0-0*0-0*0*0-0-0+9', '1*0-0*0-0*0*0-0*0+9', '1*0-0*0-0*0*0*0+0+9', '1*0-0*0-0*0*0*0-0+9', '1*0-0*0-0*0*0*0*0+9', '1*0-0*0*0+0+0+0+0+9', '1*0-0*0*0+0+0+0-0+9', '1*0-0*0*0+0+0+0*0+9', '1*0-0*0*0+0+0-0+0+9', '1*0-0*0*0+0+0-0-0+9', '1*0-0*0*0+0+0-0*0+9', '1*0-0*0*0+0+0*0+0+9', '1*0-0*0*0+0+0*0-0+9', '1*0-0*0*0+0+0*0*0+9', '1*0-0*0*0+0-0+0+0+9', '1*0-0*0*0+0-0+0-0+9', '1*0-0*0*0+0-0+0*0+9', '1*0-0*0*0+0-0-0+0+9', '1*0-0*0*0+0-0-0-0+9', '1*0-0*0*0+0-0-0*0+9', '1*0-0*0*0+0-0*0+0+9', '1*0-0*0*0+0-0*0-0+9', '1*0-0*0*0+0-0*0*0+9', '1*0-0*0*0+0*0+0+0+9', '1*0-0*0*0+0*0+0-0+9', '1*0-0*0*0+0*0+0*0+9', '1*0-0*0*0+0*0-0+0+9', '1*0-0*0*0+0*0-0-0+9', '1*0-0*0*0+0*0-0*0+9', '1*0-0*0*0+0*0*0+0+9', '1*0-0*0*0+0*0*0-0+9', '1*0-0*0*0+0*0*0*0+9', '1*0-0*0*0-0+0+0+0+9', '1*0-0*0*0-0+0+0-0+9', '1*0-0*0*0-0+0+0*0+9', '1*0-0*0*0-0+0-0+0+9', '1*0-0*0*0-0+0-0-0+9', '1*0-0*0*0-0+0-0*0+9', '1*0-0*0*0-0+0*0+0+9', '1*0-0*0*0-0+0*0-0+9', '1*0-0*0*0-0+0*0*0+9', '1*0-0*0*0-0-0+0+0+9', '1*0-0*0*0-0-0+0-0+9', '1*0-0*0*0-0-0+0*0+9', '1*0-0*0*0-0-0-0+0+9', '1*0-0*0*0-0-0-0-0+9', '1*0-0*0*0-0-0-0*0+9', '1*0-0*0*0-0-0*0+0+9', '1*0-0*0*0-0-0*0-0+9', '1*0-0*0*0-0-0*0*0+9', '1*0-0*0*0-0*0+0+0+9', '1*0-0*0*0-0*0+0-0+9', '1*0-0*0*0-0*0+0*0+9', '1*0-0*0*0-0*0-0+0+9', '1*0-0*0*0-0*0-0-0+9', '1*0-0*0*0-0*0-0*0+9', '1*0-0*0*0-0*0*0+0+9', '1*0-0*0*0-0*0*0-0+9', '1*0-0*0*0-0*0*0*0+9', '1*0-0*0*0*0+0+0+0+9', '1*0-0*0*0*0+0+0-0+9', '1*0-0*0*0*0+0+0*0+9', '1*0-0*0*0*0+0-0+0+9', '1*0-0*0*0*0+0-0-0+9', '1*0-0*0*0*0+0-0*0+9', '1*0-0*0*0*0+0*0+0+9', '1*0-0*0*0*0+0*0-0+9', '1*0-0*0*0*0+0*0*0+9', '1*0-0*0*0*0-0+0+0+9', '1*0-0*0*0*0-0+0-0+9', '1*0-0*0*0*0-0+0*0+9', '1*0-0*0*0*0-0-0+0+9', '1*0-0*0*0*0-0-0-0+9', '1*0-0*0*0*0-0-0*0+9', '1*0-0*0*0*0-0*0+0+9', '1*0-0*0*0*0-0*0-0+9', '1*0-0*0*0*0-0*0*0+9', '1*0-0*0*0*0*0+0+0+9', '1*0-0*0*0*0*0+0-0+9', '1*0-0*0*0*0*0+0*0+9', '1*0-0*0*0*0*0-0+0+9', '1*0-0*0*0*0*0-0-0+9', '1*0-0*0*0*0*0-0*0+9', '1*0-0*0*0*0*0*0+0+9', '1*0-0*0*0*0*0*0-0+9', '1*0-0*0*0*0*0*0*0+9', '1*0*0+0+0+0+0+0+0+9', '1*0*0+0+0+0+0+0-0+9', '1*0*0+0+0+0+0+0*0+9', '1*0*0+0+0+0+0-0+0+9', '1*0*0+0+0+0+0-0-0+9', '1*0*0+0+0+0+0-0*0+9', '1*0*0+0+0+0+0*0+0+9', '1*0*0+0+0+0+0*0-0+9', '1*0*0+0+0+0+0*0*0+9', '1*0*0+0+0+0-0+0+0+9', '1*0*0+0+0+0-0+0-0+9', '1*0*0+0+0+0-0+0*0+9', '1*0*0+0+0+0-0-0+0+9', '1*0*0+0+0+0-0-0-0+9', '1*0*0+0+0+0-0-0*0+9', '1*0*0+0+0+0-0*0+0+9', '1*0*0+0+0+0-0*0-0+9', '1*0*0+0+0+0-0*0*0+9', '1*0*0+0+0+0*0+0+0+9', '1*0*0+0+0+0*0+0-0+9', '1*0*0+0+0+0*0+0*0+9', '1*0*0+0+0+0*0-0+0+9', '1*0*0+0+0+0*0-0-0+9', '1*0*0+0+0+0*0-0*0+9', '1*0*0+0+0+0*0*0+0+9', '1*0*0+0+0+0*0*0-0+9', '1*0*0+0+0+0*0*0*0+9', '1*0*0+0+0-0+0+0+0+9', '1*0*0+0+0-0+0+0-0+9', '1*0*0+0+0-0+0+0*0+9', '1*0*0+0+0-0+0-0+0+9', '1*0*0+0+0-0+0-0-0+9', '1*0*0+0+0-0+0-0*0+9', '1*0*0+0+0-0+0*0+0+9', '1*0*0+0+0-0+0*0-0+9', '1*0*0+0+0-0+0*0*0+9', '1*0*0+0+0-0-0+0+0+9', '1*0*0+0+0-0-0+0-0+9', '1*0*0+0+0-0-0+0*0+9', '1*0*0+0+0-0-0-0+0+9', '1*0*0+0+0-0-0-0-0+9', '1*0*0+0+0-0-0-0*0+9', '1*0*0+0+0-0-0*0+0+9', '1*0*0+0+0-0-0*0-0+9', '1*0*0+0+0-0-0*0*0+9', '1*0*0+0+0-0*0+0+0+9', '1*0*0+0+0-0*0+0-0+9', '1*0*0+0+0-0*0+0*0+9', '1*0*0+0+0-0*0-0+0+9', '1*0*0+0+0-0*0-0-0+9', '1*0*0+0+0-0*0-0*0+9', '1*0*0+0+0-0*0*0+0+9', '1*0*0+0+0-0*0*0-0+9', '1*0*0+0+0-0*0*0*0+9', '1*0*0+0+0*0+0+0+0+9', '1*0*0+0+0*0+0+0-0+9', '1*0*0+0+0*0+0+0*0+9', '1*0*0+0+0*0+0-0+0+9', '1*0*0+0+0*0+0-0-0+9', '1*0*0+0+0*0+0-0*0+9', '1*0*0+0+0*0+0*0+0+9', '1*0*0+0+0*0+0*0-0+9', '1*0*0+0+0*0+0*0*0+9', '1*0*0+0+0*0-0+0+0+9', '1*0*0+0+0*0-0+0-0+9', '1*0*0+0+0*0-0+0*0+9', '1*0*0+0+0*0-0-0+0+9', '1*0*0+0+0*0-0-0-0+9', '1*0*0+0+0*0-0-0*0+9', '1*0*0+0+0*0-0*0+0+9', '1*0*0+0+0*0-0*0-0+9', '1*0*0+0+0*0-0*0*0+9', '1*0*0+0+0*0*0+0+0+9', '1*0*0+0+0*0*0+0-0+9', '1*0*0+0+0*0*0+0*0+9', '1*0*0+0+0*0*0-0+0+9', '1*0*0+0+0*0*0-0-0+9', '1*0*0+0+0*0*0-0*0+9', '1*0*0+0+0*0*0*0+0+9', '1*0*0+0+0*0*0*0-0+9', '1*0*0+0+0*0*0*0*0+9', '1*0*0+0-0+0+0+0+0+9', '1*0*0+0-0+0+0+0-0+9', '1*0*0+0-0+0+0+0*0+9', '1*0*0+0-0+0+0-0+0+9', '1*0*0+0-0+0+0-0-0+9', '1*0*0+0-0+0+0-0*0+9', '1*0*0+0-0+0+0*0+0+9', '1*0*0+0-0+0+0*0-0+9', '1*0*0+0-0+0+0*0*0+9', '1*0*0+0-0+0-0+0+0+9', '1*0*0+0-0+0-0+0-0+9', '1*0*0+0-0+0-0+0*0+9', '1*0*0+0-0+0-0-0+0+9', '1*0*0+0-0+0-0-0-0+9', '1*0*0+0-0+0-0-0*0+9', '1*0*0+0-0+0-0*0+0+9', '1*0*0+0-0+0-0*0-0+9', '1*0*0+0-0+0-0*0*0+9', '1*0*0+0-0+0*0+0+0+9', '1*0*0+0-0+0*0+0-0+9', '1*0*0+0-0+0*0+0*0+9', '1*0*0+0-0+0*0-0+0+9', '1*0*0+0-0+0*0-0-0+9', '1*0*0+0-0+0*0-0*0+9', '1*0*0+0-0+0*0*0+0+9', '1*0*0+0-0+0*0*0-0+9', '1*0*0+0-0+0*0*0*0+9', '1*0*0+0-0-0+0+0+0+9', '1*0*0+0-0-0+0+0-0+9', '1*0*0+0-0-0+0+0*0+9', '1*0*0+0-0-0+0-0+0+9', '1*0*0+0-0-0+0-0-0+9', '1*0*0+0-0-0+0-0*0+9', '1*0*0+0-0-0+0*0+0+9', '1*0*0+0-0-0+0*0-0+9', '1*0*0+0-0-0+0*0*0+9', '1*0*0+0-0-0-0+0+0+9', '1*0*0+0-0-0-0+0-0+9', '1*0*0+0-0-0-0+0*0+9', '1*0*0+0-0-0-0-0+0+9', '1*0*0+0-0-0-0-0-0+9', '1*0*0+0-0-0-0-0*0+9', '1*0*0+0-0-0-0*0+0+9', '1*0*0+0-0-0-0*0-0+9', '1*0*0+0-0-0-0*0*0+9', '1*0*0+0-0-0*0+0+0+9', '1*0*0+0-0-0*0+0-0+9', '1*0*0+0-0-0*0+0*0+9', '1*0*0+0-0-0*0-0+0+9', '1*0*0+0-0-0*0-0-0+9', '1*0*0+0-0-0*0-0*0+9', '1*0*0+0-0-0*0*0+0+9', '1*0*0+0-0-0*0*0-0+9', '1*0*0+0-0-0*0*0*0+9', '1*0*0+0-0*0+0+0+0+9', '1*0*0+0-0*0+0+0-0+9', '1*0*0+0-0*0+0+0*0+9', '1*0*0+0-0*0+0-0+0+9', '1*0*0+0-0*0+0-0-0+9', '1*0*0+0-0*0+0-0*0+9', '1*0*0+0-0*0+0*0+0+9', '1*0*0+0-0*0+0*0-0+9', '1*0*0+0-0*0+0*0*0+9', '1*0*0+0-0*0-0+0+0+9', '1*0*0+0-0*0-0+0-0+9', '1*0*0+0-0*0-0+0*0+9', '1*0*0+0-0*0-0-0+0+9', '1*0*0+0-0*0-0-0-0+9', '1*0*0+0-0*0-0-0*0+9', '1*0*0+0-0*0-0*0+0+9', '1*0*0+0-0*0-0*0-0+9', '1*0*0+0-0*0-0*0*0+9', '1*0*0+0-0*0*0+0+0+9', '1*0*0+0-0*0*0+0-0+9', '1*0*0+0-0*0*0+0*0+9', '1*0*0+0-0*0*0-0+0+9', '1*0*0+0-0*0*0-0-0+9', '1*0*0+0-0*0*0-0*0+9', '1*0*0+0-0*0*0*0+0+9', '1*0*0+0-0*0*0*0-0+9', '1*0*0+0-0*0*0*0*0+9', '1*0*0+0*0+0+0+0+0+9', '1*0*0+0*0+0+0+0-0+9', '1*0*0+0*0+0+0+0*0+9', '1*0*0+0*0+0+0-0+0+9', '1*0*0+0*0+0+0-0-0+9', '1*0*0+0*0+0+0-0*0+9', '1*0*0+0*0+0+0*0+0+9', '1*0*0+0*0+0+0*0-0+9', '1*0*0+0*0+0+0*0*0+9', '1*0*0+0*0+0-0+0+0+9', '1*0*0+0*0+0-0+0-0+9', '1*0*0+0*0+0-0+0*0+9', '1*0*0+0*0+0-0-0+0+9', '1*0*0+0*0+0-0-0-0+9', '1*0*0+0*0+0-0-0*0+9', '1*0*0+0*0+0-0*0+0+9', '1*0*0+0*0+0-0*0-0+9', '1*0*0+0*0+0-0*0*0+9', '1*0*0+0*0+0*0+0+0+9', '1*0*0+0*0+0*0+0-0+9', '1*0*0+0*0+0*0+0*0+9', '1*0*0+0*0+0*0-0+0+9', '1*0*0+0*0+0*0-0-0+9', '1*0*0+0*0+0*0-0*0+9', '1*0*0+0*0+0*0*0+0+9', '1*0*0+0*0+0*0*0-0+9', '1*0*0+0*0+0*0*0*0+9', '1*0*0+0*0-0+0+0+0+9', '1*0*0+0*0-0+0+0-0+9', '1*0*0+0*0-0+0+0*0+9', '1*0*0+0*0-0+0-0+0+9', '1*0*0+0*0-0+0-0-0+9', '1*0*0+0*0-0+0-0*0+9', '1*0*0+0*0-0+0*0+0+9', '1*0*0+0*0-0+0*0-0+9', '1*0*0+0*0-0+0*0*0+9', '1*0*0+0*0-0-0+0+0+9', '1*0*0+0*0-0-0+0-0+9', '1*0*0+0*0-0-0+0*0+9', '1*0*0+0*0-0-0-0+0+9', '1*0*0+0*0-0-0-0-0+9', '1*0*0+0*0-0-0-0*0+9', '1*0*0+0*0-0-0*0+0+9', '1*0*0+0*0-0-0*0-0+9', '1*0*0+0*0-0-0*0*0+9', '1*0*0+0*0-0*0+0+0+9', '1*0*0+0*0-0*0+0-0+9', '1*0*0+0*0-0*0+0*0+9', '1*0*0+0*0-0*0-0+0+9', '1*0*0+0*0-0*0-0-0+9', '1*0*0+0*0-0*0-0*0+9', '1*0*0+0*0-0*0*0+0+9', '1*0*0+0*0-0*0*0-0+9', '1*0*0+0*0-0*0*0*0+9', '1*0*0+0*0*0+0+0+0+9', '1*0*0+0*0*0+0+0-0+9', '1*0*0+0*0*0+0+0*0+9', '1*0*0+0*0*0+0-0+0+9', '1*0*0+0*0*0+0-0-0+9', '1*0*0+0*0*0+0-0*0+9', '1*0*0+0*0*0+0*0+0+9', '1*0*0+0*0*0+0*0-0+9', '1*0*0+0*0*0+0*0*0+9', '1*0*0+0*0*0-0+0+0+9', '1*0*0+0*0*0-0+0-0+9', '1*0*0+0*0*0-0+0*0+9', '1*0*0+0*0*0-0-0+0+9', '1*0*0+0*0*0-0-0-0+9', '1*0*0+0*0*0-0-0*0+9', '1*0*0+0*0*0-0*0+0+9', '1*0*0+0*0*0-0*0-0+9', '1*0*0+0*0*0-0*0*0+9', '1*0*0+0*0*0*0+0+0+9', '1*0*0+0*0*0*0+0-0+9', '1*0*0+0*0*0*0+0*0+9', '1*0*0+0*0*0*0-0+0+9', '1*0*0+0*0*0*0-0-0+9', '1*0*0+0*0*0*0-0*0+9', '1*0*0+0*0*0*0*0+0+9', '1*0*0+0*0*0*0*0-0+9', '1*0*0+0*0*0*0*0*0+9', '1*0*0-0+0+0+0+0+0+9', '1*0*0-0+0+0+0+0-0+9', '1*0*0-0+0+0+0+0*0+9', '1*0*0-0+0+0+0-0+0+9', '1*0*0-0+0+0+0-0-0+9', '1*0*0-0+0+0+0-0*0+9', '1*0*0-0+0+0+0*0+0+9', '1*0*0-0+0+0+0*0-0+9', '1*0*0-0+0+0+0*0*0+9', '1*0*0-0+0+0-0+0+0+9', '1*0*0-0+0+0-0+0-0+9', '1*0*0-0+0+0-0+0*0+9', '1*0*0-0+0+0-0-0+0+9', '1*0*0-0+0+0-0-0-0+9', '1*0*0-0+0+0-0-0*0+9', '1*0*0-0+0+0-0*0+0+9', '1*0*0-0+0+0-0*0-0+9', '1*0*0-0+0+0-0*0*0+9', '1*0*0-0+0+0*0+0+0+9', '1*0*0-0+0+0*0+0-0+9', '1*0*0-0+0+0*0+0*0+9', '1*0*0-0+0+0*0-0+0+9', '1*0*0-0+0+0*0-0-0+9', '1*0*0-0+0+0*0-0*0+9', '1*0*0-0+0+0*0*0+0+9', '1*0*0-0+0+0*0*0-0+9', '1*0*0-0+0+0*0*0*0+9', '1*0*0-0+0-0+0+0+0+9', '1*0*0-0+0-0+0+0-0+9', '1*0*0-0+0-0+0+0*0+9', '1*0*0-0+0-0+0-0+0+9', '1*0*0-0+0-0+0-0-0+9', '1*0*0-0+0-0+0-0*0+9', '1*0*0-0+0-0+0*0+0+9', '1*0*0-0+0-0+0*0-0+9', '1*0*0-0+0-0+0*0*0+9', '1*0*0-0+0-0-0+0+0+9', '1*0*0-0+0-0-0+0-0+9', '1*0*0-0+0-0-0+0*0+9', '1*0*0-0+0-0-0-0+0+9', '1*0*0-0+0-0-0-0-0+9', '1*0*0-0+0-0-0-0*0+9', '1*0*0-0+0-0-0*0+0+9', '1*0*0-0+0-0-0*0-0+9', '1*0*0-0+0-0-0*0*0+9', '1*0*0-0+0-0*0+0+0+9', '1*0*0-0+0-0*0+0-0+9', '1*0*0-0+0-0*0+0*0+9', '1*0*0-0+0-0*0-0+0+9', '1*0*0-0+0-0*0-0-0+9', '1*0*0-0+0-0*0-0*0+9', '1*0*0-0+0-0*0*0+0+9', '1*0*0-0+0-0*0*0-0+9', '1*0*0-0+0-0*0*0*0+9', '1*0*0-0+0*0+0+0+0+9', '1*0*0-0+0*0+0+0-0+9', '1*0*0-0+0*0+0+0*0+9', '1*0*0-0+0*0+0-0+0+9', '1*0*0-0+0*0+0-0-0+9', '1*0*0-0+0*0+0-0*0+9', '1*0*0-0+0*0+0*0+0+9', '1*0*0-0+0*0+0*0-0+9', '1*0*0-0+0*0+0*0*0+9', '1*0*0-0+0*0-0+0+0+9', '1*0*0-0+0*0-0+0-0+9', '1*0*0-0+0*0-0+0*0+9', '1*0*0-0+0*0-0-0+0+9', '1*0*0-0+0*0-0-0-0+9', '1*0*0-0+0*0-0-0*0+9', '1*0*0-0+0*0-0*0+0+9', '1*0*0-0+0*0-0*0-0+9', '1*0*0-0+0*0-0*0*0+9', '1*0*0-0+0*0*0+0+0+9', '1*0*0-0+0*0*0+0-0+9', '1*0*0-0+0*0*0+0*0+9', '1*0*0-0+0*0*0-0+0+9', '1*0*0-0+0*0*0-0-0+9', '1*0*0-0+0*0*0-0*0+9', '1*0*0-0+0*0*0*0+0+9', '1*0*0-0+0*0*0*0-0+9', '1*0*0-0+0*0*0*0*0+9', '1*0*0-0-0+0+0+0+0+9', '1*0*0-0-0+0+0+0-0+9', '1*0*0-0-0+0+0+0*0+9', '1*0*0-0-0+0+0-0+0+9', '1*0*0-0-0+0+0-0-0+9', '1*0*0-0-0+0+0-0*0+9', '1*0*0-0-0+0+0*0+0+9', '1*0*0-0-0+0+0*0-0+9', '1*0*0-0-0+0+0*0*0+9', '1*0*0-0-0+0-0+0+0+9', '1*0*0-0-0+0-0+0-0+9', '1*0*0-0-0+0-0+0*0+9', '1*0*0-0-0+0-0-0+0+9', '1*0*0-0-0+0-0-0-0+9', '1*0*0-0-0+0-0-0*0+9', '1*0*0-0-0+0-0*0+0+9', '1*0*0-0-0+0-0*0-0+9', '1*0*0-0-0+0-0*0*0+9', '1*0*0-0-0+0*0+0+0+9', '1*0*0-0-0+0*0+0-0+9', '1*0*0-0-0+0*0+0*0+9', '1*0*0-0-0+0*0-0+0+9', '1*0*0-0-0+0*0-0-0+9', '1*0*0-0-0+0*0-0*0+9', '1*0*0-0-0+0*0*0+0+9', '1*0*0-0-0+0*0*0-0+9', '1*0*0-0-0+0*0*0*0+9', '1*0*0-0-0-0+0+0+0+9', '1*0*0-0-0-0+0+0-0+9', '1*0*0-0-0-0+0+0*0+9', '1*0*0-0-0-0+0-0+0+9', '1*0*0-0-0-0+0-0-0+9', '1*0*0-0-0-0+0-0*0+9', '1*0*0-0-0-0+0*0+0+9', '1*0*0-0-0-0+0*0-0+9', '1*0*0-0-0-0+0*0*0+9', '1*0*0-0-0-0-0+0+0+9', '1*0*0-0-0-0-0+0-0+9', '1*0*0-0-0-0-0+0*0+9', '1*0*0-0-0-0-0-0+0+9', '1*0*0-0-0-0-0-0-0+9', '1*0*0-0-0-0-0-0*0+9', '1*0*0-0-0-0-0*0+0+9', '1*0*0-0-0-0-0*0-0+9', '1*0*0-0-0-0-0*0*0+9', '1*0*0-0-0-0*0+0+0+9', '1*0*0-0-0-0*0+0-0+9', '1*0*0-0-0-0*0+0*0+9', '1*0*0-0-0-0*0-0+0+9', '1*0*0-0-0-0*0-0-0+9', '1*0*0-0-0-0*0-0*0+9', '1*0*0-0-0-0*0*0+0+9', '1*0*0-0-0-0*0*0-0+9', '1*0*0-0-0-0*0*0*0+9', '1*0*0-0-0*0+0+0+0+9', '1*0*0-0-0*0+0+0-0+9', '1*0*0-0-0*0+0+0*0+9', '1*0*0-0-0*0+0-0+0+9', '1*0*0-0-0*0+0-0-0+9', '1*0*0-0-0*0+0-0*0+9', '1*0*0-0-0*0+0*0+0+9', '1*0*0-0-0*0+0*0-0+9', '1*0*0-0-0*0+0*0*0+9', '1*0*0-0-0*0-0+0+0+9', '1*0*0-0-0*0-0+0-0+9', '1*0*0-0-0*0-0+0*0+9', '1*0*0-0-0*0-0-0+0+9', '1*0*0-0-0*0-0-0-0+9', '1*0*0-0-0*0-0-0*0+9', '1*0*0-0-0*0-0*0+0+9', '1*0*0-0-0*0-0*0-0+9', '1*0*0-0-0*0-0*0*0+9', '1*0*0-0-0*0*0+0+0+9', '1*0*0-0-0*0*0+0-0+9', '1*0*0-0-0*0*0+0*0+9', '1*0*0-0-0*0*0-0+0+9', '1*0*0-0-0*0*0-0-0+9', '1*0*0-0-0*0*0-0*0+9', '1*0*0-0-0*0*0*0+0+9', '1*0*0-0-0*0*0*0-0+9', '1*0*0-0-0*0*0*0*0+9', '1*0*0-0*0+0+0+0+0+9', '1*0*0-0*0+0+0+0-0+9', '1*0*0-0*0+0+0+0*0+9', '1*0*0-0*0+0+0-0+0+9', '1*0*0-0*0+0+0-0-0+9', '1*0*0-0*0+0+0-0*0+9', '1*0*0-0*0+0+0*0+0+9', '1*0*0-0*0+0+0*0-0+9', '1*0*0-0*0+0+0*0*0+9', '1*0*0-0*0+0-0+0+0+9', '1*0*0-0*0+0-0+0-0+9', '1*0*0-0*0+0-0+0*0+9', '1*0*0-0*0+0-0-0+0+9', '1*0*0-0*0+0-0-0-0+9', '1*0*0-0*0+0-0-0*0+9', '1*0*0-0*0+0-0*0+0+9', '1*0*0-0*0+0-0*0-0+9', '1*0*0-0*0+0-0*0*0+9', '1*0*0-0*0+0*0+0+0+9', '1*0*0-0*0+0*0+0-0+9', '1*0*0-0*0+0*0+0*0+9', '1*0*0-0*0+0*0-0+0+9', '1*0*0-0*0+0*0-0-0+9', '1*0*0-0*0+0*0-0*0+9', '1*0*0-0*0+0*0*0+0+9', '1*0*0-0*0+0*0*0-0+9', '1*0*0-0*0+0*0*0*0+9', '1*0*0-0*0-0+0+0+0+9', '1*0*0-0*0-0+0+0-0+9', '1*0*0-0*0-0+0+0*0+9', '1*0*0-0*0-0+0-0+0+9', '1*0*0-0*0-0+0-0-0+9', '1*0*0-0*0-0+0-0*0+9', '1*0*0-0*0-0+0*0+0+9', '1*0*0-0*0-0+0*0-0+9', '1*0*0-0*0-0+0*0*0+9', '1*0*0-0*0-0-0+0+0+9', '1*0*0-0*0-0-0+0-0+9', '1*0*0-0*0-0-0+0*0+9', '1*0*0-0*0-0-0-0+0+9', '1*0*0-0*0-0-0-0-0+9', '1*0*0-0*0-0-0-0*0+9', '1*0*0-0*0-0-0*0+0+9', '1*0*0-0*0-0-0*0-0+9', '1*0*0-0*0-0-0*0*0+9', '1*0*0-0*0-0*0+0+0+9', '1*0*0-0*0-0*0+0-0+9', '1*0*0-0*0-0*0+0*0+9', '1*0*0-0*0-0*0-0+0+9', '1*0*0-0*0-0*0-0-0+9', '1*0*0-0*0-0*0-0*0+9', '1*0*0-0*0-0*0*0+0+9', '1*0*0-0*0-0*0*0-0+9', '1*0*0-0*0-0*0*0*0+9', '1*0*0-0*0*0+0+0+0+9', '1*0*0-0*0*0+0+0-0+9', '1*0*0-0*0*0+0+0*0+9', '1*0*0-0*0*0+0-0+0+9', '1*0*0-0*0*0+0-0-0+9', '1*0*0-0*0*0+0-0*0+9', '1*0*0-0*0*0+0*0+0+9', '1*0*0-0*0*0+0*0-0+9', '1*0*0-0*0*0+0*0*0+9', '1*0*0-0*0*0-0+0+0+9', '1*0*0-0*0*0-0+0-0+9', '1*0*0-0*0*0-0+0*0+9', '1*0*0-0*0*0-0-0+0+9', '1*0*0-0*0*0-0-0-0+9', '1*0*0-0*0*0-0-0*0+9', '1*0*0-0*0*0-0*0+0+9', '1*0*0-0*0*0-0*0-0+9', '1*0*0-0*0*0-0*0*0+9', '1*0*0-0*0*0*0+0+0+9', '1*0*0-0*0*0*0+0-0+9', '1*0*0-0*0*0*0+0*0+9', '1*0*0-0*0*0*0-0+0+9', '1*0*0-0*0*0*0-0-0+9', '1*0*0-0*0*0*0-0*0+9', '1*0*0-0*0*0*0*0+0+9', '1*0*0-0*0*0*0*0-0+9', '1*0*0-0*0*0*0*0*0+9', '1*0*0*0+0+0+0+0+0+9', '1*0*0*0+0+0+0+0-0+9', '1*0*0*0+0+0+0+0*0+9', '1*0*0*0+0+0+0-0+0+9', '1*0*0*0+0+0+0-0-0+9', '1*0*0*0+0+0+0-0*0+9', '1*0*0*0+0+0+0*0+0+9', '1*0*0*0+0+0+0*0-0+9', '1*0*0*0+0+0+0*0*0+9', '1*0*0*0+0+0-0+0+0+9', '1*0*0*0+0+0-0+0-0+9', '1*0*0*0+0+0-0+0*0+9', '1*0*0*0+0+0-0-0+0+9', '1*0*0*0+0+0-0-0-0+9', '1*0*0*0+0+0-0-0*0+9', '1*0*0*0+0+0-0*0+0+9', '1*0*0*0+0+0-0*0-0+9', '1*0*0*0+0+0-0*0*0+9', '1*0*0*0+0+0*0+0+0+9', '1*0*0*0+0+0*0+0-0+9', '1*0*0*0+0+0*0+0*0+9', '1*0*0*0+0+0*0-0+0+9', '1*0*0*0+0+0*0-0-0+9', '1*0*0*0+0+0*0-0*0+9', '1*0*0*0+0+0*0*0+0+9', '1*0*0*0+0+0*0*0-0+9', '1*0*0*0+0+0*0*0*0+9', '1*0*0*0+0-0+0+0+0+9', '1*0*0*0+0-0+0+0-0+9', '1*0*0*0+0-0+0+0*0+9', '1*0*0*0+0-0+0-0+0+9', '1*0*0*0+0-0+0-0-0+9', '1*0*0*0+0-0+0-0*0+9', '1*0*0*0+0-0+0*0+0+9', '1*0*0*0+0-0+0*0-0+9', '1*0*0*0+0-0+0*0*0+9', '1*0*0*0+0-0-0+0+0+9', '1*0*0*0+0-0-0+0-0+9', '1*0*0*0+0-0-0+0*0+9', '1*0*0*0+0-0-0-0+0+9', '1*0*0*0+0-0-0-0-0+9', '1*0*0*0+0-0-0-0*0+9', '1*0*0*0+0-0-0*0+0+9', '1*0*0*0+0-0-0*0-0+9', '1*0*0*0+0-0-0*0*0+9', '1*0*0*0+0-0*0+0+0+9', '1*0*0*0+0-0*0+0-0+9', '1*0*0*0+0-0*0+0*0+9', '1*0*0*0+0-0*0-0+0+9', '1*0*0*0+0-0*0-0-0+9', '1*0*0*0+0-0*0-0*0+9', '1*0*0*0+0-0*0*0+0+9', '1*0*0*0+0-0*0*0-0+9', '1*0*0*0+0-0*0*0*0+9', '1*0*0*0+0*0+0+0+0+9', '1*0*0*0+0*0+0+0-0+9', '1*0*0*0+0*0+0+0*0+9', '1*0*0*0+0*0+0-0+0+9', '1*0*0*0+0*0+0-0-0+9', '1*0*0*0+0*0+0-0*0+9', '1*0*0*0+0*0+0*0+0+9', '1*0*0*0+0*0+0*0-0+9', '1*0*0*0+0*0+0*0*0+9', '1*0*0*0+0*0-0+0+0+9', '1*0*0*0+0*0-0+0-0+9', '1*0*0*0+0*0-0+0*0+9', '1*0*0*0+0*0-0-0+0+9', '1*0*0*0+0*0-0-0-0+9', '1*0*0*0+0*0-0-0*0+9', '1*0*0*0+0*0-0*0+0+9', '1*0*0*0+0*0-0*0-0+9', '1*0*0*0+0*0-0*0*0+9', '1*0*0*0+0*0*0+0+0+9', '1*0*0*0+0*0*0+0-0+9', '1*0*0*0+0*0*0+0*0+9', '1*0*0*0+0*0*0-0+0+9', '1*0*0*0+0*0*0-0-0+9', '1*0*0*0+0*0*0-0*0+9', '1*0*0*0+0*0*0*0+0+9', '1*0*0*0+0*0*0*0-0+9', '1*0*0*0+0*0*0*0*0+9', '1*0*0*0-0+0+0+0+0+9', '1*0*0*0-0+0+0+0-0+9', '1*0*0*0-0+0+0+0*0+9', '1*0*0*0-0+0+0-0+0+9', '1*0*0*0-0+0+0-0-0+9', '1*0*0*0-0+0+0-0*0+9', '1*0*0*0-0+0+0*0+0+9', '1*0*0*0-0+0+0*0-0+9', '1*0*0*0-0+0+0*0*0+9', '1*0*0*0-0+0-0+0+0+9', '1*0*0*0-0+0-0+0-0+9', '1*0*0*0-0+0-0+0*0+9', '1*0*0*0-0+0-0-0+0+9', '1*0*0*0-0+0-0-0-0+9', '1*0*0*0-0+0-0-0*0+9', '1*0*0*0-0+0-0*0+0+9', '1*0*0*0-0+0-0*0-0+9', '1*0*0*0-0+0-0*0*0+9', '1*0*0*0-0+0*0+0+0+9', '1*0*0*0-0+0*0+0-0+9', '1*0*0*0-0+0*0+0*0+9', '1*0*0*0-0+0*0-0+0+9', '1*0*0*0-0+0*0-0-0+9', '1*0*0*0-0+0*0-0*0+9', '1*0*0*0-0+0*0*0+0+9', '1*0*0*0-0+0*0*0-0+9', '1*0*0*0-0+0*0*0*0+9', '1*0*0*0-0-0+0+0+0+9', '1*0*0*0-0-0+0+0-0+9', '1*0*0*0-0-0+0+0*0+9', '1*0*0*0-0-0+0-0+0+9', '1*0*0*0-0-0+0-0-0+9', '1*0*0*0-0-0+0-0*0+9', '1*0*0*0-0-0+0*0+0+9', '1*0*0*0-0-0+0*0-0+9', '1*0*0*0-0-0+0*0*0+9', '1*0*0*0-0-0-0+0+0+9', '1*0*0*0-0-0-0+0-0+9', '1*0*0*0-0-0-0+0*0+9', '1*0*0*0-0-0-0-0+0+9', '1*0*0*0-0-0-0-0-0+9', '1*0*0*0-0-0-0-0*0+9', '1*0*0*0-0-0-0*0+0+9', '1*0*0*0-0-0-0*0-0+9', '1*0*0*0-0-0-0*0*0+9', '1*0*0*0-0-0*0+0+0+9', '1*0*0*0-0-0*0+0-0+9', '1*0*0*0-0-0*0+0*0+9', '1*0*0*0-0-0*0-0+0+9', '1*0*0*0-0-0*0-0-0+9', '1*0*0*0-0-0*0-0*0+9', '1*0*0*0-0-0*0*0+0+9', '1*0*0*0-0-0*0*0-0+9', '1*0*0*0-0-0*0*0*0+9', '1*0*0*0-0*0+0+0+0+9', '1*0*0*0-0*0+0+0-0+9', '1*0*0*0-0*0+0+0*0+9', '1*0*0*0-0*0+0-0+0+9', '1*0*0*0-0*0+0-0-0+9', '1*0*0*0-0*0+0-0*0+9', '1*0*0*0-0*0+0*0+0+9', '1*0*0*0-0*0+0*0-0+9', '1*0*0*0-0*0+0*0*0+9', '1*0*0*0-0*0-0+0+0+9', '1*0*0*0-0*0-0+0-0+9', '1*0*0*0-0*0-0+0*0+9', '1*0*0*0-0*0-0-0+0+9', '1*0*0*0-0*0-0-0-0+9', '1*0*0*0-0*0-0-0*0+9', '1*0*0*0-0*0-0*0+0+9', '1*0*0*0-0*0-0*0-0+9', '1*0*0*0-0*0-0*0*0+9', '1*0*0*0-0*0*0+0+0+9', '1*0*0*0-0*0*0+0-0+9', '1*0*0*0-0*0*0+0*0+9', '1*0*0*0-0*0*0-0+0+9', '1*0*0*0-0*0*0-0-0+9', '1*0*0*0-0*0*0-0*0+9', '1*0*0*0-0*0*0*0+0+9', '1*0*0*0-0*0*0*0-0+9', '1*0*0*0-0*0*0*0*0+9', '1*0*0*0*0+0+0+0+0+9', '1*0*0*0*0+0+0+0-0+9', '1*0*0*0*0+0+0+0*0+9', '1*0*0*0*0+0+0-0+0+9', '1*0*0*0*0+0+0-0-0+9', '1*0*0*0*0+0+0-0*0+9', '1*0*0*0*0+0+0*0+0+9', '1*0*0*0*0+0+0*0-0+9', '1*0*0*0*0+0+0*0*0+9', '1*0*0*0*0+0-0+0+0+9', '1*0*0*0*0+0-0+0-0+9', '1*0*0*0*0+0-0+0*0+9', '1*0*0*0*0+0-0-0+0+9', '1*0*0*0*0+0-0-0-0+9', '1*0*0*0*0+0-0-0*0+9', '1*0*0*0*0+0-0*0+0+9', '1*0*0*0*0+0-0*0-0+9', '1*0*0*0*0+0-0*0*0+9', '1*0*0*0*0+0*0+0+0+9', '1*0*0*0*0+0*0+0-0+9', '1*0*0*0*0+0*0+0*0+9', '1*0*0*0*0+0*0-0+0+9', '1*0*0*0*0+0*0-0-0+9', '1*0*0*0*0+0*0-0*0+9', '1*0*0*0*0+0*0*0+0+9', '1*0*0*0*0+0*0*0-0+9', '1*0*0*0*0+0*0*0*0+9', '1*0*0*0*0-0+0+0+0+9', '1*0*0*0*0-0+0+0-0+9', '1*0*0*0*0-0+0+0*0+9', '1*0*0*0*0-0+0-0+0+9', '1*0*0*0*0-0+0-0-0+9', '1*0*0*0*0-0+0-0*0+9', '1*0*0*0*0-0+0*0+0+9', '1*0*0*0*0-0+0*0-0+9', '1*0*0*0*0-0+0*0*0+9', '1*0*0*0*0-0-0+0+0+9', '1*0*0*0*0-0-0+0-0+9', '1*0*0*0*0-0-0+0*0+9', '1*0*0*0*0-0-0-0+0+9', '1*0*0*0*0-0-0-0-0+9', '1*0*0*0*0-0-0-0*0+9', '1*0*0*0*0-0-0*0+0+9', '1*0*0*0*0-0-0*0-0+9', '1*0*0*0*0-0-0*0*0+9', '1*0*0*0*0-0*0+0+0+9', '1*0*0*0*0-0*0+0-0+9', '1*0*0*0*0-0*0+0*0+9', '1*0*0*0*0-0*0-0+0+9', '1*0*0*0*0-0*0-0-0+9', '1*0*0*0*0-0*0-0*0+9', '1*0*0*0*0-0*0*0+0+9', '1*0*0*0*0-0*0*0-0+9', '1*0*0*0*0-0*0*0*0+9', '1*0*0*0*0*0+0+0+0+9', '1*0*0*0*0*0+0+0-0+9', '1*0*0*0*0*0+0+0*0+9', '1*0*0*0*0*0+0-0+0+9', '1*0*0*0*0*0+0-0-0+9', '1*0*0*0*0*0+0-0*0+9', '1*0*0*0*0*0+0*0+0+9', '1*0*0*0*0*0+0*0-0+9', '1*0*0*0*0*0+0*0*0+9', '1*0*0*0*0*0-0+0+0+9', '1*0*0*0*0*0-0+0-0+9', '1*0*0*0*0*0-0+0*0+9', '1*0*0*0*0*0-0-0+0+9', '1*0*0*0*0*0-0-0-0+9', '1*0*0*0*0*0-0-0*0+9', '1*0*0*0*0*0-0*0+0+9', '1*0*0*0*0*0-0*0-0+9', '1*0*0*0*0*0-0*0*0+9', '1*0*0*0*0*0*0+0+0+9', '1*0*0*0*0*0*0+0-0+9', '1*0*0*0*0*0*0+0*0+9', '1*0*0*0*0*0*0-0+0+9', '1*0*0*0*0*0*0-0-0+9', '1*0*0*0*0*0*0-0*0+9', '1*0*0*0*0*0*0*0+0+9', '1*0*0*0*0*0*0*0-0+9', '1*0*0*0*0*0*0*0*0+9', '10*0+0+0+0+0+0+0+9', '10*0+0+0+0+0+0-0+9', '10*0+0+0+0+0+0*0+9', '10*0+0+0+0+0-0+0+9', '10*0+0+0+0+0-0-0+9', '10*0+0+0+0+0-0*0+9', '10*0+0+0+0+0*0+0+9', '10*0+0+0+0+0*0-0+9', '10*0+0+0+0+0*0*0+9', '10*0+0+0+0-0+0+0+9', '10*0+0+0+0-0+0-0+9', '10*0+0+0+0-0+0*0+9', '10*0+0+0+0-0-0+0+9', '10*0+0+0+0-0-0-0+9', '10*0+0+0+0-0-0*0+9', '10*0+0+0+0-0*0+0+9', '10*0+0+0+0-0*0-0+9', '10*0+0+0+0-0*0*0+9', '10*0+0+0+0*0+0+0+9', '10*0+0+0+0*0+0-0+9', '10*0+0+0+0*0+0*0+9', '10*0+0+0+0*0-0+0+9', '10*0+0+0+0*0-0-0+9', '10*0+0+0+0*0-0*0+9', '10*0+0+0+0*0*0+0+9', '10*0+0+0+0*0*0-0+9', '10*0+0+0+0*0*0*0+9', '10*0+0+0-0+0+0+0+9', '10*0+0+0-0+0+0-0+9', '10*0+0+0-0+0+0*0+9', '10*0+0+0-0+0-0+0+9', '10*0+0+0-0+0-0-0+9', '10*0+0+0-0+0-0*0+9', '10*0+0+0-0+0*0+0+9', '10*0+0+0-0+0*0-0+9', '10*0+0+0-0+0*0*0+9', '10*0+0+0-0-0+0+0+9', '10*0+0+0-0-0+0-0+9', '10*0+0+0-0-0+0*0+9', '10*0+0+0-0-0-0+0+9', '10*0+0+0-0-0-0-0+9', '10*0+0+0-0-0-0*0+9', '10*0+0+0-0-0*0+0+9', '10*0+0+0-0-0*0-0+9', '10*0+0+0-0-0*0*0+9', '10*0+0+0-0*0+0+0+9', '10*0+0+0-0*0+0-0+9', '10*0+0+0-0*0+0*0+9', '10*0+0+0-0*0-0+0+9', '10*0+0+0-0*0-0-0+9', '10*0+0+0-0*0-0*0+9', '10*0+0+0-0*0*0+0+9', '10*0+0+0-0*0*0-0+9', '10*0+0+0-0*0*0*0+9', '10*0+0+0*0+0+0+0+9', '10*0+0+0*0+0+0-0+9', '10*0+0+0*0+0+0*0+9', '10*0+0+0*0+0-0+0+9', '10*0+0+0*0+0-0-0+9', '10*0+0+0*0+0-0*0+9', '10*0+0+0*0+0*0+0+9', '10*0+0+0*0+0*0-0+9', '10*0+0+0*0+0*0*0+9', '10*0+0+0*0-0+0+0+9', '10*0+0+0*0-0+0-0+9', '10*0+0+0*0-0+0*0+9', '10*0+0+0*0-0-0+0+9', '10*0+0+0*0-0-0-0+9', '10*0+0+0*0-0-0*0+9', '10*0+0+0*0-0*0+0+9', '10*0+0+0*0-0*0-0+9', '10*0+0+0*0-0*0*0+9', '10*0+0+0*0*0+0+0+9', '10*0+0+0*0*0+0-0+9', '10*0+0+0*0*0+0*0+9', '10*0+0+0*0*0-0+0+9', '10*0+0+0*0*0-0-0+9', '10*0+0+0*0*0-0*0+9', '10*0+0+0*0*0*0+0+9', '10*0+0+0*0*0*0-0+9', '10*0+0+0*0*0*0*0+9', '10*0+0-0+0+0+0+0+9', '10*0+0-0+0+0+0-0+9', '10*0+0-0+0+0+0*0+9', '10*0+0-0+0+0-0+0+9', '10*0+0-0+0+0-0-0+9', '10*0+0-0+0+0-0*0+9', '10*0+0-0+0+0*0+0+9', '10*0+0-0+0+0*0-0+9', '10*0+0-0+0+0*0*0+9', '10*0+0-0+0-0+0+0+9', '10*0+0-0+0-0+0-0+9', '10*0+0-0+0-0+0*0+9', '10*0+0-0+0-0-0+0+9', '10*0+0-0+0-0-0-0+9', '10*0+0-0+0-0-0*0+9', '10*0+0-0+0-0*0+0+9', '10*0+0-0+0-0*0-0+9', '10*0+0-0+0-0*0*0+9', '10*0+0-0+0*0+0+0+9', '10*0+0-0+0*0+0-0+9', '10*0+0-0+0*0+0*0+9', '10*0+0-0+0*0-0+0+9', '10*0+0-0+0*0-0-0+9', '10*0+0-0+0*0-0*0+9', '10*0+0-0+0*0*0+0+9', '10*0+0-0+0*0*0-0+9', '10*0+0-0+0*0*0*0+9', '10*0+0-0-0+0+0+0+9', '10*0+0-0-0+0+0-0+9', '10*0+0-0-0+0+0*0+9', '10*0+0-0-0+0-0+0+9', '10*0+0-0-0+0-0-0+9', '10*0+0-0-0+0-0*0+9', '10*0+0-0-0+0*0+0+9', '10*0+0-0-0+0*0-0+9', '10*0+0-0-0+0*0*0+9', '10*0+0-0-0-0+0+0+9', '10*0+0-0-0-0+0-0+9', '10*0+0-0-0-0+0*0+9', '10*0+0-0-0-0-0+0+9', '10*0+0-0-0-0-0-0+9', '10*0+0-0-0-0-0*0+9', '10*0+0-0-0-0*0+0+9', '10*0+0-0-0-0*0-0+9', '10*0+0-0-0-0*0*0+9', '10*0+0-0-0*0+0+0+9', '10*0+0-0-0*0+0-0+9', '10*0+0-0-0*0+0*0+9', '10*0+0-0-0*0-0+0+9', '10*0+0-0-0*0-0-0+9', '10*0+0-0-0*0-0*0+9', '10*0+0-0-0*0*0+0+9', '10*0+0-0-0*0*0-0+9', '10*0+0-0-0*0*0*0+9', '10*0+0-0*0+0+0+0+9', '10*0+0-0*0+0+0-0+9', '10*0+0-0*0+0+0*0+9', '10*0+0-0*0+0-0+0+9', '10*0+0-0*0+0-0-0+9', '10*0+0-0*0+0-0*0+9', '10*0+0-0*0+0*0+0+9', '10*0+0-0*0+0*0-0+9', '10*0+0-0*0+0*0*0+9', '10*0+0-0*0-0+0+0+9', '10*0+0-0*0-0+0-0+9', '10*0+0-0*0-0+0*0+9', '10*0+0-0*0-0-0+0+9', '10*0+0-0*0-0-0-0+9', '10*0+0-0*0-0-0*0+9', '10*0+0-0*0-0*0+0+9', '10*0+0-0*0-0*0-0+9', '10*0+0-0*0-0*0*0+9', '10*0+0-0*0*0+0+0+9', '10*0+0-0*0*0+0-0+9', '10*0+0-0*0*0+0*0+9', '10*0+0-0*0*0-0+0+9', '10*0+0-0*0*0-0-0+9', '10*0+0-0*0*0-0*0+9', '10*0+0-0*0*0*0+0+9', '10*0+0-0*0*0*0-0+9', '10*0+0-0*0*0*0*0+9', '10*0+0*0+0+0+0+0+9', '10*0+0*0+0+0+0-0+9', '10*0+0*0+0+0+0*0+9', '10*0+0*0+0+0-0+0+9', '10*0+0*0+0+0-0-0+9', '10*0+0*0+0+0-0*0+9', '10*0+0*0+0+0*0+0+9', '10*0+0*0+0+0*0-0+9', '10*0+0*0+0+0*0*0+9', '10*0+0*0+0-0+0+0+9', '10*0+0*0+0-0+0-0+9', '10*0+0*0+0-0+0*0+9', '10*0+0*0+0-0-0+0+9', '10*0+0*0+0-0-0-0+9', '10*0+0*0+0-0-0*0+9', '10*0+0*0+0-0*0+0+9', '10*0+0*0+0-0*0-0+9', '10*0+0*0+0-0*0*0+9', '10*0+0*0+0*0+0+0+9', '10*0+0*0+0*0+0-0+9', '10*0+0*0+0*0+0*0+9', '10*0+0*0+0*0-0+0+9', '10*0+0*0+0*0-0-0+9', '10*0+0*0+0*0-0*0+9', '10*0+0*0+0*0*0+0+9', '10*0+0*0+0*0*0-0+9', '10*0+0*0+0*0*0*0+9', '10*0+0*0-0+0+0+0+9', '10*0+0*0-0+0+0-0+9', '10*0+0*0-0+0+0*0+9', '10*0+0*0-0+0-0+0+9', '10*0+0*0-0+0-0-0+9', '10*0+0*0-0+0-0*0+9', '10*0+0*0-0+0*0+0+9', '10*0+0*0-0+0*0-0+9', '10*0+0*0-0+0*0*0+9', '10*0+0*0-0-0+0+0+9', '10*0+0*0-0-0+0-0+9', '10*0+0*0-0-0+0*0+9', '10*0+0*0-0-0-0+0+9', '10*0+0*0-0-0-0-0+9', '10*0+0*0-0-0-0*0+9', '10*0+0*0-0-0*0+0+9', '10*0+0*0-0-0*0-0+9', '10*0+0*0-0-0*0*0+9', '10*0+0*0-0*0+0+0+9', '10*0+0*0-0*0+0-0+9', '10*0+0*0-0*0+0*0+9', '10*0+0*0-0*0-0+0+9', '10*0+0*0-0*0-0-0+9', '10*0+0*0-0*0-0*0+9', '10*0+0*0-0*0*0+0+9', '10*0+0*0-0*0*0-0+9', '10*0+0*0-0*0*0*0+9', '10*0+0*0*0+0+0+0+9', '10*0+0*0*0+0+0-0+9', '10*0+0*0*0+0+0*0+9', '10*0+0*0*0+0-0+0+9', '10*0+0*0*0+0-0-0+9', '10*0+0*0*0+0-0*0+9', '10*0+0*0*0+0*0+0+9', '10*0+0*0*0+0*0-0+9', '10*0+0*0*0+0*0*0+9', '10*0+0*0*0-0+0+0+9', '10*0+0*0*0-0+0-0+9', '10*0+0*0*0-0+0*0+9', '10*0+0*0*0-0-0+0+9', '10*0+0*0*0-0-0-0+9', '10*0+0*0*0-0-0*0+9', '10*0+0*0*0-0*0+0+9', '10*0+0*0*0-0*0-0+9', '10*0+0*0*0-0*0*0+9', '10*0+0*0*0*0+0+0+9', '10*0+0*0*0*0+0-0+9', '10*0+0*0*0*0+0*0+9', '10*0+0*0*0*0-0+0+9', '10*0+0*0*0*0-0-0+9', '10*0+0*0*0*0-0*0+9', '10*0+0*0*0*0*0+0+9', '10*0+0*0*0*0*0-0+9', '10*0+0*0*0*0*0*0+9', '10*0-0+0+0+0+0+0+9', '10*0-0+0+0+0+0-0+9', '10*0-0+0+0+0+0*0+9', '10*0-0+0+0+0-0+0+9', '10*0-0+0+0+0-0-0+9', '10*0-0+0+0+0-0*0+9', '10*0-0+0+0+0*0+0+9', '10*0-0+0+0+0*0-0+9', '10*0-0+0+0+0*0*0+9', '10*0-0+0+0-0+0+0+9', '10*0-0+0+0-0+0-0+9', '10*0-0+0+0-0+0*0+9', '10*0-0+0+0-0-0+0+9', '10*0-0+0+0-0-0-0+9', '10*0-0+0+0-0-0*0+9', '10*0-0+0+0-0*0+0+9', '10*0-0+0+0-0*0-0+9', '10*0-0+0+0-0*0*0+9', '10*0-0+0+0*0+0+0+9', '10*0-0+0+0*0+0-0+9', '10*0-0+0+0*0+0*0+9', '10*0-0+0+0*0-0+0+9', '10*0-0+0+0*0-0-0+9', '10*0-0+0+0*0-0*0+9', '10*0-0+0+0*0*0+0+9', '10*0-0+0+0*0*0-0+9', '10*0-0+0+0*0*0*0+9', '10*0-0+0-0+0+0+0+9', '10*0-0+0-0+0+0-0+9', '10*0-0+0-0+0+0*0+9', '10*0-0+0-0+0-0+0+9', '10*0-0+0-0+0-0-0+9', '10*0-0+0-0+0-0*0+9', '10*0-0+0-0+0*0+0+9', '10*0-0+0-0+0*0-0+9', '10*0-0+0-0+0*0*0+9', '10*0-0+0-0-0+0+0+9', '10*0-0+0-0-0+0-0+9', '10*0-0+0-0-0+0*0+9', '10*0-0+0-0-0-0+0+9', '10*0-0+0-0-0-0-0+9', '10*0-0+0-0-0-0*0+9', '10*0-0+0-0-0*0+0+9', '10*0-0+0-0-0*0-0+9', '10*0-0+0-0-0*0*0+9', '10*0-0+0-0*0+0+0+9', '10*0-0+0-0*0+0-0+9', '10*0-0+0-0*0+0*0+9', '10*0-0+0-0*0-0+0+9', '10*0-0+0-0*0-0-0+9', '10*0-0+0-0*0-0*0+9', '10*0-0+0-0*0*0+0+9', '10*0-0+0-0*0*0-0+9', '10*0-0+0-0*0*0*0+9', '10*0-0+0*0+0+0+0+9', '10*0-0+0*0+0+0-0+9', '10*0-0+0*0+0+0*0+9', '10*0-0+0*0+0-0+0+9', '10*0-0+0*0+0-0-0+9', '10*0-0+0*0+0-0*0+9', '10*0-0+0*0+0*0+0+9', '10*0-0+0*0+0*0-0+9', '10*0-0+0*0+0*0*0+9', '10*0-0+0*0-0+0+0+9', '10*0-0+0*0-0+0-0+9', '10*0-0+0*0-0+0*0+9', '10*0-0+0*0-0-0+0+9', '10*0-0+0*0-0-0-0+9', '10*0-0+0*0-0-0*0+9', '10*0-0+0*0-0*0+0+9', '10*0-0+0*0-0*0-0+9', '10*0-0+0*0-0*0*0+9', '10*0-0+0*0*0+0+0+9', '10*0-0+0*0*0+0-0+9', '10*0-0+0*0*0+0*0+9', '10*0-0+0*0*0-0+0+9', '10*0-0+0*0*0-0-0+9', '10*0-0+0*0*0-0*0+9', '10*0-0+0*0*0*0+0+9', '10*0-0+0*0*0*0-0+9', '10*0-0+0*0*0*0*0+9', '10*0-0-0+0+0+0+0+9', '10*0-0-0+0+0+0-0+9', '10*0-0-0+0+0+0*0+9', '10*0-0-0+0+0-0+0+9', '10*0-0-0+0+0-0-0+9', '10*0-0-0+0+0-0*0+9', '10*0-0-0+0+0*0+0+9', '10*0-0-0+0+0*0-0+9', '10*0-0-0+0+0*0*0+9', '10*0-0-0+0-0+0+0+9', '10*0-0-0+0-0+0-0+9', '10*0-0-0+0-0+0*0+9', '10*0-0-0+0-0-0+0+9', '10*0-0-0+0-0-0-0+9', '10*0-0-0+0-0-0*0+9', '10*0-0-0+0-0*0+0+9', '10*0-0-0+0-0*0-0+9', '10*0-0-0+0-0*0*0+9', '10*0-0-0+0*0+0+0+9', '10*0-0-0+0*0+0-0+9', '10*0-0-0+0*0+0*0+9', '10*0-0-0+0*0-0+0+9', '10*0-0-0+0*0-0-0+9', '10*0-0-0+0*0-0*0+9', '10*0-0-0+0*0*0+0+9', '10*0-0-0+0*0*0-0+9', '10*0-0-0+0*0*0*0+9', '10*0-0-0-0+0+0+0+9', '10*0-0-0-0+0+0-0+9', '10*0-0-0-0+0+0*0+9', '10*0-0-0-0+0-0+0+9', '10*0-0-0-0+0-0-0+9', '10*0-0-0-0+0-0*0+9', '10*0-0-0-0+0*0+0+9', '10*0-0-0-0+0*0-0+9', '10*0-0-0-0+0*0*0+9', '10*0-0-0-0-0+0+0+9', '10*0-0-0-0-0+0-0+9', '10*0-0-0-0-0+0*0+9', '10*0-0-0-0-0-0+0+9', '10*0-0-0-0-0-0-0+9', '10*0-0-0-0-0-0*0+9', '10*0-0-0-0-0*0+0+9', '10*0-0-0-0-0*0-0+9', '10*0-0-0-0-0*0*0+9', '10*0-0-0-0*0+0+0+9', '10*0-0-0-0*0+0-0+9', '10*0-0-0-0*0+0*0+9', '10*0-0-0-0*0-0+0+9', '10*0-0-0-0*0-0-0+9', '10*0-0-0-0*0-0*0+9', '10*0-0-0-0*0*0+0+9', '10*0-0-0-0*0*0-0+9', '10*0-0-0-0*0*0*0+9', '10*0-0-0*0+0+0+0+9', '10*0-0-0*0+0+0-0+9', '10*0-0-0*0+0+0*0+9', '10*0-0-0*0+0-0+0+9', '10*0-0-0*0+0-0-0+9', '10*0-0-0*0+0-0*0+9', '10*0-0-0*0+0*0+0+9', '10*0-0-0*0+0*0-0+9', '10*0-0-0*0+0*0*0+9', '10*0-0-0*0-0+0+0+9', '10*0-0-0*0-0+0-0+9', '10*0-0-0*0-0+0*0+9', '10*0-0-0*0-0-0+0+9', '10*0-0-0*0-0-0-0+9', '10*0-0-0*0-0-0*0+9', '10*0-0-0*0-0*0+0+9', '10*0-0-0*0-0*0-0+9', '10*0-0-0*0-0*0*0+9', '10*0-0-0*0*0+0+0+9', '10*0-0-0*0*0+0-0+9', '10*0-0-0*0*0+0*0+9', '10*0-0-0*0*0-0+0+9', '10*0-0-0*0*0-0-0+9', '10*0-0-0*0*0-0*0+9', '10*0-0-0*0*0*0+0+9', '10*0-0-0*0*0*0-0+9', '10*0-0-0*0*0*0*0+9', '10*0-0*0+0+0+0+0+9', '10*0-0*0+0+0+0-0+9', '10*0-0*0+0+0+0*0+9', '10*0-0*0+0+0-0+0+9', '10*0-0*0+0+0-0-0+9', '10*0-0*0+0+0-0*0+9', '10*0-0*0+0+0*0+0+9', '10*0-0*0+0+0*0-0+9', '10*0-0*0+0+0*0*0+9', '10*0-0*0+0-0+0+0+9', '10*0-0*0+0-0+0-0+9', '10*0-0*0+0-0+0*0+9', '10*0-0*0+0-0-0+0+9', '10*0-0*0+0-0-0-0+9', '10*0-0*0+0-0-0*0+9', '10*0-0*0+0-0*0+0+9', '10*0-0*0+0-0*0-0+9', '10*0-0*0+0-0*0*0+9', '10*0-0*0+0*0+0+0+9', '10*0-0*0+0*0+0-0+9', '10*0-0*0+0*0+0*0+9', '10*0-0*0+0*0-0+0+9', '10*0-0*0+0*0-0-0+9', '10*0-0*0+0*0-0*0+9', '10*0-0*0+0*0*0+0+9', '10*0-0*0+0*0*0-0+9', '10*0-0*0+0*0*0*0+9', '10*0-0*0-0+0+0+0+9', '10*0-0*0-0+0+0-0+9', '10*0-0*0-0+0+0*0+9', '10*0-0*0-0+0-0+0+9', '10*0-0*0-0+0-0-0+9', '10*0-0*0-0+0-0*0+9', '10*0-0*0-0+0*0+0+9', '10*0-0*0-0+0*0-0+9', '10*0-0*0-0+0*0*0+9', '10*0-0*0-0-0+0+0+9', '10*0-0*0-0-0+0-0+9', '10*0-0*0-0-0+0*0+9', '10*0-0*0-0-0-0+0+9', '10*0-0*0-0-0-0-0+9', '10*0-0*0-0-0-0*0+9', '10*0-0*0-0-0*0+0+9', '10*0-0*0-0-0*0-0+9', '10*0-0*0-0-0*0*0+9', '10*0-0*0-0*0+0+0+9', '10*0-0*0-0*0+0-0+9', '10*0-0*0-0*0+0*0+9', '10*0-0*0-0*0-0+0+9', '10*0-0*0-0*0-0-0+9', '10*0-0*0-0*0-0*0+9', '10*0-0*0-0*0*0+0+9', '10*0-0*0-0*0*0-0+9', '10*0-0*0-0*0*0*0+9', '10*0-0*0*0+0+0+0+9', '10*0-0*0*0+0+0-0+9', '10*0-0*0*0+0+0*0+9', '10*0-0*0*0+0-0+0+9', '10*0-0*0*0+0-0-0+9', '10*0-0*0*0+0-0*0+9', '10*0-0*0*0+0*0+0+9', '10*0-0*0*0+0*0-0+9', '10*0-0*0*0+0*0*0+9', '10*0-0*0*0-0+0+0+9', '10*0-0*0*0-0+0-0+9', '10*0-0*0*0-0+0*0+9', '10*0-0*0*0-0-0+0+9', '10*0-0*0*0-0-0-0+9', '10*0-0*0*0-0-0*0+9', '10*0-0*0*0-0*0+0+9', '10*0-0*0*0-0*0-0+9', '10*0-0*0*0-0*0*0+9', '10*0-0*0*0*0+0+0+9', '10*0-0*0*0*0+0-0+9', '10*0-0*0*0*0+0*0+9', '10*0-0*0*0*0-0+0+9', '10*0-0*0*0*0-0-0+9', '10*0-0*0*0*0-0*0+9', '10*0-0*0*0*0*0+0+9', '10*0-0*0*0*0*0-0+9', '10*0-0*0*0*0*0*0+9', '10*0*0+0+0+0+0+0+9', '10*0*0+0+0+0+0-0+9', '10*0*0+0+0+0+0*0+9', '10*0*0+0+0+0-0+0+9', '10*0*0+0+0+0-0-0+9', '10*0*0+0+0+0-0*0+9', '10*0*0+0+0+0*0+0+9', '10*0*0+0+0+0*0-0+9', '10*0*0+0+0+0*0*0+9', '10*0*0+0+0-0+0+0+9', '10*0*0+0+0-0+0-0+9', '10*0*0+0+0-0+0*0+9', '10*0*0+0+0-0-0+0+9', '10*0*0+0+0-0-0-0+9', '10*0*0+0+0-0-0*0+9', '10*0*0+0+0-0*0+0+9', '10*0*0+0+0-0*0-0+9', '10*0*0+0+0-0*0*0+9', '10*0*0+0+0*0+0+0+9', '10*0*0+0+0*0+0-0+9', '10*0*0+0+0*0+0*0+9', '10*0*0+0+0*0-0+0+9', '10*0*0+0+0*0-0-0+9', '10*0*0+0+0*0-0*0+9', '10*0*0+0+0*0*0+0+9', '10*0*0+0+0*0*0-0+9', '10*0*0+0+0*0*0*0+9', '10*0*0+0-0+0+0+0+9', '10*0*0+0-0+0+0-0+9', '10*0*0+0-0+0+0*0+9', '10*0*0+0-0+0-0+0+9', '10*0*0+0-0+0-0-0+9', '10*0*0+0-0+0-0*0+9', '10*0*0+0-0+0*0+0+9', '10*0*0+0-0+0*0-0+9', '10*0*0+0-0+0*0*0+9', '10*0*0+0-0-0+0+0+9', '10*0*0+0-0-0+0-0+9', '10*0*0+0-0-0+0*0+9', '10*0*0+0-0-0-0+0+9', '10*0*0+0-0-0-0-0+9', '10*0*0+0-0-0-0*0+9', '10*0*0+0-0-0*0+0+9', '10*0*0+0-0-0*0-0+9', '10*0*0+0-0-0*0*0+9', '10*0*0+0-0*0+0+0+9', '10*0*0+0-0*0+0-0+9', '10*0*0+0-0*0+0*0+9', '10*0*0+0-0*0-0+0+9', '10*0*0+0-0*0-0-0+9', '10*0*0+0-0*0-0*0+9', '10*0*0+0-0*0*0+0+9', '10*0*0+0-0*0*0-0+9', '10*0*0+0-0*0*0*0+9', '10*0*0+0*0+0+0+0+9', '10*0*0+0*0+0+0-0+9', '10*0*0+0*0+0+0*0+9', '10*0*0+0*0+0-0+0+9', '10*0*0+0*0+0-0-0+9', '10*0*0+0*0+0-0*0+9', '10*0*0+0*0+0*0+0+9', '10*0*0+0*0+0*0-0+9', '10*0*0+0*0+0*0*0+9', '10*0*0+0*0-0+0+0+9', '10*0*0+0*0-0+0-0+9', '10*0*0+0*0-0+0*0+9', '10*0*0+0*0-0-0+0+9', '10*0*0+0*0-0-0-0+9', '10*0*0+0*0-0-0*0+9', '10*0*0+0*0-0*0+0+9', '10*0*0+0*0-0*0-0+9', '10*0*0+0*0-0*0*0+9', '10*0*0+0*0*0+0+0+9', '10*0*0+0*0*0+0-0+9', '10*0*0+0*0*0+0*0+9', '10*0*0+0*0*0-0+0+9', '10*0*0+0*0*0-0-0+9', '10*0*0+0*0*0-0*0+9', '10*0*0+0*0*0*0+0+9', '10*0*0+0*0*0*0-0+9', '10*0*0+0*0*0*0*0+9', '10*0*0-0+0+0+0+0+9', '10*0*0-0+0+0+0-0+9', '10*0*0-0+0+0+0*0+9', '10*0*0-0+0+0-0+0+9', '10*0*0-0+0+0-0-0+9', '10*0*0-0+0+0-0*0+9', '10*0*0-0+0+0*0+0+9', '10*0*0-0+0+0*0-0+9', '10*0*0-0+0+0*0*0+9', '10*0*0-0+0-0+0+0+9', '10*0*0-0+0-0+0-0+9', '10*0*0-0+0-0+0*0+9', '10*0*0-0+0-0-0+0+9', '10*0*0-0+0-0-0-0+9', '10*0*0-0+0-0-0*0+9', '10*0*0-0+0-0*0+0+9', '10*0*0-0+0-0*0-0+9', '10*0*0-0+0-0*0*0+9', '10*0*0-0+0*0+0+0+9', '10*0*0-0+0*0+0-0+9', '10*0*0-0+0*0+0*0+9', '10*0*0-0+0*0-0+0+9', '10*0*0-0+0*0-0-0+9', '10*0*0-0+0*0-0*0+9', '10*0*0-0+0*0*0+0+9', '10*0*0-0+0*0*0-0+9', '10*0*0-0+0*0*0*0+9', '10*0*0-0-0+0+0+0+9', '10*0*0-0-0+0+0-0+9', '10*0*0-0-0+0+0*0+9', '10*0*0-0-0+0-0+0+9', '10*0*0-0-0+0-0-0+9', '10*0*0-0-0+0-0*0+9', '10*0*0-0-0+0*0+0+9', '10*0*0-0-0+0*0-0+9', '10*0*0-0-0+0*0*0+9', '10*0*0-0-0-0+0+0+9', '10*0*0-0-0-0+0-0+9', '10*0*0-0-0-0+0*0+9', '10*0*0-0-0-0-0+0+9', '10*0*0-0-0-0-0-0+9', '10*0*0-0-0-0-0*0+9', '10*0*0-0-0-0*0+0+9', '10*0*0-0-0-0*0-0+9', '10*0*0-0-0-0*0*0+9', '10*0*0-0-0*0+0+0+9', '10*0*0-0-0*0+0-0+9', '10*0*0-0-0*0+0*0+9', '10*0*0-0-0*0-0+0+9', '10*0*0-0-0*0-0-0+9', '10*0*0-0-0*0-0*0+9', '10*0*0-0-0*0*0+0+9', '10*0*0-0-0*0*0-0+9', '10*0*0-0-0*0*0*0+9', '10*0*0-0*0+0+0+0+9', '10*0*0-0*0+0+0-0+9', '10*0*0-0*0+0+0*0+9', '10*0*0-0*0+0-0+0+9', '10*0*0-0*0+0-0-0+9', '10*0*0-0*0+0-0*0+9', '10*0*0-0*0+0*0+0+9', '10*0*0-0*0+0*0-0+9', '10*0*0-0*0+0*0*0+9', '10*0*0-0*0-0+0+0+9', '10*0*0-0*0-0+0-0+9', '10*0*0-0*0-0+0*0+9', '10*0*0-0*0-0-0+0+9', '10*0*0-0*0-0-0-0+9', '10*0*0-0*0-0-0*0+9', '10*0*0-0*0-0*0+0+9', '10*0*0-0*0-0*0-0+9', '10*0*0-0*0-0*0*0+9', '10*0*0-0*0*0+0+0+9', '10*0*0-0*0*0+0-0+9', '10*0*0-0*0*0+0*0+9', '10*0*0-0*0*0-0+0+9', '10*0*0-0*0*0-0-0+9', '10*0*0-0*0*0-0*0+9', '10*0*0-0*0*0*0+0+9', '10*0*0-0*0*0*0-0+9', '10*0*0-0*0*0*0*0+9', '10*0*0*0+0+0+0+0+9', '10*0*0*0+0+0+0-0+9', '10*0*0*0+0+0+0*0+9', '10*0*0*0+0+0-0+0+9', '10*0*0*0+0+0-0-0+9', '10*0*0*0+0+0-0*0+9', '10*0*0*0+0+0*0+0+9', '10*0*0*0+0+0*0-0+9', '10*0*0*0+0+0*0*0+9', '10*0*0*0+0-0+0+0+9', '10*0*0*0+0-0+0-0+9', '10*0*0*0+0-0+0*0+9', '10*0*0*0+0-0-0+0+9', '10*0*0*0+0-0-0-0+9', '10*0*0*0+0-0-0*0+9', '10*0*0*0+0-0*0+0+9', '10*0*0*0+0-0*0-0+9', '10*0*0*0+0-0*0*0+9', '10*0*0*0+0*0+0+0+9', '10*0*0*0+0*0+0-0+9', '10*0*0*0+0*0+0*0+9', '10*0*0*0+0*0-0+0+9', '10*0*0*0+0*0-0-0+9', '10*0*0*0+0*0-0*0+9', '10*0*0*0+0*0*0+0+9', '10*0*0*0+0*0*0-0+9', '10*0*0*0+0*0*0*0+9', '10*0*0*0-0+0+0+0+9', '10*0*0*0-0+0+0-0+9', '10*0*0*0-0+0+0*0+9', '10*0*0*0-0+0-0+0+9', '10*0*0*0-0+0-0-0+9', '10*0*0*0-0+0-0*0+9', '10*0*0*0-0+0*0+0+9', '10*0*0*0-0+0*0-0+9', '10*0*0*0-0+0*0*0+9', '10*0*0*0-0-0+0+0+9', '10*0*0*0-0-0+0-0+9', '10*0*0*0-0-0+0*0+9', '10*0*0*0-0-0-0+0+9', '10*0*0*0-0-0-0-0+9', '10*0*0*0-0-0-0*0+9', '10*0*0*0-0-0*0+0+9', '10*0*0*0-0-0*0-0+9', '10*0*0*0-0-0*0*0+9', '10*0*0*0-0*0+0+0+9', '10*0*0*0-0*0+0-0+9', '10*0*0*0-0*0+0*0+9', '10*0*0*0-0*0-0+0+9', '10*0*0*0-0*0-0-0+9', '10*0*0*0-0*0-0*0+9', '10*0*0*0-0*0*0+0+9', '10*0*0*0-0*0*0-0+9', '10*0*0*0-0*0*0*0+9', '10*0*0*0*0+0+0+0+9', '10*0*0*0*0+0+0-0+9', '10*0*0*0*0+0+0*0+9', '10*0*0*0*0+0-0+0+9', '10*0*0*0*0+0-0-0+9', '10*0*0*0*0+0-0*0+9', '10*0*0*0*0+0*0+0+9', '10*0*0*0*0+0*0-0+9', '10*0*0*0*0+0*0*0+9', '10*0*0*0*0-0+0+0+9', '10*0*0*0*0-0+0-0+9', '10*0*0*0*0-0+0*0+9', '10*0*0*0*0-0-0+0+9', '10*0*0*0*0-0-0-0+9', '10*0*0*0*0-0-0*0+9', '10*0*0*0*0-0*0+0+9', '10*0*0*0*0-0*0-0+9', '10*0*0*0*0-0*0*0+9', '10*0*0*0*0*0+0+0+9', '10*0*0*0*0*0+0-0+9', '10*0*0*0*0*0+0*0+9', '10*0*0*0*0*0-0+0+9', '10*0*0*0*0*0-0-0+9', '10*0*0*0*0*0-0*0+9', '10*0*0*0*0*0*0+0+9', '10*0*0*0*0*0*0-0+9', '10*0*0*0*0*0*0*0+9', '100*0+0+0+0+0+0+9', '100*0+0+0+0+0-0+9', '100*0+0+0+0+0*0+9', '100*0+0+0+0-0+0+9', '100*0+0+0+0-0-0+9', '100*0+0+0+0-0*0+9', '100*0+0+0+0*0+0+9', '100*0+0+0+0*0-0+9', '100*0+0+0+0*0*0+9', '100*0+0+0-0+0+0+9', '100*0+0+0-0+0-0+9', '100*0+0+0-0+0*0+9', '100*0+0+0-0-0+0+9', '100*0+0+0-0-0-0+9', '100*0+0+0-0-0*0+9', '100*0+0+0-0*0+0+9', '100*0+0+0-0*0-0+9', '100*0+0+0-0*0*0+9', '100*0+0+0*0+0+0+9', '100*0+0+0*0+0-0+9', '100*0+0+0*0+0*0+9', '100*0+0+0*0-0+0+9', '100*0+0+0*0-0-0+9', '100*0+0+0*0-0*0+9', '100*0+0+0*0*0+0+9', '100*0+0+0*0*0-0+9', '100*0+0+0*0*0*0+9', '100*0+0-0+0+0+0+9', '100*0+0-0+0+0-0+9', '100*0+0-0+0+0*0+9', '100*0+0-0+0-0+0+9', '100*0+0-0+0-0-0+9', '100*0+0-0+0-0*0+9', '100*0+0-0+0*0+0+9', '100*0+0-0+0*0-0+9', '100*0+0-0+0*0*0+9', '100*0+0-0-0+0+0+9', '100*0+0-0-0+0-0+9', '100*0+0-0-0+0*0+9', '100*0+0-0-0-0+0+9', '100*0+0-0-0-0-0+9', '100*0+0-0-0-0*0+9', '100*0+0-0-0*0+0+9', '100*0+0-0-0*0-0+9', '100*0+0-0-0*0*0+9', '100*0+0-0*0+0+0+9', '100*0+0-0*0+0-0+9', '100*0+0-0*0+0*0+9', '100*0+0-0*0-0+0+9', '100*0+0-0*0-0-0+9', '100*0+0-0*0-0*0+9', '100*0+0-0*0*0+0+9', '100*0+0-0*0*0-0+9', '100*0+0-0*0*0*0+9', '100*0+0*0+0+0+0+9', '100*0+0*0+0+0-0+9', '100*0+0*0+0+0*0+9', '100*0+0*0+0-0+0+9', '100*0+0*0+0-0-0+9', '100*0+0*0+0-0*0+9', '100*0+0*0+0*0+0+9', '100*0+0*0+0*0-0+9', '100*0+0*0+0*0*0+9', '100*0+0*0-0+0+0+9', '100*0+0*0-0+0-0+9', '100*0+0*0-0+0*0+9', '100*0+0*0-0-0+0+9', '100*0+0*0-0-0-0+9', '100*0+0*0-0-0*0+9', '100*0+0*0-0*0+0+9', '100*0+0*0-0*0-0+9', '100*0+0*0-0*0*0+9', '100*0+0*0*0+0+0+9', '100*0+0*0*0+0-0+9', '100*0+0*0*0+0*0+9', '100*0+0*0*0-0+0+9', '100*0+0*0*0-0-0+9', '100*0+0*0*0-0*0+9', '100*0+0*0*0*0+0+9', '100*0+0*0*0*0-0+9', '100*0+0*0*0*0*0+9', '100*0-0+0+0+0+0+9', '100*0-0+0+0+0-0+9', '100*0-0+0+0+0*0+9', '100*0-0+0+0-0+0+9', '100*0-0+0+0-0-0+9', '100*0-0+0+0-0*0+9', '100*0-0+0+0*0+0+9', '100*0-0+0+0*0-0+9', '100*0-0+0+0*0*0+9', '100*0-0+0-0+0+0+9', '100*0-0+0-0+0-0+9', '100*0-0+0-0+0*0+9', '100*0-0+0-0-0+0+9', '100*0-0+0-0-0-0+9', '100*0-0+0-0-0*0+9', '100*0-0+0-0*0+0+9', '100*0-0+0-0*0-0+9', '100*0-0+0-0*0*0+9', '100*0-0+0*0+0+0+9', '100*0-0+0*0+0-0+9', '100*0-0+0*0+0*0+9', '100*0-0+0*0-0+0+9', '100*0-0+0*0-0-0+9', '100*0-0+0*0-0*0+9', '100*0-0+0*0*0+0+9', '100*0-0+0*0*0-0+9', '100*0-0+0*0*0*0+9', '100*0-0-0+0+0+0+9', '100*0-0-0+0+0-0+9', '100*0-0-0+0+0*0+9', '100*0-0-0+0-0+0+9', '100*0-0-0+0-0-0+9', '100*0-0-0+0-0*0+9', '100*0-0-0+0*0+0+9', '100*0-0-0+0*0-0+9', '100*0-0-0+0*0*0+9', '100*0-0-0-0+0+0+9', '100*0-0-0-0+0-0+9', '100*0-0-0-0+0*0+9', '100*0-0-0-0-0+0+9', '100*0-0-0-0-0-0+9', '100*0-0-0-0-0*0+9', '100*0-0-0-0*0+0+9', '100*0-0-0-0*0-0+9', '100*0-0-0-0*0*0+9', '100*0-0-0*0+0+0+9', '100*0-0-0*0+0-0+9', '100*0-0-0*0+0*0+9', '100*0-0-0*0-0+0+9', '100*0-0-0*0-0-0+9', '100*0-0-0*0-0*0+9', '100*0-0-0*0*0+0+9', '100*0-0-0*0*0-0+9', '100*0-0-0*0*0*0+9', '100*0-0*0+0+0+0+9', '100*0-0*0+0+0-0+9', '100*0-0*0+0+0*0+9', '100*0-0*0+0-0+0+9', '100*0-0*0+0-0-0+9', '100*0-0*0+0-0*0+9', '100*0-0*0+0*0+0+9', '100*0-0*0+0*0-0+9', '100*0-0*0+0*0*0+9', '100*0-0*0-0+0+0+9', '100*0-0*0-0+0-0+9', '100*0-0*0-0+0*0+9', '100*0-0*0-0-0+0+9', '100*0-0*0-0-0-0+9', '100*0-0*0-0-0*0+9', '100*0-0*0-0*0+0+9', '100*0-0*0-0*0-0+9', '100*0-0*0-0*0*0+9', '100*0-0*0*0+0+0+9', '100*0-0*0*0+0-0+9', '100*0-0*0*0+0*0+9', '100*0-0*0*0-0+0+9', '100*0-0*0*0-0-0+9', '100*0-0*0*0-0*0+9', '100*0-0*0*0*0+0+9', '100*0-0*0*0*0-0+9', '100*0-0*0*0*0*0+9', '100*0*0+0+0+0+0+9', '100*0*0+0+0+0-0+9', '100*0*0+0+0+0*0+9', '100*0*0+0+0-0+0+9', '100*0*0+0+0-0-0+9', '100*0*0+0+0-0*0+9', '100*0*0+0+0*0+0+9', '100*0*0+0+0*0-0+9', '100*0*0+0+0*0*0+9', '100*0*0+0-0+0+0+9', '100*0*0+0-0+0-0+9', '100*0*0+0-0+0*0+9', '100*0*0+0-0-0+0+9', '100*0*0+0-0-0-0+9', '100*0*0+0-0-0*0+9', '100*0*0+0-0*0+0+9', '100*0*0+0-0*0-0+9', '100*0*0+0-0*0*0+9', '100*0*0+0*0+0+0+9', '100*0*0+0*0+0-0+9', '100*0*0+0*0+0*0+9', '100*0*0+0*0-0+0+9', '100*0*0+0*0-0-0+9', '100*0*0+0*0-0*0+9', '100*0*0+0*0*0+0+9', '100*0*0+0*0*0-0+9', '100*0*0+0*0*0*0+9', '100*0*0-0+0+0+0+9', '100*0*0-0+0+0-0+9', '100*0*0-0+0+0*0+9', '100*0*0-0+0-0+0+9', '100*0*0-0+0-0-0+9', '100*0*0-0+0-0*0+9', '100*0*0-0+0*0+0+9', '100*0*0-0+0*0-0+9', '100*0*0-0+0*0*0+9', '100*0*0-0-0+0+0+9', '100*0*0-0-0+0-0+9', '100*0*0-0-0+0*0+9', '100*0*0-0-0-0+0+9', '100*0*0-0-0-0-0+9', '100*0*0-0-0-0*0+9', '100*0*0-0-0*0+0+9', '100*0*0-0-0*0-0+9', '100*0*0-0-0*0*0+9', '100*0*0-0*0+0+0+9', '100*0*0-0*0+0-0+9', '100*0*0-0*0+0*0+9', '100*0*0-0*0-0+0+9', '100*0*0-0*0-0-0+9', '100*0*0-0*0-0*0+9', '100*0*0-0*0*0+0+9', '100*0*0-0*0*0-0+9', '100*0*0-0*0*0*0+9', '100*0*0*0+0+0+0+9', '100*0*0*0+0+0-0+9', '100*0*0*0+0+0*0+9', '100*0*0*0+0-0+0+9', '100*0*0*0+0-0-0+9', '100*0*0*0+0-0*0+9', '100*0*0*0+0*0+0+9', '100*0*0*0+0*0-0+9', '100*0*0*0+0*0*0+9', '100*0*0*0-0+0+0+9', '100*0*0*0-0+0-0+9', '100*0*0*0-0+0*0+9', '100*0*0*0-0-0+0+9', '100*0*0*0-0-0-0+9', '100*0*0*0-0-0*0+9', '100*0*0*0-0*0+0+9', '100*0*0*0-0*0-0+9', '100*0*0*0-0*0*0+9', '100*0*0*0*0+0+0+9', '100*0*0*0*0+0-0+9', '100*0*0*0*0+0*0+9', '100*0*0*0*0-0+0+9', '100*0*0*0*0-0-0+9', '100*0*0*0*0-0*0+9', '100*0*0*0*0*0+0+9', '100*0*0*0*0*0-0+9', '100*0*0*0*0*0*0+9', '1000*0+0+0+0+0+9', '1000*0+0+0+0-0+9', '1000*0+0+0+0*0+9', '1000*0+0+0-0+0+9', '1000*0+0+0-0-0+9', '1000*0+0+0-0*0+9', '1000*0+0+0*0+0+9', '1000*0+0+0*0-0+9', '1000*0+0+0*0*0+9', '1000*0+0-0+0+0+9', '1000*0+0-0+0-0+9', '1000*0+0-0+0*0+9', '1000*0+0-0-0+0+9', '1000*0+0-0-0-0+9', '1000*0+0-0-0*0+9', '1000*0+0-0*0+0+9', '1000*0+0-0*0-0+9', '1000*0+0-0*0*0+9', '1000*0+0*0+0+0+9', '1000*0+0*0+0-0+9', '1000*0+0*0+0*0+9', '1000*0+0*0-0+0+9', '1000*0+0*0-0-0+9', '1000*0+0*0-0*0+9', '1000*0+0*0*0+0+9', '1000*0+0*0*0-0+9', '1000*0+0*0*0*0+9', '1000*0-0+0+0+0+9', '1000*0-0+0+0-0+9', '1000*0-0+0+0*0+9', '1000*0-0+0-0+0+9', '1000*0-0+0-0-0+9', '1000*0-0+0-0*0+9', '1000*0-0+0*0+0+9', '1000*0-0+0*0-0+9', '1000*0-0+0*0*0+9', '1000*0-0-0+0+0+9', '1000*0-0-0+0-0+9', '1000*0-0-0+0*0+9', '1000*0-0-0-0+0+9', '1000*0-0-0-0-0+9', '1000*0-0-0-0*0+9', '1000*0-0-0*0+0+9', '1000*0-0-0*0-0+9', '1000*0-0-0*0*0+9', '1000*0-0*0+0+0+9', '1000*0-0*0+0-0+9', '1000*0-0*0+0*0+9', '1000*0-0*0-0+0+9', '1000*0-0*0-0-0+9', '1000*0-0*0-0*0+9', '1000*0-0*0*0+0+9', '1000*0-0*0*0-0+9', '1000*0-0*0*0*0+9', '1000*0*0+0+0+0+9', '1000*0*0+0+0-0+9', '1000*0*0+0+0*0+9', '1000*0*0+0-0+0+9', '1000*0*0+0-0-0+9', '1000*0*0+0-0*0+9', '1000*0*0+0*0+0+9', '1000*0*0+0*0-0+9', '1000*0*0+0*0*0+9', '1000*0*0-0+0+0+9', '1000*0*0-0+0-0+9', '1000*0*0-0+0*0+9', '1000*0*0-0-0+0+9', '1000*0*0-0-0-0+9', '1000*0*0-0-0*0+9', '1000*0*0-0*0+0+9', '1000*0*0-0*0-0+9', '1000*0*0-0*0*0+9', '1000*0*0*0+0+0+9', '1000*0*0*0+0-0+9', '1000*0*0*0+0*0+9', '1000*0*0*0-0+0+9', '1000*0*0*0-0-0+9', '1000*0*0*0-0*0+9', '1000*0*0*0*0+0+9', '1000*0*0*0*0-0+9', '1000*0*0*0*0*0+9', '10000*0+0+0+0+9', '10000*0+0+0-0+9', '10000*0+0+0*0+9', '10000*0+0-0+0+9', '10000*0+0-0-0+9', '10000*0+0-0*0+9', '10000*0+0*0+0+9', '10000*0+0*0-0+9', '10000*0+0*0*0+9', '10000*0-0+0+0+9', '10000*0-0+0-0+9', '10000*0-0+0*0+9', '10000*0-0-0+0+9', '10000*0-0-0-0+9', '10000*0-0-0*0+9', '10000*0-0*0+0+9', '10000*0-0*0-0+9', '10000*0-0*0*0+9', '10000*0*0+0+0+9', '10000*0*0+0-0+9', '10000*0*0+0*0+9', '10000*0*0-0+0+9', '10000*0*0-0-0+9', '10000*0*0-0*0+9', '10000*0*0*0+0+9', '10000*0*0*0-0+9', '10000*0*0*0*0+9', '100000*0+0+0+9', '100000*0+0-0+9', '100000*0+0*0+9', '100000*0-0+0+9', '100000*0-0-0+9', '100000*0-0*0+9', '100000*0*0+0+9', '100000*0*0-0+9', '100000*0*0*0+9', '1000000*0+0+9', '1000000*0-0+9', '1000000*0*0+9', '10000000*0+9']",
            "[]",
            "['999999999']",
            "['0+1']",
            "['1+2*3+4', '1-2+3*4', '12+3-4']"
        ],
        "boilerplate": "class Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        ",
        "compare_func": "return sorted(result) == sorted(eval(expected))"
    },
    {
        "title": "Remove Invalid Parentheses",
        "source": "https://leetcode.com/problems/remove-invalid-parentheses/",
        "description": "<p>Given a string <code>s</code> that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.</p>\n\n<p>Return <em>a list of <strong>unique strings</strong> that are valid with the minimum number of removals</em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;()())()&quot;\n<strong>Output:</strong> [&quot;(())()&quot;,&quot;()()()&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(a)())()&quot;\n<strong>Output:</strong> [&quot;(a())()&quot;,&quot;(a)()()&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;)(&quot;\n<strong>Output:</strong> [&quot;&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 25</code></li>\n\t<li><code>s</code> consists of lowercase English letters and parentheses <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>.</li>\n\t<li>There will be at most <code>20</code> parentheses in <code>s</code>.</li>\n</ul>\n",
        "difficulty": "hard",
        "sample_test_cases": [
            "removeInvalidParentheses(\"()())()\")",
            "removeInvalidParentheses(\"(a)())()\")",
            "removeInvalidParentheses(\")(\")"
        ],
        "sample_test_results": [
            "['(())()', '()()()']",
            "['(a())()', '(a)()()']",
            "['']"
        ],
        "hidden_test_cases": [
            "removeInvalidParentheses(\"()())()\")",
            "removeInvalidParentheses(\"(a)())()\")",
            "removeInvalidParentheses(\")(\")",
            "removeInvalidParentheses(\"((()\")",
            "removeInvalidParentheses(\")()\")",
            "removeInvalidParentheses(\"(())())\")",
            "removeInvalidParentheses(\"())()(((\")",
            "removeInvalidParentheses(\"(a)(b)(c))(\")",
            "removeInvalidParentheses(\")()(\")",
            "removeInvalidParentheses(\"((())\")"
        ],
        "hidden_test_results": [
            "['(())()', '()()()']",
            "['(a())()', '(a)()()']",
            "['']",
            "['()']",
            "['()']",
            "['(()())', '(())()']",
            "['()()']",
            "['(a(b)(c))', '(a)(b(c))', '(a)(b)(c)']",
            "['()']",
            "['(())']"
        ],
        "boilerplate": "class Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        ",
        "compare_func": "return sorted(result) == sorted(eval(expected))"
    }
]